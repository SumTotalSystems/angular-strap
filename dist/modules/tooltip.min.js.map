{"version":3,"sources":["modules/tooltip.js"],"names":["angular","target","provider","placement","this","defaults","templateUrl","template","titleTemplate","trigger","keyboard","html","show","title","type","delay","autoClose","bsEnabled","mouseDownPreventDefault","mouseDownStopPropagation","viewport","selector","padding","TooltipFactory","$get","promise","$tooltip","$bsCompiler","compile","options","split","length","clearTimeout","hoverState","prefixEvent","hide","isFunction","onShow","leaveAnimateCallback","scope","$emit","destroyTipElement","onHide","_tipToHide","evt","preventDefault","element","triggers","on","forEach","enter","isTouch","unbindTriggerEvents","i","leave","off","bindKeyboardEvents","tipElement","$onKeyUp","unbindKeyboardEvents","_autoCloseEventsBinded","bindAutoCloseEvents","$timeout","$body","unbindAutoCloseEvents","stopEventPropagation","event","getPosition","$element","elRect","getBoundingClientRect","rect","p","width","height","top","left","extend","dimensions","offset","el","scroll","outerDims","isBody","document","documentElement","scrollTop","body","prop","clientWidth","innerHeight","position","actualWidth","actualHeight","marginLeft","isNaN","setOffset","using","parseInt","props","css","right","marginTop","tip","offsetHeight","getViewportAdjustedDelta","delta","offsetWidth","isVertical","arrowDelta","replaceArrow","arrowOffsetPosition","viewportDimensions","$viewport","topEdgeOffset","bottomEdgeOffset","viewportPadding","test","leftEdgeOffset","rightEdgeOffset","dimension","isHorizontal","findElement","$arrow","timeout","$isShown","tipScope","$destroy","$$phase","$options","config","$promise","$scope","$new","$rootScope","$id","attr","map","parseFloat","$sce","trustAsHtml","$setEnabled","$$postDigest","id","$hide","setEnabled","isEnabled","toggle","compileData","then","data","tipContainer","init","container","bindTriggerEvents","isElement","destroy","focus","isDefined","onBeforeShow","after","parent","lastChild","display","visibility","link","clonedElement","animation","addClass","prefixClass","safeDigest","version","prepend","$$rAF","$applyPlacement","$animate","enterAnimateCallback","_blur","onBeforeHide","blur","autoPlace","autoToken","elementPosition","tipWidth","tipHeight","replace","viewportPosition","originalPlacement","removeClass","tipPosition","getCalculatedOffset","applyPlacement","stopPropagation","directive","$root","$digest","restrict","query","querySelectorAll","isNative","isString","tooltip","transclusion","falseValueRegExp","key","$eval","bsKey","dataTarget","slice","hasOwnProperty","oldValue","$observe","newValue","bsTooltip","bsShow","$watch","match","setViewport","$on"],"mappings":"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","file":"modules/tooltip.min.js","sourcesContent":["'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\r\n\r\n  .provider('$tooltip', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      customClass: '',\r\n      prefixClass: 'tooltip',\r\n      prefixEvent: 'tooltip',\r\n      container: false,\r\n      target: false,\r\n      placement: 'top',\r\n      templateUrl: 'tooltip/tooltip.tpl.html',\r\n      template: '',\r\n      titleTemplate: false,\r\n      trigger: 'hover focus',\r\n      keyboard: false,\r\n      html: false,\r\n      show: false,\r\n      title: '',\r\n      type: '',\r\n      delay: 0,\r\n      autoClose: false,\r\n      bsEnabled: true,\r\n      mouseDownPreventDefault: true,\r\n      mouseDownStopPropagation: true,\r\n      viewport: {\r\n        selector: 'body',\r\n        padding: 0\r\n      }\r\n    };\r\n\r\n    this.$get = function ($window, $rootScope, $bsCompiler, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\r\n\r\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n      var isTouch = ('createTouch' in $window.document) && isNative;\r\n      var $body = angular.element($window.document);\r\n\r\n      function TooltipFactory (element, config) {\r\n\r\n        var $tooltip = {};\r\n\r\n        // Common vars\r\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\r\n        var promise = $tooltip.$promise = $bsCompiler.compile(options);\r\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\r\n\r\n        // var nodeName = element[0].nodeName.toLowerCase();\r\n        if (options.delay && angular.isString(options.delay)) {\r\n          var split = options.delay.split(',').map(parseFloat);\r\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\r\n        }\r\n\r\n        // Store $id to identify the triggering element in events\r\n        // give priority to options.id, otherwise, try to use\r\n        // element id if defined\r\n        $tooltip.$id = options.id || element.attr('id') || '';\r\n\r\n        // Support scope as string options\r\n        if (options.title) {\r\n          scope.title = $sce.trustAsHtml(options.title);\r\n        }\r\n\r\n        // Provide scope helpers\r\n        scope.$setEnabled = function (isEnabled) {\r\n          scope.$$postDigest(function () {\r\n            $tooltip.setEnabled(isEnabled);\r\n          });\r\n        };\r\n        scope.$hide = function () {\r\n          scope.$$postDigest(function () {\r\n            $tooltip.hide();\r\n          });\r\n        };\r\n        scope.$show = function () {\r\n          scope.$$postDigest(function () {\r\n            $tooltip.show();\r\n          });\r\n        };\r\n        scope.$toggle = function () {\r\n          scope.$$postDigest(function () {\r\n            $tooltip.toggle();\r\n          });\r\n        };\r\n        // Publish isShown as a protected var on scope\r\n        $tooltip.$isShown = scope.$isShown = false;\r\n\r\n        // Private vars\r\n        var timeout;\r\n        var hoverState;\r\n\r\n        // Fetch, compile then initialize tooltip\r\n        var compileData;\r\n        var tipElement;\r\n        var tipContainer;\r\n        var tipScope;\r\n        promise.then(function (data) {\r\n          compileData = data;\r\n          $tooltip.init();\r\n        });\r\n\r\n        $tooltip.init = function () {\r\n\r\n          // Options: delay\r\n          if (options.delay && angular.isNumber(options.delay)) {\r\n            options.delay = {\r\n              show: options.delay,\r\n              hide: options.delay\r\n            };\r\n          }\r\n\r\n          // Replace trigger on touch devices ?\r\n          // if(isTouch && options.trigger === defaults.trigger) {\r\n          //   options.trigger.replace(/hover/g, 'click');\r\n          // }\r\n\r\n          // Options : container\r\n          if (options.container === 'self') {\r\n            tipContainer = element;\r\n          } else if (angular.isElement(options.container)) {\r\n            tipContainer = options.container;\r\n          } else if (options.container) {\r\n            tipContainer = findElement(options.container);\r\n          }\r\n\r\n          // Options: trigger\r\n          bindTriggerEvents();\r\n\r\n          // Options: target\r\n          if (options.target) {\r\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\r\n          }\r\n\r\n          // Options: show\r\n          if (options.show) {\r\n            scope.$$postDigest(function () {\r\n              if (options.trigger === 'focus') {\r\n                element[0].focus();\r\n              } else {\r\n                $tooltip.show();\r\n              }\r\n            });\r\n          }\r\n\r\n        };\r\n\r\n        $tooltip.destroy = function () {\r\n\r\n          // Unbind events\r\n          unbindTriggerEvents();\r\n\r\n          // Remove element\r\n          destroyTipElement();\r\n\r\n          // Destroy scope\r\n          scope.$destroy();\r\n\r\n        };\r\n\r\n        $tooltip.enter = function () {\r\n\r\n          clearTimeout(timeout);\r\n          hoverState = 'in';\r\n          if (!options.delay || !options.delay.show) {\r\n            return $tooltip.show();\r\n          }\r\n\r\n          timeout = setTimeout(function () {\r\n            if (hoverState === 'in') $tooltip.show();\r\n          }, options.delay.show);\r\n\r\n        };\r\n\r\n        $tooltip.show = function () {\r\n          if (!options.bsEnabled || $tooltip.$isShown) return;\r\n\r\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\r\n          if (angular.isDefined(options.onBeforeShow) && angular.isFunction(options.onBeforeShow)) {\r\n            options.onBeforeShow($tooltip);\r\n          }\r\n          var parent;\r\n          var after;\r\n          if (options.container) {\r\n            parent = tipContainer;\r\n            if (tipContainer[0].lastChild) {\r\n              after = angular.element(tipContainer[0].lastChild);\r\n            } else {\r\n              after = null;\r\n            }\r\n          } else {\r\n            parent = null;\r\n            after = element;\r\n          }\r\n\r\n\r\n          // Hide any existing tipElement\r\n          if (tipElement) destroyTipElement();\r\n          // Fetch a cloned element linked from template\r\n          tipScope = $tooltip.$scope.$new();\r\n          tipElement = $tooltip.$element = compileData.link(tipScope, function (clonedElement, scope) {});\r\n\r\n          // Set the initial positioning.  Make the tooltip invisible\r\n          // so IE doesn't try to focus on it off screen.\r\n          tipElement.css({top: '-9999px', left: '-9999px', right: 'auto', display: 'block', visibility: 'hidden'});\r\n\r\n          // Options: animation\r\n          if (options.animation) tipElement.addClass(options.animation);\r\n          // Options: type\r\n          if (options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\r\n          // Options: custom classes\r\n          if (options.customClass) tipElement.addClass(options.customClass);\r\n\r\n          // Append the element, without any animations.  If we append\r\n          // using $animate.enter, some of the animations cause the placement\r\n          // to be off due to the transforms.\r\n          if (after) {\r\n            after.after(tipElement);\r\n          } else {\r\n            parent.prepend(tipElement);\r\n          }\r\n\r\n          $tooltip.$isShown = scope.$isShown = true;\r\n          safeDigest(scope);\r\n\r\n          // Now, apply placement\r\n          $tooltip.$applyPlacement();\r\n\r\n          // Once placed, animate it.\r\n          // Support v1.2+ $animate\r\n          // https://github.com/angular/angular.js/issues/11713\r\n          if (angular.version.minor <= 2) {\r\n            $animate.enter(tipElement, parent, after, enterAnimateCallback);\r\n          } else {\r\n            $animate.enter(tipElement, parent, after).then(enterAnimateCallback);\r\n          }\r\n          safeDigest(scope);\r\n\r\n          $$rAF(function () {\r\n            // Once the tooltip is placed and the animation starts, make the tooltip visible\r\n            if (tipElement) tipElement.css({visibility: 'visible'});\r\n\r\n            // Bind events\r\n            if (options.keyboard) {\r\n              if (options.trigger !== 'focus') {\r\n                $tooltip.focus();\r\n              }\r\n              bindKeyboardEvents();\r\n            }\r\n          });\r\n\r\n          if (options.autoClose) {\r\n            bindAutoCloseEvents();\r\n          }\r\n\r\n        };\r\n\r\n        function enterAnimateCallback () {\r\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\r\n          if (angular.isDefined(options.onShow) && angular.isFunction(options.onShow)) {\r\n            options.onShow($tooltip);\r\n          }\r\n        }\r\n\r\n        $tooltip.leave = function () {\r\n\r\n          clearTimeout(timeout);\r\n          hoverState = 'out';\r\n          if (!options.delay || !options.delay.hide) {\r\n            return $tooltip.hide();\r\n          }\r\n          timeout = setTimeout(function () {\r\n            if (hoverState === 'out') {\r\n              $tooltip.hide();\r\n            }\r\n          }, options.delay.hide);\r\n\r\n        };\r\n\r\n        var _blur;\r\n        var _tipToHide;\r\n        $tooltip.hide = function (blur) {\r\n\r\n          if (!$tooltip.$isShown) return;\r\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\r\n          if (angular.isDefined(options.onBeforeHide) && angular.isFunction(options.onBeforeHide)) {\r\n            options.onBeforeHide($tooltip);\r\n          }\r\n\r\n          // store blur value for leaveAnimateCallback to use\r\n          _blur = blur;\r\n\r\n          // store current tipElement reference to use\r\n          // in leaveAnimateCallback\r\n          _tipToHide = tipElement;\r\n\r\n          if (tipElement !== null) {\r\n            // Support v1.2+ $animate\r\n            // https://github.com/angular/angular.js/issues/11713\r\n            if (angular.version.minor <= 2) {\r\n              $animate.leave(tipElement, leaveAnimateCallback);\r\n            } else {\r\n              $animate.leave(tipElement).then(leaveAnimateCallback);\r\n            }\r\n          }\r\n\r\n          $tooltip.$isShown = scope.$isShown = false;\r\n          safeDigest(scope);\r\n\r\n          // Unbind events\r\n          if (options.keyboard && tipElement !== null) {\r\n            unbindKeyboardEvents();\r\n          }\r\n\r\n          if (options.autoClose && tipElement !== null) {\r\n            unbindAutoCloseEvents();\r\n          }\r\n        };\r\n\r\n        function leaveAnimateCallback () {\r\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\r\n          if (angular.isDefined(options.onHide) && angular.isFunction(options.onHide)) {\r\n            options.onHide($tooltip);\r\n          }\r\n\r\n          // check if current tipElement still references\r\n          // the same element when hide was called\r\n          if (tipElement === _tipToHide) {\r\n            // Allow to blur the input when hidden, like when pressing enter key\r\n            if (_blur && options.trigger === 'focus') {\r\n              return element[0].blur();\r\n            }\r\n\r\n            // clean up child scopes\r\n            destroyTipElement();\r\n          }\r\n        }\r\n\r\n        $tooltip.toggle = function (evt) {\r\n          if (evt) { evt.preventDefault(); }\r\n          if ($tooltip.$isShown) {\r\n            $tooltip.leave();\r\n          } else {\r\n            $tooltip.enter();\r\n          }\r\n        };\r\n\r\n        $tooltip.focus = function () {\r\n          tipElement[0].focus();\r\n        };\r\n\r\n        $tooltip.setEnabled = function (isEnabled) {\r\n          options.bsEnabled = isEnabled;\r\n        };\r\n\r\n        $tooltip.setViewport = function (viewport) {\r\n          options.viewport = viewport;\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $tooltip.$applyPlacement = function () {\r\n          if (!tipElement) return;\r\n\r\n          // Determine if we're doing an auto or normal placement\r\n          var placement = options.placement;\r\n          var autoToken = /\\s?auto?\\s?/i;\r\n          var autoPlace = autoToken.test(placement);\r\n\r\n          if (autoPlace) {\r\n            placement = placement.replace(autoToken, '') || defaults.placement;\r\n          }\r\n\r\n          // Need to add the position class before we get\r\n          // the offsets\r\n          tipElement.addClass(options.placement);\r\n\r\n          // Get the position of the target element\r\n          // and the height and width of the tooltip so we can center it.\r\n          var elementPosition = getPosition();\r\n          var tipWidth = tipElement.prop('offsetWidth');\r\n          var tipHeight = tipElement.prop('offsetHeight');\r\n\r\n          // Refresh viewport position\r\n          $tooltip.$viewport = options.viewport && findElement(options.viewport.selector || options.viewport);\r\n\r\n          // If we're auto placing, we need to check the positioning\r\n          if (autoPlace) {\r\n            var originalPlacement = placement;\r\n            var viewportPosition = getPosition($tooltip.$viewport);\r\n\r\n            if (/bottom/.test(originalPlacement) && elementPosition.bottom + tipHeight > viewportPosition.bottom) {\r\n              placement = originalPlacement.replace('bottom', 'top');\r\n            } else if (/top/.test(originalPlacement) && elementPosition.top - tipHeight < viewportPosition.top) {\r\n              placement = originalPlacement.replace('top', 'bottom');\r\n            }\r\n\r\n            if (/left/.test(originalPlacement) && elementPosition.left - tipWidth < viewportPosition.left) {\r\n              placement = placement.replace('left', 'right');\r\n            } else if (/right/.test(originalPlacement) && elementPosition.right + tipWidth > viewportPosition.width) {\r\n              placement = placement.replace('right', 'left');\r\n            }\r\n\r\n            tipElement.removeClass(originalPlacement).addClass(placement);\r\n          }\r\n\r\n          // Get the tooltip's top and left coordinates to center it with this directive.\r\n          var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\r\n          applyPlacement(tipPosition, placement);\r\n        };\r\n\r\n        $tooltip.$onKeyUp = function (evt) {\r\n          if (evt.which === 27 && $tooltip.$isShown) {\r\n            $tooltip.hide();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        $tooltip.$onFocusKeyUp = function (evt) {\r\n          if (evt.which === 27) {\r\n            element[0].blur();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        $tooltip.$onFocusElementMouseDown = function (evt) {\r\n          if (options.mouseDownPreventDefault) { evt.preventDefault(); }\r\n          if (options.mouseDownStopPropagation) { evt.stopPropagation(); }\r\n          // Some browsers do not auto-focus buttons (eg. Safari)\r\n          if ($tooltip.$isShown) {\r\n            element[0].blur();\r\n          } else {\r\n            element[0].focus();\r\n          }\r\n        };\r\n\r\n        // bind/unbind events\r\n        function bindTriggerEvents () {\r\n\r\n          var triggers = options.trigger.split(' ');\r\n          angular.forEach(triggers, function (trigger) {\r\n            if (trigger === 'click' || trigger === 'contextmenu') {\r\n              element.on(trigger, $tooltip.toggle);\r\n              // element.on('blur', $tooltip.leave);\r\n            } else if (trigger !== 'manual') {\r\n              // Only bind up hover events if we are on a desktop\r\n              if (!isTouch) {\r\n                element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\r\n                element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\r\n              }\r\n\t\t\t  //but do bind focus events for touch\r\n              else if (trigger === 'focus') {\r\n                element.on('focus', $tooltip.enter);\r\n                element.on('blur', $tooltip.leave);\r\n\t\t\t  }\r\n\t\t  \r\n              // if (nodeName === 'button' && trigger !== 'hover') {\r\n              //   element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\r\n              // }\r\n            }\r\n          });\r\n        }\r\n\r\n        function unbindTriggerEvents () {\r\n          var triggers = options.trigger.split(' ');\r\n          for (var i = triggers.length; i--;) {\r\n            var trigger = triggers[i];\r\n            if (trigger === 'click' || trigger === 'contextmenu') {\r\n              element.off(trigger, $tooltip.toggle);\r\n            } else if (trigger !== 'manual') {\r\n              // Remove previously defined hover events if we are on a desktop\r\n              if (!isTouch) {\r\n                element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\r\n                element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\r\n              }\r\n\t\t\t  // Remove previously defined focus events\r\n              else if (trigger === 'focus') {\r\n                element.off('focus', $tooltip.enter);\r\n                element.off('blur', $tooltip.leave);\r\n\t\t\t  }\r\n\t\t\t  \r\n              // if (nodeName === 'button' && trigger !== 'hover') {\r\n              //   element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\r\n              // }\r\n            }\r\n          }\r\n        }\r\n\r\n        function bindKeyboardEvents () {\r\n          if (options.trigger !== 'focus') {\r\n            tipElement.on('keyup', $tooltip.$onKeyUp);\r\n          } else {\r\n            element.on('keyup', $tooltip.$onFocusKeyUp);\r\n          }\r\n        }\r\n\r\n        function unbindKeyboardEvents () {\r\n          if (options.trigger !== 'focus') {\r\n            tipElement.off('keyup', $tooltip.$onKeyUp);\r\n          } else {\r\n            element.off('keyup', $tooltip.$onFocusKeyUp);\r\n          }\r\n        }\r\n\r\n        var _autoCloseEventsBinded = false;\r\n        function bindAutoCloseEvents () {\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed imediately.\r\n          $timeout(function () {\r\n            // Stop propagation when clicking inside tooltip\r\n            tipElement.on('click', stopEventPropagation);\r\n\r\n            // Hide when clicking outside tooltip\r\n            $body.on('click', $tooltip.hide);\r\n\r\n            _autoCloseEventsBinded = true;\r\n          }, 0, false);\r\n        }\r\n\r\n        function unbindAutoCloseEvents () {\r\n          if (_autoCloseEventsBinded) {\r\n            tipElement.off('click', stopEventPropagation);\r\n            $body.off('click', $tooltip.hide);\r\n            _autoCloseEventsBinded = false;\r\n          }\r\n        }\r\n\r\n        function stopEventPropagation (event) {\r\n          event.stopPropagation();\r\n        }\r\n\r\n        // Private methods\r\n\r\n        function getPosition ($element) {\r\n          $element = $element || (options.target || element);\r\n\r\n          var el = $element[0];\r\n          var isBody = el.tagName === 'BODY';\r\n\r\n          var elRect = el.getBoundingClientRect();\r\n          var rect = {};\r\n\r\n          // IE8 has issues with angular.extend and using elRect directly.\r\n          // By coping the values of elRect into a new object, we can continue to use extend\r\n          /* eslint-disable guard-for-in */\r\n          for (var p in elRect) { // eslint-disable-line\r\n            // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.\r\n            rect[p] = elRect[p];\r\n          }\r\n          /* eslint-enable guard-for-in */\r\n\r\n          if (rect.width === null) {\r\n            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\r\n            rect = angular.extend({}, rect, {width: elRect.right - elRect.left, height: elRect.bottom - elRect.top});\r\n          }\r\n          var elOffset = isBody ? {top: 0, left: 0} : dimensions.offset(el);\r\n          var scroll = {scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0};\r\n          var outerDims = isBody ? {width: document.documentElement.clientWidth, height: $window.innerHeight} : null;\r\n\r\n          return angular.extend({}, rect, scroll, outerDims, elOffset);\r\n        }\r\n\r\n        function getCalculatedOffset (placement, position, actualWidth, actualHeight) {\r\n          var offset;\r\n          var split = placement.split('-');\r\n\r\n          switch (split[0]) {\r\n            case 'right':\r\n              offset = {\r\n                top: position.top + position.height / 2 - actualHeight / 2,\r\n                left: position.left + position.width\r\n              };\r\n              break;\r\n            case 'bottom':\r\n              offset = {\r\n                top: position.top + position.height,\r\n                left: position.left + position.width / 2 - actualWidth / 2\r\n              };\r\n              break;\r\n            case 'left':\r\n              offset = {\r\n                top: position.top + position.height / 2 - actualHeight / 2,\r\n                left: position.left - actualWidth\r\n              };\r\n              break;\r\n            default:\r\n              offset = {\r\n                top: position.top - actualHeight,\r\n                left: position.left + position.width / 2 - actualWidth / 2\r\n              };\r\n              break;\r\n          }\r\n\r\n          if (!split[1]) {\r\n            return offset;\r\n          }\r\n\r\n          // Add support for corners @todo css\r\n          if (split[0] === 'top' || split[0] === 'bottom') {\r\n            switch (split[1]) {\r\n              case 'left':\r\n                offset.left = position.left;\r\n                break;\r\n              case 'right':\r\n                offset.left = position.left + position.width - actualWidth;\r\n                break;\r\n              default:\r\n                break;\r\n            }\r\n          } else if (split[0] === 'left' || split[0] === 'right') {\r\n            switch (split[1]) {\r\n              case 'top':\r\n                offset.top = position.top - actualHeight + position.height;\r\n                break;\r\n              case 'bottom':\r\n                offset.top = position.top;\r\n                break;\r\n              default:\r\n                break;\r\n            }\r\n          }\r\n\r\n          return offset;\r\n        }\r\n\r\n        function applyPlacement (offset, placement) {\r\n          var tip = tipElement[0];\r\n          var width = tip.offsetWidth;\r\n          var height = tip.offsetHeight;\r\n\r\n          // manually read margins because getBoundingClientRect includes difference\r\n          var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10);\r\n          var marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);\r\n\r\n          // we must check for NaN for ie 8/9\r\n          if (isNaN(marginTop)) marginTop = 0;\r\n          if (isNaN(marginLeft)) marginLeft = 0;\r\n\r\n          offset.top = offset.top + marginTop;\r\n          offset.left = offset.left + marginLeft;\r\n\r\n          // dimensions setOffset doesn't round pixel values\r\n          // so we use setOffset directly with our own function\r\n          dimensions.setOffset(tip, angular.extend({\r\n            using: function (props) {\r\n              tipElement.css({\r\n                top: Math.round(props.top) + 'px',\r\n                left: Math.round(props.left) + 'px',\r\n                right: ''\r\n              });\r\n            }\r\n          }, offset), 0);\r\n\r\n          // check to see if placing tip in new offset caused the tip to resize itself\r\n          var actualWidth = tip.offsetWidth;\r\n          var actualHeight = tip.offsetHeight;\r\n\r\n          if (placement === 'top' && actualHeight !== height) {\r\n            offset.top = offset.top + height - actualHeight;\r\n          }\r\n\r\n          // If it's an exotic placement, exit now instead of\r\n          // applying a delta and changing the arrow\r\n          if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;\r\n\r\n          var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\r\n\r\n          if (delta.left) {\r\n            offset.left += delta.left;\r\n          } else {\r\n            offset.top += delta.top;\r\n          }\r\n\r\n          dimensions.setOffset(tip, offset);\r\n\r\n          if (/top|right|bottom|left/.test(placement)) {\r\n            var isVertical = /top|bottom/.test(placement);\r\n            var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;\r\n            var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';\r\n\r\n            replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);\r\n          }\r\n        }\r\n\r\n        // @source https://github.com/twbs/bootstrap/blob/v3.3.5/js/tooltip.js#L380\r\n        function getViewportAdjustedDelta (placement, position, actualWidth, actualHeight) {\r\n          var delta = {top: 0, left: 0};\r\n          if (!$tooltip.$viewport) return delta;\r\n\r\n          var viewportPadding = options.viewport && options.viewport.padding || 0;\r\n          var viewportDimensions = getPosition($tooltip.$viewport);\r\n\r\n          if (/right|left/.test(placement)) {\r\n            var topEdgeOffset = position.top - viewportPadding - viewportDimensions.scroll;\r\n            var bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;\r\n            if (topEdgeOffset < viewportDimensions.top) { // top overflow\r\n              delta.top = viewportDimensions.top - topEdgeOffset;\r\n            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\r\n              delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\r\n            }\r\n          } else {\r\n            var leftEdgeOffset = position.left - viewportPadding;\r\n            var rightEdgeOffset = position.left + viewportPadding + actualWidth;\r\n            if (leftEdgeOffset < viewportDimensions.left) { // left overflow\r\n              delta.left = viewportDimensions.left - leftEdgeOffset;\r\n            } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow\r\n              delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\r\n            }\r\n          }\r\n\r\n          return delta;\r\n        }\r\n\r\n        function replaceArrow (delta, dimension, isHorizontal) {\r\n          var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);\r\n\r\n          $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\r\n                .css(isHorizontal ? 'top' : 'left', '');\r\n        }\r\n\r\n        function destroyTipElement () {\r\n          // Cancel pending callbacks\r\n          clearTimeout(timeout);\r\n\r\n          if ($tooltip.$isShown && tipElement !== null) {\r\n            if (options.autoClose) {\r\n              unbindAutoCloseEvents();\r\n            }\r\n\r\n            if (options.keyboard) {\r\n              unbindKeyboardEvents();\r\n            }\r\n          }\r\n\r\n          if (tipScope) {\r\n            tipScope.$destroy();\r\n            tipScope = null;\r\n          }\r\n\r\n          if (tipElement) {\r\n            tipElement.remove();\r\n            tipElement = $tooltip.$element = null;\r\n          }\r\n        }\r\n\r\n        return $tooltip;\r\n\r\n      }\r\n\r\n      // Helper functions\r\n\r\n      function safeDigest (scope) {\r\n        /* eslint-disable no-unused-expressions */\r\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\r\n        /* eslint-enable no-unused-expressions */\r\n      }\r\n\r\n      function findElement (query, element) {\r\n        return angular.element((element || document).querySelectorAll(query));\r\n      }\r\n\r\n      return TooltipFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsTooltip', function ($window, $location, $sce, $parse, $tooltip, $$rAF) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink (scope, element, attr, transclusion) {\r\n\r\n        var tooltip;\r\n        // Directive options\r\n        var options = {scope: scope};\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'titleTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\r\n            options[key] = false;\r\n          }\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // should not parse target attribute (anchor tag), only data-target #1454\r\n        var dataTarget = element.attr('data-target');\r\n        if (angular.isDefined(dataTarget)) {\r\n          if (falseValueRegExp.test(dataTarget)) {\r\n            options.target = false;\r\n          } else {\r\n            options.target = dataTarget;\r\n          }\r\n        }\r\n\r\n        // overwrite inherited title value when no value specified\r\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\r\n        if (!scope.hasOwnProperty('title')) {\r\n          scope.title = '';\r\n        }\r\n\r\n        // Observe scope attributes for change\r\n        attr.$observe('title', function (newValue) {\r\n          if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {\r\n            var oldValue = scope.title;\r\n            scope.title = $sce.trustAsHtml(newValue);\r\n            if (angular.isDefined(oldValue)) {\r\n              $$rAF(function () {\r\n                if (tooltip) tooltip.$applyPlacement();\r\n              });\r\n            }\r\n          }\r\n        });\r\n\r\n        attr.$observe('disabled', function (newValue) {\r\n          if (newValue && tooltip.$isShown) {\r\n            tooltip.hide();\r\n          }\r\n        });\r\n\r\n        // Support scope as an object\r\n        if (attr.bsTooltip) {\r\n          scope.$watch(attr.bsTooltip, function (newValue, oldValue) {\r\n            if (angular.isObject(newValue)) {\r\n              angular.extend(scope, newValue);\r\n            } else {\r\n              scope.title = newValue;\r\n            }\r\n            if (angular.isDefined(oldValue)) {\r\n              $$rAF(function () {\r\n                if (tooltip) tooltip.$applyPlacement();\r\n              });\r\n            }\r\n          }, true);\r\n        }\r\n\r\n        // Visibility binding support\r\n        if (attr.bsShow) {\r\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\r\n            if (!tooltip || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\r\n            if (newValue === true) {\r\n              tooltip.show();\r\n            } else {\r\n              tooltip.hide();\r\n            }\r\n          });\r\n        }\r\n\r\n        // Enabled binding support\r\n        if (attr.bsEnabled) {\r\n          scope.$watch(attr.bsEnabled, function (newValue, oldValue) {\r\n            // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\r\n            if (!tooltip || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\r\n            if (newValue === false) {\r\n              tooltip.setEnabled(false);\r\n            } else {\r\n              tooltip.setEnabled(true);\r\n            }\r\n          });\r\n        }\r\n\r\n        // Viewport support\r\n        if (attr.viewport) {\r\n          scope.$watch(attr.viewport, function (newValue) {\r\n            if (!tooltip || !angular.isDefined(newValue)) return;\r\n            tooltip.setViewport(newValue);\r\n          });\r\n        }\r\n\r\n        // Initialize popover\r\n        tooltip = $tooltip(element, options);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (tooltip) tooltip.destroy();\r\n          options = null;\r\n          tooltip = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n"],"sourceRoot":"/source/"}