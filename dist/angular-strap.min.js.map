{"version":3,"sources":["angular-strap.js","helpers/compiler.js","dropdown/dropdown.js","button/button.js","typeahead/typeahead.js","tooltip/tooltip.js","timepicker/timepicker.js","tab/tab.js","select/select.js","scrollspy/scrollspy.js","popover/popover.js","navbar/navbar.js","modal/modal.js","helpers/raf.js","helpers/parse-options.js","helpers/focus-out.js","helpers/focus-element.js","helpers/dimensions.js","helpers/debounce.js","helpers/date-parser.js","helpers/date-formatter.js","datepicker/datepicker.js","collapse/collapse.js","aside/aside.js","alert/alert.js","affix/affix.js","module.js"],"names":["window","document","undefined","templateUrl","options","cache","$templateCache","then","element","res","fetchTemplate","template","fetchPromises","module","$http","get","defaults","animation","prefixClass","data","this","compile","controller","console","controllerAs","resolve","locals","bindToController","angular","forEach","value","isString","$injector","key","transformTemplate","identity","extend","$template","when","$q","all","templateEl","Error","findElement","contentTemplate","templates","contentEl","removeAttr","html","replace","next","remove","outerHTML","link","scope","trim","contents","linkFn","invokeCtrl","children","instance","ctrl","isObject","arguments","apply","bsCompilerService","$inject","activeClass","directive","restrict","require","querySelectorAll","childEl","ngModel","attr","child","$button","constantValueRegExp","isInput","trueValue","falseValue","test","isDefined","hasExoticValues","viewValue","$formatters","push","$render","isActive","$viewValue","checked","activeElement","toggleClass","bind","toggleEvent","$$rAF","$setViewValue","$apply","hasClass","$observe","$eval","v","parent","equals","trigger","provider","container","keyboard","delay","minLength","filter","limit","autoSelect","comparator","trimValue","KEY_CODES","downArrow","enter","escape","upArrow","$typeahead","parentScope","id","$resetMatches","config","setAriaActiveDescendant","index","resultId","$generateResultId","$$phase","$root","$activeIndex","$tooltip","$activate","$scope","$$postDigest","activate","$matches","select","$select","evt","$isActive","matches","safeDigest","update","$emit","prefixEvent","onSelect","length","isFunction","$getIndex","$onMouseDown","preventDefault","stopPropagation","clientTop","active","offsetTop","clientBottom","highWatermark","scrollTop","Math","lowWatermark","clientHeight","keyCode","$isVisible","getElementById","$digest","label","show","$element","assertDiv","$timeout","append","ariaLabelledby","hide","$onKeyDown","onKeyUp","which","$isShown","onFocusKeyUp","$onFocusKeyUp","array","TypeaheadFactory","$filter","expression","results","postLink","falseValueRegExp","bsKey","charAt","toUpperCase","slice","bsOptions","parsedOptions","$parseOptions","typeahead","watchedOptions","$match","$watchCollection","values","watchOptions","$watch","newValue","oldValue","$modelValue","valuesFn","selectMode","substring","displayValue","modelValue","selected","ss","selectionStart","val","selectionEnd","setSelectionRange","sd","toString","$on","off","destroy","target","placement","titleTemplate","title","type","autoClose","bsEnabled","mouseDownPreventDefault","mouseDownStopPropagation","viewport","selector","padding","TooltipFactory","$get","promise","$bsCompiler","split","clearTimeout","hoverState","onShow","leaveAnimateCallback","destroyTipElement","onHide","_tipToHide","triggers","on","isTouch","unbindTriggerEvents","i","leave","bindKeyboardEvents","tipElement","$onKeyUp","unbindKeyboardEvents","_autoCloseEventsBinded","bindAutoCloseEvents","$body","unbindAutoCloseEvents","stopEventPropagation","event","getPosition","elRect","getBoundingClientRect","rect","p","width","height","top","left","dimensions","offset","el","scroll","outerDims","isBody","documentElement","body","prop","clientWidth","innerHeight","position","actualWidth","actualHeight","marginLeft","isNaN","setOffset","using","parseInt","props","css","right","marginTop","tip","offsetHeight","getViewportAdjustedDelta","delta","offsetWidth","isVertical","arrowDelta","replaceArrow","arrowOffsetPosition","viewportDimensions","$viewport","topEdgeOffset","bottomEdgeOffset","viewportPadding","leftEdgeOffset","rightEdgeOffset","dimension","isHorizontal","$arrow","timeout","tipScope","$destroy","$options","$promise","$new","$rootScope","$id","map","parseFloat","$sce","trustAsHtml","$setEnabled","$hide","setEnabled","isEnabled","toggle","compileData","tipContainer","init","bindTriggerEvents","isElement","focus","onBeforeShow","after","lastChild","display","visibility","clonedElement","addClass","version","prepend","$applyPlacement","$animate","enterAnimateCallback","_blur","onBeforeHide","blur","autoPlace","autoToken","elementPosition","tipWidth","tipHeight","viewportPosition","originalPlacement","removeClass","tipPosition","getCalculatedOffset","applyPlacement","query","isNative","tooltip","transclusion","dataTarget","hasOwnProperty","bsTooltip","bsShow","match","setViewport","useNative","timeType","timeFormat","timezone","modelTimeFormat","autoclose","minTime","maxTime","Infinity","hourStep","minuteStep","secondStep","roundDisplay","iconUp","iconDown","arrowBehavior","$timepicker","timepickerFactory","formatDate","format","viewDate","hour","startDate","getHours","meridian","coeff","selRange","end","start","isUndefined","collapse","moveStart","moveEnd","focusElement","_init","floorMinutes","time","floor","lang","selectedIndex","date","defaultDate","second","getSeconds","millisecond","getMilliseconds","$dateValue","hoursFormat","$dateFormatter","timeSeparator","minute","minutesFormat","secondsFormat","showSeconds","$iconUp","$moveIndex","$switchMeridian","switchMeridian","isDate","getMinutes","getTime","$build","$isBuilt","keep","Date","setHours","setMinutes","setSeconds","copy","midIndex","hours","disabled","minutes","$date","seconds","rows","$isDisabled","showAM","$isSelected","isAM","selectedTime","$arrowAction","$setTimeByStep","newDate","targetDate","nodeName","targetEl","triggerHandler","hoursLength","minutesLength","sepLength","lateralMove","count","selectRange","incr","isSeconds","isMeridian","secondsLength","createSelection","createTextRange","_destroy","_show","_hide","$window","navigator","userAgent","isMaxValid","isValid","parsedTime","isMinValid","setFullYear","$setValidity","$parsers","unshift","getTimeFormattedString","timepicker","dateParser","$dateParser","validateAgainstMinMaxTime","timezoneOffsetAdjust","NaN","parse","_tabsHash","_addTabControl","navClass","$attrs","control","self","newIndex","navigatePane","toLeft","$panes","$setActive","name","focusCurrentTab","activeAs","$activePaneChangeListeners","$viewChangeListeners","$push","pane","$navClass","$activeClass","$onClick","tabPane","$labeledBy","$active","activeIndex","$remove","indexOf","splice","fn","$pane","$onKeyPress","e","charCode","$tab","transclude","ngModelCtrl","bsTabsCtrl","tabKey","addTabControl","controllers","liElements","find","iElement","attrs","bsActivePane","parsedBsActivePane","$parse","assign","render","$describedBy","multiple","allNoneButtons","sort","caretHtml","placeholder","allText","noneText","maxLength","maxLengthHtml","iconCheckmark","SelectFactory","$isMultiple","$showAllNoneButtons","$iconCheckmark","$allText","$selectNone","$updateActiveIndex","a","b","isArray","anchor","anchorCandidate","$selectScrollFix","$isIE","stopImmediatePropagation","ua","tagName","dataMultiple","inputEl","addEventListener","join","$isEmpty","spies","$document","windowEl","debounce","bodyEl","throttle","ScrollSpyFactory","scrollEl","isWindowSpy","scrollId","$$count","$scrollspy","unbindViewContentLoaded","unbindIncludeContentLoaded","trackedElements","sortedElements","activeTarget","debouncedCheckOffsets","viewportHeight","debouncedCheckPosition","throttledCheckPosition","checkPositionWithEventLoop","checkOffsets","checkPosition","docEl","$activateElement","setTimeout","source","$getTrackedElement","targetElement","querySelector","trackedElement","trackElement","toDelete","untrackElement","scrollspy","content","$popover","PopoverFactory","requestAnimationFrame","bsPopover","popover","routeAttr","$navbar","li","liElement","pattern","path","RegExp","regexp","backdrop","size","zIndex","containerElement","bodyElement","layoutHideElement","backdropCount","backdropBaseZindex","ModalFactory","focusableElement","$modal","modalElement","findFocusableElements","focusableElements","focusable","findNextFocusableElement","call","inReverse","prototype","reverse","unbindBackdropEvents","hideOnBackdropClick","backdropElement","preventEventDefault","modalScope","dialogBaseZindex","returnFocus","$show","bottom","destroyModalElement","z-index","defaultPrevented","customClass","validSizes","minor","backdropAnimation","bindBackdropEvents","nextFocusable","shiftKey","lg","sm","modalClass","bsModal","modal","dot","cancelAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","rafSupported","raf","timer","cancel","supported","$values","valueName","keyName","displayFn","valueFn","ParseOptionsFactory","groupByFn","callback","$event","ngFocusOut","ngEventHandler","factory","offsetParent","docElement","ownerDocument","outer","getComputedStyle","extra","currentStyle","boxRect","style","curPosition","curLeft","curCSSTop","curTop","calculatePosition","curElem","curCSSLeft","curOffset","offsetParentRect","offsetParentEl","offsetParentElement","func","immediate","args","context","callNow","leading","wait","trailing","year","$localeProvider","milliseconds","ParseDate","noop","toLowerCase","indexOfCaseInsensitive","len","str","strict","DateParserFactory","day","month","getFullYear","getMonth","proto","isNumeric","toDate","regExpMap","sss","$locale","dateFilter","mm","literalRegex","formatParts","escapedLiteralFormat","dateElements","keys","escapedFormat","isFormatStringLiteral","part","trimLiteralEscapeChars","dateRegexParts","escapeReservedSymbols","text","re","abstractRegex","buildDateParseRegex","setMapForFormat","buildDateAbstractRegex","buildDateParseValuesMap","Object","valuesMatch","keyIndex","valueKey","valuesFunctionMap","valueFunction","valuesRegex","exec","setFnMap","setMap","m","HH","H","hh","h","EEEE","EEE","DATETIME_FORMATS","SHORTDAY","dd","d","MMMM","MMM","SHORTMONTH","MM","M","DAY","yyyy","yy","y","MONTH","s","setDate","setMonth","regex","$format","regExpForFormat","baseDate","formatRegex","formatSetMap","fromDate","getDate","today","substr","getTimeForAttribute","daylightSavingAdjust","undo","getTimezoneOffset","getDefaultLocale","getDatetimeFormat","weekdaysShort","splitTimeFormat","weekdays","service","matchesSelector","DropdownFactory","$dropdown","onBodyClick","items","inMenu","relatedTarget","$onFocusOut","parentEl","webkitMatchesSelector","Element","mozMatchesSelector","msMatchesSelector","oMatchesSelector","tAttrs","nextSibling","nodeType","parentNode","removeChild","dropdown","dateType","dateFormat","modelDateFormat","dayFormat","monthFormat","yearFormat","monthTitleFormat","yearTitleFormat","strictFormat","minDate","maxDate","startView","minView","startWeek","daysOfWeekDisabled","hasToday","hasClear","iconLeft","iconRight","screenReaderDateFormat","focusOnOpen","DatepickerFactory","$datepicker","pickerViews","datepickerViews","altKey","setMode","$mode","focused","$views","views","$iconLeft","$iconRight","$hasToday","dropdownId","$nextLabel","labelNext","$previousLabel","$picker","handleOnKeyDown","$toggleMode","$setToday","$clear","$focused","selectedDayId","dayInfo","isNext","continueHandling","onKeyDown","inTable","updateDisabledDates","disabledDateRanges","dateRanges","$setDisabledEl","mode","pristine","built","$updateSelected","updateSelected","build","isSelected","steps","getUTCFullYear","getUTCMonth","$selectPane","UTC","getUTCDate","previousValue","normalizeDateRanges","ranges","disabledRanges","datepicker","parsedDate","getDateFormattedString","validateAgainstMinMaxDate","disabledDates","arrays","mod","n","arr","weekDaysMin","weekDaysShortLabels","weekDaysLongLabels","weekDaysLabelsHtml","weekDayLabel","concat","picker","firstDayOfMonth","firstDayOfMonthOffset","firstDate","firstDateOffset","days","selectedDay","todayDay","dayItem","isToday","screenReaderLabel","muted","defaultFirstDayTabIndex","showLabels","labels","isTodayDisabled","hasSelectedDate","$modeLabel","isDisabled","getDay","actualTime","months","selectedMonth","monthItem","thisMonthDate","thisMonth","lastDate","actualMonth","firstYear","years","selectedYear","yearItem","thisYear","actualYear","setYear","Array","startCollapsed","allowMultiple","activeIndexes","$targets","deactivateItem","activateItem","$toggles","$collapse","$registerToggle","$registerTarget","$unregisterToggle","fixActiveItemIndexes","disallowToggle","$activeIndexes","bsCollapseCtrl","ENTER","SPACE","actionEventHandler","bsCollapseToggle","log","action","$unregisterTarget","AsideFactory","$aside","bsAside","aside","duration","dismissable","AlertFactory","$alert","bsAlert","alert","AffixFactory","inlineStyles","$affix","setWidth","reset","initialOffsetTop","getRequiredAffixClass","_unpin","getScrollTop","scrollHeight","getScrollHeight","pageYOffset","offsetBottom","elementHeight","initialAffixTop","affixed","unpin","$parseOffsets","affix","offsetUnpin","$onResize","initialTop","$debouncedOnResize","initialPosition","affixTarget","option"],"mappings":"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","file":"angular-strap.min.js","sourcesContent":["(function(window, document, undefined) {\r\n'use strict';\r\n\r\n// Source: button\\button.js\r\nangular.module('mgcrea.ngStrap.button', [])\r\n\r\n  .provider('$button', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      activeClass: 'active',\r\n      toggleEvent: 'click'\r\n    };\r\n\r\n    this.$get = function () {\r\n      return {defaults: defaults};\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsCheckboxGroup', function () {\r\n\r\n    return {\r\n      restrict: 'A',\r\n      require: 'ngModel',\r\n      compile: function postLink (element, attr) {\r\n        element.attr('data-toggle', 'buttons');\r\n        element.removeAttr('ng-model');\r\n        var children = element[0].querySelectorAll('input[type=\"checkbox\"]');\r\n        angular.forEach(children, function (child) {\r\n          var childEl = angular.element(child);\r\n          childEl.attr('bs-checkbox', '');\r\n          childEl.attr('ng-model', attr.ngModel + '.' + childEl.attr('value'));\r\n        });\r\n      }\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsCheckbox', function ($button, $$rAF) {\r\n\r\n    var defaults = $button.defaults;\r\n    var constantValueRegExp = /^(true|false|\\d+)$/;\r\n\r\n    return {\r\n      restrict: 'A',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        var options = defaults;\r\n\r\n        // Support label > input[type=\"checkbox\"]\r\n        var isInput = element[0].nodeName === 'INPUT';\r\n        var activeElement = isInput ? element.parent() : element;\r\n\r\n        var trueValue = angular.isDefined(attr.trueValue) ? attr.trueValue : true;\r\n        if (constantValueRegExp.test(attr.trueValue)) {\r\n          trueValue = scope.$eval(attr.trueValue);\r\n        }\r\n        var falseValue = angular.isDefined(attr.falseValue) ? attr.falseValue : false;\r\n        if (constantValueRegExp.test(attr.falseValue)) {\r\n          falseValue = scope.$eval(attr.falseValue);\r\n        }\r\n\r\n        // Parse exotic values\r\n        var hasExoticValues = typeof trueValue !== 'boolean' || typeof falseValue !== 'boolean';\r\n        if (hasExoticValues) {\r\n          controller.$parsers.push(function (viewValue) {\r\n            // console.warn('$parser', element.attr('ng-model'), 'viewValue', viewValue);\r\n            return viewValue ? trueValue : falseValue;\r\n          });\r\n          // modelValue -> $formatters -> viewValue\r\n          controller.$formatters.push(function (modelValue) {\r\n             // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n            return angular.equals(modelValue, trueValue);\r\n          });\r\n        }\r\n\r\n        // model -> view\r\n        controller.$render = function () {\r\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\r\n          var isActive = !!controller.$viewValue;\r\n          $$rAF(function () {\r\n            if (isInput) element[0].checked = isActive;\r\n            activeElement.toggleClass(options.activeClass, isActive);\r\n          });\r\n        };\r\n\r\n        // view -> model\r\n        element.bind(options.toggleEvent, function () {\r\n          scope.$apply(function () {\r\n            // console.warn('!click', element.attr('ng-model'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\r\n            if (!isInput) {\r\n              controller.$setViewValue(!activeElement.hasClass('active'));\r\n            }\r\n            controller.$render();\r\n          });\r\n        });\r\n\r\n      }\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsRadioGroup', function () {\r\n\r\n    return {\r\n      restrict: 'A',\r\n      require: 'ngModel',\r\n      compile: function postLink (element, attr) {\r\n        element.attr('data-toggle', 'buttons');\r\n        element.removeAttr('ng-model');\r\n        var children = element[0].querySelectorAll('input[type=\"radio\"]');\r\n        angular.forEach(children, function (child) {\r\n          angular.element(child).attr('bs-radio', '');\r\n          angular.element(child).attr('ng-model', attr.ngModel);\r\n        });\r\n      }\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsRadio', function ($button, $$rAF) {\r\n\r\n    var defaults = $button.defaults;\r\n    var constantValueRegExp = /^(true|false|\\d+)$/;\r\n\r\n    return {\r\n      restrict: 'A',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        var options = defaults;\r\n\r\n        // Support `label > input[type=\"radio\"]` markup\r\n        var isInput = element[0].nodeName === 'INPUT';\r\n        var activeElement = isInput ? element.parent() : element;\r\n\r\n        var value;\r\n        attr.$observe('value', function (v) {\r\n          if (typeof v !== 'boolean' && constantValueRegExp.test(v)) {\r\n            value = scope.$eval(v);\r\n          } else {\r\n            value = v;\r\n          }\r\n          controller.$render();\r\n        });\r\n\r\n        // model -> view\r\n        controller.$render = function () {\r\n          // console.warn('$render', element.attr('value'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\r\n          var isActive = angular.equals(controller.$viewValue, value);\r\n          $$rAF(function () {\r\n            if (isInput) element[0].checked = isActive;\r\n            activeElement.toggleClass(options.activeClass, isActive);\r\n          });\r\n        };\r\n\r\n        // view -> model\r\n        element.bind(options.toggleEvent, function () {\r\n          scope.$apply(function () {\r\n            // console.warn('!click', element.attr('value'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\r\n            controller.$setViewValue(value);\r\n            controller.$render();\r\n          });\r\n        });\r\n\r\n      }\r\n\r\n    };\r\n\r\n  });\r\n\r\n// Source: typeahead\\typeahead.js\r\nangular.module('mgcrea.ngStrap.typeahead', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\r\n\r\n  .provider('$typeahead', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      prefixClass: 'typeahead',\r\n      prefixEvent: '$typeahead',\r\n      placement: 'bottom-left',\r\n      templateUrl: 'typeahead/typeahead.tpl.html',\r\n      trigger: 'focus',\r\n      container: false,\r\n      keyboard: true,\r\n      html: false,\r\n      delay: 0,\r\n      minLength: 1,\r\n      filter: 'bsAsyncFilter',\r\n      limit: 6,\r\n      autoSelect: false,\r\n      comparator: '',\r\n      trimValue: true\r\n    };\r\n\r\n    var KEY_CODES = {\r\n      downArrow: 40,\r\n      enter: 13,\r\n      escape: 27,\r\n      upArrow: 38\r\n    };\r\n\r\n    this.$get = function ($window, $rootScope, $tooltip, $$rAF, $timeout) {\r\n\r\n      function TypeaheadFactory (element, controller, config) {\r\n\r\n        var $typeahead = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n\r\n        $typeahead = $tooltip(element, options);\r\n\r\n        var parentScope = config.scope;\r\n        var scope = $typeahead.$scope;\r\n        scope.id = options.id;\r\n\r\n        scope.$resetMatches = function () {\r\n          scope.$matches = [];\r\n          scope.$activeIndex = options.autoSelect ? 0 : -1; // If set to 0, the first match will be highlighted\r\n        };\r\n        scope.$resetMatches();\r\n\r\n        scope.$activate = function (index) {\r\n          scope.$$postDigest(function () {\r\n            $typeahead.activate(index);\r\n          });\r\n        };\r\n\r\n        scope.$select = function (index, evt) {\r\n          scope.$$postDigest(function () {\r\n            $typeahead.select(index);\r\n          });\r\n        };\r\n\r\n        scope.$isVisible = function () {\r\n          return $typeahead.$isVisible();\r\n        };\r\n\r\n        scope.$isActive = function isActive (index) {\r\n          return scope.$activeIndex === index ? true : undefined;\r\n        };\r\n\r\n        // Public methods\r\n\r\n        $typeahead.update = function (matches) {\r\n          scope.$matches = matches;\r\n          if (scope.$activeIndex >= matches.length) {\r\n            scope.$activeIndex = options.autoSelect ? 0 : -1;\r\n          }\r\n\r\n          // wrap in a $timeout so the results are updated\r\n          // before repositioning\r\n          safeDigest(scope);\r\n          $$rAF($typeahead.$applyPlacement);\r\n        };\r\n\r\n        $typeahead.activate = function (index) {\r\n          scope.$activeIndex = index;\r\n        };\r\n\r\n        $typeahead.select = function (index) {\r\n          if (index === -1) return;\r\n          var value = scope.$matches[index].value;\r\n          // console.log('$setViewValue', value);\r\n          controller.$setViewValue(value);\r\n          controller.$render();\r\n          scope.$resetMatches();\r\n          if (parentScope) parentScope.$digest();\r\n          // Emit event\r\n          scope.$emit(options.prefixEvent + '.select', value, index, $typeahead);\r\n          if (angular.isDefined(options.onSelect) && angular.isFunction(options.onSelect)) {\r\n            options.onSelect(value, index, $typeahead);\r\n          }\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $typeahead.$isVisible = function () {\r\n          if (!options.minLength || !controller) {\r\n            return !!scope.$matches.length;\r\n          }\r\n          // minLength support\r\n          return scope.$matches.length && angular.isString(controller.$viewValue) && controller.$viewValue.length >= options.minLength;\r\n        };\r\n\r\n        scope.$generateResultId = function (index) {\r\n          return scope.id ? scope.id + '_typeahead_result_' + index : undefined;\r\n        };\r\n\r\n        $typeahead.$getIndex = function (value) {\r\n          var index;\r\n          for (index = scope.$matches.length; index--;) {\r\n            if (angular.equals(scope.$matches[index].value, value)) break;\r\n          }\r\n          return index;\r\n        };\r\n\r\n        $typeahead.$onMouseDown = function (evt) {\r\n          // Prevent blur on mousedown\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n        };\r\n\r\n        $typeahead.$$updateScrollTop = function (container, index) {\r\n          if (index > -1 && index < container.children.length) {\r\n            var active = container.children[index];\r\n            var clientTop = active.offsetTop;\r\n            var clientBottom = active.offsetTop + active.clientHeight;\r\n            var highWatermark = container.scrollTop;\r\n            var lowWatermark = container.scrollTop + container.clientHeight;\r\n\r\n            // active entry overlaps top border\r\n            if (clientBottom >= highWatermark && clientTop < highWatermark) {\r\n              container.scrollTop = Math.max(0, container.scrollTop - container.clientHeight);\r\n            } else if (clientBottom > lowWatermark) {\r\n              // top of active element is invisible because it's below the bottom of the visible container window\r\n              container.scrollTop = clientTop;\r\n            }\r\n          }\r\n        };\r\n\r\n        $typeahead.$onKeyDown = function (evt) {\r\n          // If the key code isn't up arrow, down arrow, or enter return.\r\n          if (!/(38|40|13)/.test(evt.keyCode)) return;\r\n\r\n          // Let ngSubmit pass if the typeahead tip is hidden or no option is selected\r\n          if ($typeahead.$isVisible() && !(evt.keyCode === KEY_CODES.enter && scope.$activeIndex === -1)) {\r\n            evt.preventDefault();\r\n            evt.stopPropagation();\r\n          }\r\n\r\n          // Select with enter\r\n          if (evt.keyCode === KEY_CODES.enter && scope.$matches.length) {\r\n            $typeahead.select(scope.$activeIndex);\r\n            // Navigate with keyboard\r\n          } else if (evt.keyCode === KEY_CODES.upArrow && scope.$activeIndex > 0) {\r\n            scope.$activeIndex--;\r\n            setAriaActiveDescendant(scope.$activeIndex);\r\n            angular.element(document.getElementById(options.id + '_sr_text')).html(scope.$matches[scope.$activeIndex].label);\r\n          } else if (evt.keyCode === KEY_CODES.downArrow && scope.$activeIndex < scope.$matches.length - 1) {\r\n            scope.$activeIndex++;\r\n            setAriaActiveDescendant(scope.$activeIndex);\r\n            angular.element(document.getElementById(options.id + '_sr_text')).html(scope.$matches[scope.$activeIndex].label);\r\n          } else if (angular.isUndefined(scope.$activeIndex)) {\r\n            scope.$activeIndex = 0;\r\n            setAriaActiveDescendant();\r\n          }\r\n\r\n          // update scrollTop property on $typeahead when scope.$activeIndex is not in visible area\r\n          $typeahead.$$updateScrollTop($typeahead.$element[0], scope.$activeIndex);\r\n          scope.$digest();\r\n        };\r\n\r\n        // Overrides\r\n\r\n        var show = $typeahead.show;\r\n        $typeahead.show = function () {\r\n          show();\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed immediately.\r\n          $timeout(function () {\r\n            if ($typeahead.$element) {\r\n              if (options.id) {\r\n                // Set the id on the \"dropdown\" component of the typeahead. The input should \"control\" this element.\r\n                $typeahead.$element.attr('id', options.id + '_listbox');\r\n                element.attr('aria-controls', options.id + '_listbox');\r\n\r\n                var assertDiv = document.getElementById(options.id + '_sr_text');\r\n                if (!assertDiv) {\r\n                  $typeahead.$element.parent().append('<div id=\"' + options.id + '_sr_text\" aria-live=\"assertive\" style=\"position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); border: 0;\"></div>');\r\n                }\r\n              }\r\n\r\n              // If the input was given an aria-labelledby attribute apply it to the \"dropdown\" component.\r\n              $typeahead.$element.attr('aria-labelledby', options.ariaLabelledby);\r\n\r\n              $typeahead.$element.on('mousedown', $typeahead.$onMouseDown);\r\n              if (options.keyboard) {\r\n                if (element) element.on('keydown', $typeahead.$onKeyDown);\r\n              }\r\n            }\r\n          }, 0, false);\r\n        };\r\n\r\n        var hide = $typeahead.hide;\r\n        $typeahead.hide = function () {\r\n          if ($typeahead.$element) $typeahead.$element.off('mousedown', $typeahead.$onMouseDown);\r\n          if (options.keyboard) {\r\n            if (element) element.off('keydown', $typeahead.$onKeyDown);\r\n          }\r\n          if (!options.autoSelect) {\r\n            $typeahead.activate(-1);\r\n          }\r\n\r\n          var assertDiv = document.getElementById(options.id + '_sr_text');\r\n          angular.element(assertDiv).remove();\r\n\r\n          setAriaActiveDescendant();\r\n\r\n          hide();\r\n        };\r\n\r\n        var onKeyUp = $typeahead.$onKeyUp; // eslint-disable-line no-unused-vars\r\n        $typeahead.$onKeyUp = function (evt) {\r\n          if (evt.which === KEY_CODES.escape && $typeahead.$isShown) {\r\n            $typeahead.hide();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        var onFocusKeyUp = $typeahead.$onFocusKeyUp; // eslint-disable-line no-unused-vars\r\n        $typeahead.$onFocusKeyUp = function (evt) {\r\n          if (evt.which === KEY_CODES.escape) {\r\n            $typeahead.hide();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        // Helper functions within this closure\r\n\r\n        function setAriaActiveDescendant (index) {\r\n          if (index === undefined || !scope.id) {\r\n            element.removeAttr('aria-activedescendant');\r\n          } else {\r\n            var resultId = scope.$generateResultId(index);\r\n            if (resultId) {\r\n              element.attr('aria-activedescendant', resultId);\r\n            } else {\r\n              element.removeAttr('aria-activedescendant');\r\n            }\r\n          }\r\n        }\r\n\r\n        return $typeahead;\r\n\r\n      }\r\n\r\n      // Helper functions\r\n\r\n      function safeDigest (scope) {\r\n        /* eslint-disable no-unused-expressions */\r\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\r\n        /* eslint-enable no-unused-expressions */\r\n      }\r\n\r\n      TypeaheadFactory.defaults = defaults;\r\n      return TypeaheadFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .filter('bsAsyncFilter', function ($filter) {\r\n    return function (array, expression, comparator) {\r\n      if (array && angular.isFunction(array.then)) {\r\n        return array.then(function (results) {\r\n          return $filter('filter')(results, expression, comparator);\r\n        });\r\n      }\r\n      return $filter('filter')(array, expression, comparator);\r\n    };\r\n  })\r\n\r\n  .directive('bsTypeahead', function ($window, $parse, $q, $typeahead, $parseOptions) {\r\n\r\n    var defaults = $typeahead.defaults;\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        // Fixes firefox bug when using objects in model with typeahead\r\n        // Yes this breaks any other directive using a 'change' event on this input,\r\n        // but if it is using the 'change' event why is it used with typeahead?\r\n        element.off('change');\r\n\r\n        // Directive options\r\n        var options = {\r\n          scope: scope\r\n        };\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'filter', 'limit', 'minLength', 'watchOptions', 'selectMode', 'autoSelect', 'comparator', 'id', 'prefixEvent', 'prefixClass', 'ariaLabelledby'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container', 'trimValue', 'filter'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n        });\r\n\r\n        // bind functions from the attrs to the show, hide and select events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide', 'onSelect'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Disable browser autocompletion\r\n        if (!element.attr('autocomplete')) element.attr('autocomplete', 'off');\r\n\r\n        // Build proper bsOptions\r\n        var filter = angular.isDefined(options.filter) ? options.filter : defaults.filter;\r\n        var limit = options.limit || defaults.limit;\r\n        var comparator = options.comparator || defaults.comparator;\r\n\r\n        var bsOptions = attr.bsOptions;\r\n        if (filter) {\r\n          bsOptions += ' | ' + filter + ':$viewValue';\r\n          if (comparator) bsOptions += ':' + comparator;\r\n        }\r\n        if (limit) bsOptions += ' | limitTo:' + limit;\r\n        var parsedOptions = $parseOptions(bsOptions);\r\n\r\n        // Initialize typeahead\r\n        var typeahead = $typeahead(element, controller, options);\r\n\r\n        if (!element.attr('aria-autocomplete') && !bsOptions.templateUrl) {\r\n          // Per draft spec for a combobox element the aria-auto complete should be set to a list.\r\n          element.attr('aria-autocomplete', 'list');\r\n        }\r\n\r\n        // Watch options on demand\r\n        if (options.watchOptions) {\r\n          // Watch bsOptions values before filtering for changes, drop function calls\r\n          var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').replace(/\\(.*\\)/g, '').trim();\r\n          scope.$watchCollection(watchedOptions, function (newValue, oldValue) {\r\n            // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\r\n            parsedOptions.valuesFn(scope, controller).then(function (values) {\r\n              typeahead.update(values);\r\n              controller.$render();\r\n            });\r\n          });\r\n        }\r\n\r\n        // Watch model for changes\r\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\r\n          // console.warn('$watch', element.attr('ng-model'), newValue);\r\n          scope.$modelValue = newValue; // Publish modelValue on scope for custom templates\r\n          parsedOptions.valuesFn(scope, controller)\r\n            .then(function (values) {\r\n              // Prevent input with no future prospect if selectMode is truthy\r\n              // @TODO test selectMode\r\n              if (options.selectMode && !values.length && newValue.length > 0) {\r\n                controller.$setViewValue(controller.$viewValue.substring(0, controller.$viewValue.length - 1));\r\n                return;\r\n              }\r\n              if (values.length > limit) values = values.slice(0, limit);\r\n              typeahead.update(values);\r\n              // Queue a new rendering that will leverage collection loading\r\n              controller.$render();\r\n            });\r\n        });\r\n\r\n        // modelValue -> $formatters -> viewValue\r\n        controller.$formatters.push(function (modelValue) {\r\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n          var displayValue = parsedOptions.displayValue(modelValue);\r\n\r\n          // If we can determine the displayValue, use that\r\n          if (displayValue) {\r\n            return displayValue;\r\n          }\r\n\r\n          // If there's no display value, attempt to use the modelValue.\r\n          // If the model is an object not much we can do\r\n          if (angular.isDefined(modelValue) && typeof modelValue !== 'object') {\r\n            return modelValue;\r\n          }\r\n          return '';\r\n        });\r\n\r\n        // Model rendering in view\r\n        controller.$render = function () {\r\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\r\n          if (controller.$isEmpty(controller.$viewValue)) {\r\n            return element.val('');\r\n          }\r\n          var index = typeahead.$getIndex(controller.$modelValue);\r\n          var selected = index !== -1 ? typeahead.$scope.$matches[index].label : controller.$viewValue;\r\n          selected = angular.isObject(selected) ? parsedOptions.displayValue(selected) : selected;\r\n          var value = selected ? selected.toString().replace(/<(?:.|\\n)*?>/gm, '') : '';\r\n          var ss = element[0].selectionStart;\r\n          var sd = element[0].selectionEnd;\r\n          element.val(options.trimValue === false ? value : value.trim());\r\n          element[0].setSelectionRange(ss, sd);\r\n        };\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          element.off('keydown');\r\n          if (typeahead) typeahead.destroy();\r\n          options = null;\r\n          typeahead = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n\r\n// Source: tooltip\\tooltip.js\r\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\r\n\r\n  .provider('$tooltip', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      customClass: '',\r\n      prefixClass: 'tooltip',\r\n      prefixEvent: 'tooltip',\r\n      container: false,\r\n      target: false,\r\n      placement: 'top',\r\n      templateUrl: 'tooltip/tooltip.tpl.html',\r\n      template: '',\r\n      titleTemplate: false,\r\n      trigger: 'hover focus',\r\n      keyboard: false,\r\n      html: false,\r\n      show: false,\r\n      title: '',\r\n      type: '',\r\n      delay: 0,\r\n      autoClose: false,\r\n      bsEnabled: true,\r\n      mouseDownPreventDefault: true,\r\n      mouseDownStopPropagation: true,\r\n      viewport: {\r\n        selector: 'body',\r\n        padding: 0\r\n      }\r\n    };\r\n\r\n    this.$get = function ($window, $rootScope, $bsCompiler, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\r\n\r\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n      var isTouch = ('createTouch' in $window.document) && isNative;\r\n      var $body = angular.element($window.document);\r\n\r\n      function TooltipFactory (element, config) {\r\n\r\n        var $tooltip = {};\r\n\r\n        // Common vars\r\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\r\n        var promise = $tooltip.$promise = $bsCompiler.compile(options);\r\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\r\n\r\n        // var nodeName = element[0].nodeName.toLowerCase();\r\n        if (options.delay && angular.isString(options.delay)) {\r\n          var split = options.delay.split(',').map(parseFloat);\r\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\r\n        }\r\n\r\n        // Store $id to identify the triggering element in events\r\n        // give priority to options.id, otherwise, try to use\r\n        // element id if defined\r\n        $tooltip.$id = options.id || element.attr('id') || '';\r\n\r\n        // Support scope as string options\r\n        if (options.title) {\r\n          scope.title = $sce.trustAsHtml(options.title);\r\n        }\r\n\r\n        // Provide scope helpers\r\n        scope.$setEnabled = function (isEnabled) {\r\n          scope.$$postDigest(function () {\r\n            $tooltip.setEnabled(isEnabled);\r\n          });\r\n        };\r\n        scope.$hide = function () {\r\n          scope.$$postDigest(function () {\r\n            $tooltip.hide();\r\n          });\r\n        };\r\n        scope.$show = function () {\r\n          scope.$$postDigest(function () {\r\n            $tooltip.show();\r\n          });\r\n        };\r\n        scope.$toggle = function () {\r\n          scope.$$postDigest(function () {\r\n            $tooltip.toggle();\r\n          });\r\n        };\r\n        // Publish isShown as a protected var on scope\r\n        $tooltip.$isShown = scope.$isShown = false;\r\n\r\n        // Private vars\r\n        var timeout;\r\n        var hoverState;\r\n\r\n        // Fetch, compile then initialize tooltip\r\n        var compileData;\r\n        var tipElement;\r\n        var tipContainer;\r\n        var tipScope;\r\n        promise.then(function (data) {\r\n          compileData = data;\r\n          $tooltip.init();\r\n        });\r\n\r\n        $tooltip.init = function () {\r\n\r\n          // Options: delay\r\n          if (options.delay && angular.isNumber(options.delay)) {\r\n            options.delay = {\r\n              show: options.delay,\r\n              hide: options.delay\r\n            };\r\n          }\r\n\r\n          // Replace trigger on touch devices ?\r\n          // if(isTouch && options.trigger === defaults.trigger) {\r\n          //   options.trigger.replace(/hover/g, 'click');\r\n          // }\r\n\r\n          // Options : container\r\n          if (options.container === 'self') {\r\n            tipContainer = element;\r\n          } else if (angular.isElement(options.container)) {\r\n            tipContainer = options.container;\r\n          } else if (options.container) {\r\n            tipContainer = findElement(options.container);\r\n          }\r\n\r\n          // Options: trigger\r\n          bindTriggerEvents();\r\n\r\n          // Options: target\r\n          if (options.target) {\r\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\r\n          }\r\n\r\n          // Options: show\r\n          if (options.show) {\r\n            scope.$$postDigest(function () {\r\n              if (options.trigger === 'focus') {\r\n                element[0].focus();\r\n              } else {\r\n                $tooltip.show();\r\n              }\r\n            });\r\n          }\r\n\r\n        };\r\n\r\n        $tooltip.destroy = function () {\r\n\r\n          // Unbind events\r\n          unbindTriggerEvents();\r\n\r\n          // Remove element\r\n          destroyTipElement();\r\n\r\n          // Destroy scope\r\n          scope.$destroy();\r\n\r\n        };\r\n\r\n        $tooltip.enter = function () {\r\n\r\n          clearTimeout(timeout);\r\n          hoverState = 'in';\r\n          if (!options.delay || !options.delay.show) {\r\n            return $tooltip.show();\r\n          }\r\n\r\n          timeout = setTimeout(function () {\r\n            if (hoverState === 'in') $tooltip.show();\r\n          }, options.delay.show);\r\n\r\n        };\r\n\r\n        $tooltip.show = function () {\r\n          if (!options.bsEnabled || $tooltip.$isShown) return;\r\n\r\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\r\n          if (angular.isDefined(options.onBeforeShow) && angular.isFunction(options.onBeforeShow)) {\r\n            options.onBeforeShow($tooltip);\r\n          }\r\n          var parent;\r\n          var after;\r\n          if (options.container) {\r\n            parent = tipContainer;\r\n            if (tipContainer[0].lastChild) {\r\n              after = angular.element(tipContainer[0].lastChild);\r\n            } else {\r\n              after = null;\r\n            }\r\n          } else {\r\n            parent = null;\r\n            after = element;\r\n          }\r\n\r\n\r\n          // Hide any existing tipElement\r\n          if (tipElement) destroyTipElement();\r\n          // Fetch a cloned element linked from template\r\n          tipScope = $tooltip.$scope.$new();\r\n          tipElement = $tooltip.$element = compileData.link(tipScope, function (clonedElement, scope) {});\r\n\r\n          // Set the initial positioning.  Make the tooltip invisible\r\n          // so IE doesn't try to focus on it off screen.\r\n          tipElement.css({top: '-9999px', left: '-9999px', right: 'auto', display: 'block', visibility: 'hidden'});\r\n\r\n          // Options: animation\r\n          if (options.animation) tipElement.addClass(options.animation);\r\n          // Options: type\r\n          if (options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\r\n          // Options: custom classes\r\n          if (options.customClass) tipElement.addClass(options.customClass);\r\n\r\n          // Append the element, without any animations.  If we append\r\n          // using $animate.enter, some of the animations cause the placement\r\n          // to be off due to the transforms.\r\n          if (after) {\r\n            after.after(tipElement);\r\n          } else {\r\n            parent.prepend(tipElement);\r\n          }\r\n\r\n          $tooltip.$isShown = scope.$isShown = true;\r\n          safeDigest(scope);\r\n\r\n          // Now, apply placement\r\n          $tooltip.$applyPlacement();\r\n\r\n          // Once placed, animate it.\r\n          // Support v1.2+ $animate\r\n          // https://github.com/angular/angular.js/issues/11713\r\n          if (angular.version.minor <= 2) {\r\n            $animate.enter(tipElement, parent, after, enterAnimateCallback);\r\n          } else {\r\n            $animate.enter(tipElement, parent, after).then(enterAnimateCallback);\r\n          }\r\n          safeDigest(scope);\r\n\r\n          $$rAF(function () {\r\n            // Once the tooltip is placed and the animation starts, make the tooltip visible\r\n            if (tipElement) tipElement.css({visibility: 'visible'});\r\n\r\n            // Bind events\r\n            if (options.keyboard) {\r\n              if (options.trigger !== 'focus') {\r\n                $tooltip.focus();\r\n              }\r\n              bindKeyboardEvents();\r\n            }\r\n          });\r\n\r\n          if (options.autoClose) {\r\n            bindAutoCloseEvents();\r\n          }\r\n\r\n        };\r\n\r\n        function enterAnimateCallback () {\r\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\r\n          if (angular.isDefined(options.onShow) && angular.isFunction(options.onShow)) {\r\n            options.onShow($tooltip);\r\n          }\r\n        }\r\n\r\n        $tooltip.leave = function () {\r\n\r\n          clearTimeout(timeout);\r\n          hoverState = 'out';\r\n          if (!options.delay || !options.delay.hide) {\r\n            return $tooltip.hide();\r\n          }\r\n          timeout = setTimeout(function () {\r\n            if (hoverState === 'out') {\r\n              $tooltip.hide();\r\n            }\r\n          }, options.delay.hide);\r\n\r\n        };\r\n\r\n        var _blur;\r\n        var _tipToHide;\r\n        $tooltip.hide = function (blur) {\r\n\r\n          if (!$tooltip.$isShown) return;\r\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\r\n          if (angular.isDefined(options.onBeforeHide) && angular.isFunction(options.onBeforeHide)) {\r\n            options.onBeforeHide($tooltip);\r\n          }\r\n\r\n          // store blur value for leaveAnimateCallback to use\r\n          _blur = blur;\r\n\r\n          // store current tipElement reference to use\r\n          // in leaveAnimateCallback\r\n          _tipToHide = tipElement;\r\n\r\n          if (tipElement !== null) {\r\n            // Support v1.2+ $animate\r\n            // https://github.com/angular/angular.js/issues/11713\r\n            if (angular.version.minor <= 2) {\r\n              $animate.leave(tipElement, leaveAnimateCallback);\r\n            } else {\r\n              $animate.leave(tipElement).then(leaveAnimateCallback);\r\n            }\r\n          }\r\n\r\n          $tooltip.$isShown = scope.$isShown = false;\r\n          safeDigest(scope);\r\n\r\n          // Unbind events\r\n          if (options.keyboard && tipElement !== null) {\r\n            unbindKeyboardEvents();\r\n          }\r\n\r\n          if (options.autoClose && tipElement !== null) {\r\n            unbindAutoCloseEvents();\r\n          }\r\n        };\r\n\r\n        function leaveAnimateCallback () {\r\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\r\n          if (angular.isDefined(options.onHide) && angular.isFunction(options.onHide)) {\r\n            options.onHide($tooltip);\r\n          }\r\n\r\n          // check if current tipElement still references\r\n          // the same element when hide was called\r\n          if (tipElement === _tipToHide) {\r\n            // Allow to blur the input when hidden, like when pressing enter key\r\n            if (_blur && options.trigger === 'focus') {\r\n              return element[0].blur();\r\n            }\r\n\r\n            // clean up child scopes\r\n            destroyTipElement();\r\n          }\r\n        }\r\n\r\n        $tooltip.toggle = function (evt) {\r\n          if (evt) { evt.preventDefault(); }\r\n          if ($tooltip.$isShown) {\r\n            $tooltip.leave();\r\n          } else {\r\n            $tooltip.enter();\r\n          }\r\n        };\r\n\r\n        $tooltip.focus = function () {\r\n          tipElement[0].focus();\r\n        };\r\n\r\n        $tooltip.setEnabled = function (isEnabled) {\r\n          options.bsEnabled = isEnabled;\r\n        };\r\n\r\n        $tooltip.setViewport = function (viewport) {\r\n          options.viewport = viewport;\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $tooltip.$applyPlacement = function () {\r\n          if (!tipElement) return;\r\n\r\n          // Determine if we're doing an auto or normal placement\r\n          var placement = options.placement;\r\n          var autoToken = /\\s?auto?\\s?/i;\r\n          var autoPlace = autoToken.test(placement);\r\n\r\n          if (autoPlace) {\r\n            placement = placement.replace(autoToken, '') || defaults.placement;\r\n          }\r\n\r\n          // Need to add the position class before we get\r\n          // the offsets\r\n          tipElement.addClass(options.placement);\r\n\r\n          // Get the position of the target element\r\n          // and the height and width of the tooltip so we can center it.\r\n          var elementPosition = getPosition();\r\n          var tipWidth = tipElement.prop('offsetWidth');\r\n          var tipHeight = tipElement.prop('offsetHeight');\r\n\r\n          // Refresh viewport position\r\n          $tooltip.$viewport = options.viewport && findElement(options.viewport.selector || options.viewport);\r\n\r\n          // If we're auto placing, we need to check the positioning\r\n          if (autoPlace) {\r\n            var originalPlacement = placement;\r\n            var viewportPosition = getPosition($tooltip.$viewport);\r\n\r\n            if (/bottom/.test(originalPlacement) && elementPosition.bottom + tipHeight > viewportPosition.bottom) {\r\n              placement = originalPlacement.replace('bottom', 'top');\r\n            } else if (/top/.test(originalPlacement) && elementPosition.top - tipHeight < viewportPosition.top) {\r\n              placement = originalPlacement.replace('top', 'bottom');\r\n            }\r\n\r\n            if (/left/.test(originalPlacement) && elementPosition.left - tipWidth < viewportPosition.left) {\r\n              placement = placement.replace('left', 'right');\r\n            } else if (/right/.test(originalPlacement) && elementPosition.right + tipWidth > viewportPosition.width) {\r\n              placement = placement.replace('right', 'left');\r\n            }\r\n\r\n            tipElement.removeClass(originalPlacement).addClass(placement);\r\n          }\r\n\r\n          // Get the tooltip's top and left coordinates to center it with this directive.\r\n          var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\r\n          applyPlacement(tipPosition, placement);\r\n        };\r\n\r\n        $tooltip.$onKeyUp = function (evt) {\r\n          if (evt.which === 27 && $tooltip.$isShown) {\r\n            $tooltip.hide();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        $tooltip.$onFocusKeyUp = function (evt) {\r\n          if (evt.which === 27) {\r\n            element[0].blur();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        $tooltip.$onFocusElementMouseDown = function (evt) {\r\n          if (options.mouseDownPreventDefault) { evt.preventDefault(); }\r\n          if (options.mouseDownStopPropagation) { evt.stopPropagation(); }\r\n          // Some browsers do not auto-focus buttons (eg. Safari)\r\n          if ($tooltip.$isShown) {\r\n            element[0].blur();\r\n          } else {\r\n            element[0].focus();\r\n          }\r\n        };\r\n\r\n        // bind/unbind events\r\n        function bindTriggerEvents () {\r\n\r\n          var triggers = options.trigger.split(' ');\r\n          angular.forEach(triggers, function (trigger) {\r\n            if (trigger === 'click' || trigger === 'contextmenu') {\r\n              element.on(trigger, $tooltip.toggle);\r\n              // element.on('blur', $tooltip.leave);\r\n            } else if (trigger !== 'manual') {\r\n              // Only bind up hover events if we are on a desktop\r\n              if (!isTouch) {\r\n                element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\r\n                element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\r\n              }\r\n\t\t\t  //but do bind focus events for touch\r\n              else if (trigger === 'focus') {\r\n                element.on('focus', $tooltip.enter);\r\n                element.on('blur', $tooltip.leave);\r\n\t\t\t  }\r\n\t\t  \r\n              // if (nodeName === 'button' && trigger !== 'hover') {\r\n              //   element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\r\n              // }\r\n            }\r\n          });\r\n        }\r\n\r\n        function unbindTriggerEvents () {\r\n          var triggers = options.trigger.split(' ');\r\n          for (var i = triggers.length; i--;) {\r\n            var trigger = triggers[i];\r\n            if (trigger === 'click' || trigger === 'contextmenu') {\r\n              element.off(trigger, $tooltip.toggle);\r\n            } else if (trigger !== 'manual') {\r\n              // Remove previously defined hover events if we are on a desktop\r\n              if (!isTouch) {\r\n                element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\r\n                element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\r\n              }\r\n\t\t\t  // Remove previously defined focus events\r\n              else if (trigger === 'focus') {\r\n                element.off('focus', $tooltip.enter);\r\n                element.off('blur', $tooltip.leave);\r\n\t\t\t  }\r\n\t\t\t  \r\n              // if (nodeName === 'button' && trigger !== 'hover') {\r\n              //   element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\r\n              // }\r\n            }\r\n          }\r\n        }\r\n\r\n        function bindKeyboardEvents () {\r\n          if (options.trigger !== 'focus') {\r\n            tipElement.on('keyup', $tooltip.$onKeyUp);\r\n          } else {\r\n            element.on('keyup', $tooltip.$onFocusKeyUp);\r\n          }\r\n        }\r\n\r\n        function unbindKeyboardEvents () {\r\n          if (options.trigger !== 'focus') {\r\n            tipElement.off('keyup', $tooltip.$onKeyUp);\r\n          } else {\r\n            element.off('keyup', $tooltip.$onFocusKeyUp);\r\n          }\r\n        }\r\n\r\n        var _autoCloseEventsBinded = false;\r\n        function bindAutoCloseEvents () {\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed imediately.\r\n          $timeout(function () {\r\n            // Stop propagation when clicking inside tooltip\r\n            tipElement.on('click', stopEventPropagation);\r\n\r\n            // Hide when clicking outside tooltip\r\n            $body.on('click', $tooltip.hide);\r\n\r\n            _autoCloseEventsBinded = true;\r\n          }, 0, false);\r\n        }\r\n\r\n        function unbindAutoCloseEvents () {\r\n          if (_autoCloseEventsBinded) {\r\n            tipElement.off('click', stopEventPropagation);\r\n            $body.off('click', $tooltip.hide);\r\n            _autoCloseEventsBinded = false;\r\n          }\r\n        }\r\n\r\n        function stopEventPropagation (event) {\r\n          event.stopPropagation();\r\n        }\r\n\r\n        // Private methods\r\n\r\n        function getPosition ($element) {\r\n          $element = $element || (options.target || element);\r\n\r\n          var el = $element[0];\r\n          var isBody = el.tagName === 'BODY';\r\n\r\n          var elRect = el.getBoundingClientRect();\r\n          var rect = {};\r\n\r\n          // IE8 has issues with angular.extend and using elRect directly.\r\n          // By coping the values of elRect into a new object, we can continue to use extend\r\n          /* eslint-disable guard-for-in */\r\n          for (var p in elRect) { // eslint-disable-line\r\n            // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.\r\n            rect[p] = elRect[p];\r\n          }\r\n          /* eslint-enable guard-for-in */\r\n\r\n          if (rect.width === null) {\r\n            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\r\n            rect = angular.extend({}, rect, {width: elRect.right - elRect.left, height: elRect.bottom - elRect.top});\r\n          }\r\n          var elOffset = isBody ? {top: 0, left: 0} : dimensions.offset(el);\r\n          var scroll = {scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0};\r\n          var outerDims = isBody ? {width: document.documentElement.clientWidth, height: $window.innerHeight} : null;\r\n\r\n          return angular.extend({}, rect, scroll, outerDims, elOffset);\r\n        }\r\n\r\n        function getCalculatedOffset (placement, position, actualWidth, actualHeight) {\r\n          var offset;\r\n          var split = placement.split('-');\r\n\r\n          switch (split[0]) {\r\n            case 'right':\r\n              offset = {\r\n                top: position.top + position.height / 2 - actualHeight / 2,\r\n                left: position.left + position.width\r\n              };\r\n              break;\r\n            case 'bottom':\r\n              offset = {\r\n                top: position.top + position.height,\r\n                left: position.left + position.width / 2 - actualWidth / 2\r\n              };\r\n              break;\r\n            case 'left':\r\n              offset = {\r\n                top: position.top + position.height / 2 - actualHeight / 2,\r\n                left: position.left - actualWidth\r\n              };\r\n              break;\r\n            default:\r\n              offset = {\r\n                top: position.top - actualHeight,\r\n                left: position.left + position.width / 2 - actualWidth / 2\r\n              };\r\n              break;\r\n          }\r\n\r\n          if (!split[1]) {\r\n            return offset;\r\n          }\r\n\r\n          // Add support for corners @todo css\r\n          if (split[0] === 'top' || split[0] === 'bottom') {\r\n            switch (split[1]) {\r\n              case 'left':\r\n                offset.left = position.left;\r\n                break;\r\n              case 'right':\r\n                offset.left = position.left + position.width - actualWidth;\r\n                break;\r\n              default:\r\n                break;\r\n            }\r\n          } else if (split[0] === 'left' || split[0] === 'right') {\r\n            switch (split[1]) {\r\n              case 'top':\r\n                offset.top = position.top - actualHeight + position.height;\r\n                break;\r\n              case 'bottom':\r\n                offset.top = position.top;\r\n                break;\r\n              default:\r\n                break;\r\n            }\r\n          }\r\n\r\n          return offset;\r\n        }\r\n\r\n        function applyPlacement (offset, placement) {\r\n          var tip = tipElement[0];\r\n          var width = tip.offsetWidth;\r\n          var height = tip.offsetHeight;\r\n\r\n          // manually read margins because getBoundingClientRect includes difference\r\n          var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10);\r\n          var marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);\r\n\r\n          // we must check for NaN for ie 8/9\r\n          if (isNaN(marginTop)) marginTop = 0;\r\n          if (isNaN(marginLeft)) marginLeft = 0;\r\n\r\n          offset.top = offset.top + marginTop;\r\n          offset.left = offset.left + marginLeft;\r\n\r\n          // dimensions setOffset doesn't round pixel values\r\n          // so we use setOffset directly with our own function\r\n          dimensions.setOffset(tip, angular.extend({\r\n            using: function (props) {\r\n              tipElement.css({\r\n                top: Math.round(props.top) + 'px',\r\n                left: Math.round(props.left) + 'px',\r\n                right: ''\r\n              });\r\n            }\r\n          }, offset), 0);\r\n\r\n          // check to see if placing tip in new offset caused the tip to resize itself\r\n          var actualWidth = tip.offsetWidth;\r\n          var actualHeight = tip.offsetHeight;\r\n\r\n          if (placement === 'top' && actualHeight !== height) {\r\n            offset.top = offset.top + height - actualHeight;\r\n          }\r\n\r\n          // If it's an exotic placement, exit now instead of\r\n          // applying a delta and changing the arrow\r\n          if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;\r\n\r\n          var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\r\n\r\n          if (delta.left) {\r\n            offset.left += delta.left;\r\n          } else {\r\n            offset.top += delta.top;\r\n          }\r\n\r\n          dimensions.setOffset(tip, offset);\r\n\r\n          if (/top|right|bottom|left/.test(placement)) {\r\n            var isVertical = /top|bottom/.test(placement);\r\n            var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;\r\n            var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';\r\n\r\n            replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);\r\n          }\r\n        }\r\n\r\n        // @source https://github.com/twbs/bootstrap/blob/v3.3.5/js/tooltip.js#L380\r\n        function getViewportAdjustedDelta (placement, position, actualWidth, actualHeight) {\r\n          var delta = {top: 0, left: 0};\r\n          if (!$tooltip.$viewport) return delta;\r\n\r\n          var viewportPadding = options.viewport && options.viewport.padding || 0;\r\n          var viewportDimensions = getPosition($tooltip.$viewport);\r\n\r\n          if (/right|left/.test(placement)) {\r\n            var topEdgeOffset = position.top - viewportPadding - viewportDimensions.scroll;\r\n            var bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;\r\n            if (topEdgeOffset < viewportDimensions.top) { // top overflow\r\n              delta.top = viewportDimensions.top - topEdgeOffset;\r\n            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\r\n              delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\r\n            }\r\n          } else {\r\n            var leftEdgeOffset = position.left - viewportPadding;\r\n            var rightEdgeOffset = position.left + viewportPadding + actualWidth;\r\n            if (leftEdgeOffset < viewportDimensions.left) { // left overflow\r\n              delta.left = viewportDimensions.left - leftEdgeOffset;\r\n            } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow\r\n              delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\r\n            }\r\n          }\r\n\r\n          return delta;\r\n        }\r\n\r\n        function replaceArrow (delta, dimension, isHorizontal) {\r\n          var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);\r\n\r\n          $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\r\n                .css(isHorizontal ? 'top' : 'left', '');\r\n        }\r\n\r\n        function destroyTipElement () {\r\n          // Cancel pending callbacks\r\n          clearTimeout(timeout);\r\n\r\n          if ($tooltip.$isShown && tipElement !== null) {\r\n            if (options.autoClose) {\r\n              unbindAutoCloseEvents();\r\n            }\r\n\r\n            if (options.keyboard) {\r\n              unbindKeyboardEvents();\r\n            }\r\n          }\r\n\r\n          if (tipScope) {\r\n            tipScope.$destroy();\r\n            tipScope = null;\r\n          }\r\n\r\n          if (tipElement) {\r\n            tipElement.remove();\r\n            tipElement = $tooltip.$element = null;\r\n          }\r\n        }\r\n\r\n        return $tooltip;\r\n\r\n      }\r\n\r\n      // Helper functions\r\n\r\n      function safeDigest (scope) {\r\n        /* eslint-disable no-unused-expressions */\r\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\r\n        /* eslint-enable no-unused-expressions */\r\n      }\r\n\r\n      function findElement (query, element) {\r\n        return angular.element((element || document).querySelectorAll(query));\r\n      }\r\n\r\n      return TooltipFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsTooltip', function ($window, $location, $sce, $parse, $tooltip, $$rAF) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink (scope, element, attr, transclusion) {\r\n\r\n        var tooltip;\r\n        // Directive options\r\n        var options = {scope: scope};\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'titleTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\r\n            options[key] = false;\r\n          }\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // should not parse target attribute (anchor tag), only data-target #1454\r\n        var dataTarget = element.attr('data-target');\r\n        if (angular.isDefined(dataTarget)) {\r\n          if (falseValueRegExp.test(dataTarget)) {\r\n            options.target = false;\r\n          } else {\r\n            options.target = dataTarget;\r\n          }\r\n        }\r\n\r\n        // overwrite inherited title value when no value specified\r\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\r\n        if (!scope.hasOwnProperty('title')) {\r\n          scope.title = '';\r\n        }\r\n\r\n        // Observe scope attributes for change\r\n        attr.$observe('title', function (newValue) {\r\n          if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {\r\n            var oldValue = scope.title;\r\n            scope.title = $sce.trustAsHtml(newValue);\r\n            if (angular.isDefined(oldValue)) {\r\n              $$rAF(function () {\r\n                if (tooltip) tooltip.$applyPlacement();\r\n              });\r\n            }\r\n          }\r\n        });\r\n\r\n        attr.$observe('disabled', function (newValue) {\r\n          if (newValue && tooltip.$isShown) {\r\n            tooltip.hide();\r\n          }\r\n        });\r\n\r\n        // Support scope as an object\r\n        if (attr.bsTooltip) {\r\n          scope.$watch(attr.bsTooltip, function (newValue, oldValue) {\r\n            if (angular.isObject(newValue)) {\r\n              angular.extend(scope, newValue);\r\n            } else {\r\n              scope.title = newValue;\r\n            }\r\n            if (angular.isDefined(oldValue)) {\r\n              $$rAF(function () {\r\n                if (tooltip) tooltip.$applyPlacement();\r\n              });\r\n            }\r\n          }, true);\r\n        }\r\n\r\n        // Visibility binding support\r\n        if (attr.bsShow) {\r\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\r\n            if (!tooltip || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\r\n            if (newValue === true) {\r\n              tooltip.show();\r\n            } else {\r\n              tooltip.hide();\r\n            }\r\n          });\r\n        }\r\n\r\n        // Enabled binding support\r\n        if (attr.bsEnabled) {\r\n          scope.$watch(attr.bsEnabled, function (newValue, oldValue) {\r\n            // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\r\n            if (!tooltip || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\r\n            if (newValue === false) {\r\n              tooltip.setEnabled(false);\r\n            } else {\r\n              tooltip.setEnabled(true);\r\n            }\r\n          });\r\n        }\r\n\r\n        // Viewport support\r\n        if (attr.viewport) {\r\n          scope.$watch(attr.viewport, function (newValue) {\r\n            if (!tooltip || !angular.isDefined(newValue)) return;\r\n            tooltip.setViewport(newValue);\r\n          });\r\n        }\r\n\r\n        // Initialize popover\r\n        tooltip = $tooltip(element, options);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (tooltip) tooltip.destroy();\r\n          options = null;\r\n          tooltip = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n\r\n// Source: timepicker\\timepicker.js\r\nangular.module('mgcrea.ngStrap.timepicker', ['mgcrea.ngStrap.helpers.dateParser', 'mgcrea.ngStrap.helpers.dateFormatter', 'mgcrea.ngStrap.tooltip'])\r\n\r\n  .provider('$timepicker', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      defaultDate: 'auto',\r\n      // uncommenting the following line will break backwards compatability\r\n      // prefixEvent: 'timepicker',\r\n      prefixClass: 'timepicker',\r\n      placement: 'bottom-left',\r\n      templateUrl: 'timepicker/timepicker.tpl.html',\r\n      trigger: 'focus',\r\n      container: false,\r\n      keyboard: true,\r\n      html: false,\r\n      delay: 0,\r\n      // lang: $locale.id,\r\n      useNative: true,\r\n      timeType: 'date',\r\n      timeFormat: 'shortTime',\r\n      timezone: null,\r\n      modelTimeFormat: null,\r\n      autoclose: false,\r\n      minTime: -Infinity,\r\n      maxTime: +Infinity,\r\n      length: 5,\r\n      hourStep: 1,\r\n      minuteStep: 5,\r\n      secondStep: 5,\r\n      roundDisplay: false,\r\n      iconUp: 'glyphicon glyphicon-chevron-up',\r\n      iconDown: 'glyphicon glyphicon-chevron-down',\r\n      arrowBehavior: 'pager'\r\n    };\r\n\r\n    this.$get = function ($window, $document, $rootScope, $sce, $dateFormatter, $tooltip, $timeout) {\r\n\r\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n      var isTouch = ('createTouch' in $window.document) && isNative;\r\n      if (!defaults.lang) {\r\n        defaults.lang = $dateFormatter.getDefaultLocale();\r\n      }\r\n\r\n      function timepickerFactory (element, controller, config) {\r\n\r\n        var $timepicker = $tooltip(element, angular.extend({}, defaults, config));\r\n        var parentScope = config.scope;\r\n        var options = $timepicker.$options;\r\n        var scope = $timepicker.$scope;\r\n\r\n        var lang = options.lang;\r\n        var formatDate = function (date, format, timezone) {\r\n          return $dateFormatter.formatDate(date, format, lang, timezone);\r\n        };\r\n\r\n        function floorMinutes (time) {\r\n          // coeff used to floor current time to nearest minuteStep interval\r\n          var coeff = 1000 * 60 * options.minuteStep;\r\n          return new Date(Math.floor(time.getTime() / coeff) * coeff);\r\n        }\r\n\r\n        // View vars\r\n\r\n        var selectedIndex = 0;\r\n        var defaultDate = options.roundDisplay ? floorMinutes(new Date()) : new Date();\r\n        var startDate = controller.$dateValue || defaultDate;\r\n        var viewDate = {\r\n          hour: startDate.getHours(),\r\n          meridian: startDate.getHours() < 12,\r\n          minute: startDate.getMinutes(),\r\n          second: startDate.getSeconds(),\r\n          millisecond: startDate.getMilliseconds()\r\n        };\r\n\r\n        var format = $dateFormatter.getDatetimeFormat(options.timeFormat, lang);\r\n\r\n        var hoursFormat = $dateFormatter.hoursFormat(format);\r\n        var timeSeparator = $dateFormatter.timeSeparator(format);\r\n        var minutesFormat = $dateFormatter.minutesFormat(format);\r\n        var secondsFormat = $dateFormatter.secondsFormat(format);\r\n        var showSeconds = $dateFormatter.showSeconds(format);\r\n        var showAM = $dateFormatter.showAM(format);\r\n\r\n        scope.$iconUp = options.iconUp;\r\n        scope.$iconDown = options.iconDown;\r\n\r\n        // Scope methods\r\n\r\n        scope.$select = function (date, index) {\r\n          $timepicker.select(date, index);\r\n        };\r\n        scope.$moveIndex = function (value, index) {\r\n          $timepicker.$moveIndex(value, index);\r\n        };\r\n        scope.$switchMeridian = function (date) {\r\n          $timepicker.switchMeridian(date);\r\n        };\r\n\r\n        // Public methods\r\n\r\n        $timepicker.update = function (date) {\r\n          // console.warn('$timepicker.update() newValue=%o', date);\r\n          if (angular.isDate(date) && !isNaN(date.getTime())) {\r\n            $timepicker.$date = date;\r\n            angular.extend(viewDate, {\r\n              hour: date.getHours(),\r\n              minute: date.getMinutes(),\r\n              second: date.getSeconds(),\r\n              millisecond: date.getMilliseconds()\r\n            });\r\n            $timepicker.$build();\r\n          } else if (!$timepicker.$isBuilt) {\r\n            $timepicker.$build();\r\n          }\r\n        };\r\n\r\n        $timepicker.select = function (date, index, keep) {\r\n          // console.warn('$timepicker.select', date, scope.$mode);\r\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\r\n            controller.$dateValue = options.defaultDate === 'today' ? new Date() : new Date(1970, 0, 1);\r\n          }\r\n\r\n          if (!angular.isDate(date)) date = new Date(date);\r\n          if (index === 0) controller.$dateValue.setHours(date.getHours());\r\n          else if (index === 1) controller.$dateValue.setMinutes(date.getMinutes());\r\n          else if (index === 2) controller.$dateValue.setSeconds(date.getSeconds());\r\n          controller.$setViewValue(angular.copy(controller.$dateValue));\r\n          controller.$render();\r\n          if (options.autoclose && !keep) {\r\n            $timeout(function () {\r\n              $timepicker.hide(true);\r\n            });\r\n          }\r\n        };\r\n\r\n        $timepicker.switchMeridian = function (date) {\r\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\r\n            return;\r\n          }\r\n          var hours = (date || controller.$dateValue).getHours();\r\n          controller.$dateValue.setHours(hours < 12 ? hours + 12 : hours - 12);\r\n          controller.$setViewValue(angular.copy(controller.$dateValue));\r\n          controller.$render();\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $timepicker.$build = function () {\r\n          // console.warn('$timepicker.$build() viewDate=%o', viewDate);\r\n          var i;\r\n          var midIndex = scope.midIndex = parseInt(options.length / 2, 10);\r\n          var hours = [];\r\n          var hour;\r\n          for (i = 0; i < options.length; i++) {\r\n            hour = new Date(1970, 0, 1, viewDate.hour - (midIndex - i) * options.hourStep);\r\n            hours.push({\r\n              date: hour,\r\n              label: formatDate(hour, hoursFormat),\r\n              selected: $timepicker.$date && $timepicker.$isSelected(hour, 0),\r\n              disabled: $timepicker.$isDisabled(hour, 0)\r\n            });\r\n          }\r\n          var minutes = [];\r\n          var minute;\r\n          for (i = 0; i < options.length; i++) {\r\n            minute = new Date(1970, 0, 1, 0, viewDate.minute - (midIndex - i) * options.minuteStep);\r\n            minutes.push({\r\n              date: minute,\r\n              label: formatDate(minute, minutesFormat),\r\n              selected: $timepicker.$date && $timepicker.$isSelected(minute, 1),\r\n              disabled: $timepicker.$isDisabled(minute, 1)\r\n            });\r\n          }\r\n          var seconds = [];\r\n          var second;\r\n          for (i = 0; i < options.length; i++) {\r\n            second = new Date(1970, 0, 1, 0, 0, viewDate.second - (midIndex - i) * options.secondStep);\r\n            seconds.push({\r\n              date: second,\r\n              label: formatDate(second, secondsFormat),\r\n              selected: $timepicker.$date && $timepicker.$isSelected(second, 2),\r\n              disabled: $timepicker.$isDisabled(second, 2)\r\n            });\r\n          }\r\n\r\n          var rows = [];\r\n          for (i = 0; i < options.length; i++) {\r\n            if (showSeconds) {\r\n              rows.push([hours[i], minutes[i], seconds[i]]);\r\n            } else {\r\n              rows.push([hours[i], minutes[i]]);\r\n            }\r\n          }\r\n          scope.rows = rows;\r\n          scope.showSeconds = showSeconds;\r\n          scope.showAM = showAM;\r\n          scope.isAM = ($timepicker.$date || hours[midIndex].date).getHours() < 12;\r\n          scope.timeSeparator = timeSeparator;\r\n          $timepicker.$isBuilt = true;\r\n        };\r\n\r\n        $timepicker.$isSelected = function (date, index) {\r\n          if (!$timepicker.$date) return false;\r\n          else if (index === 0) {\r\n            return date.getHours() === $timepicker.$date.getHours();\r\n          } else if (index === 1) {\r\n            return date.getMinutes() === $timepicker.$date.getMinutes();\r\n          } else if (index === 2) {\r\n            return date.getSeconds() === $timepicker.$date.getSeconds();\r\n          }\r\n        };\r\n\r\n        $timepicker.$isDisabled = function (date, index) {\r\n          var selectedTime;\r\n          if (index === 0) {\r\n            selectedTime = date.getTime() + viewDate.minute * 6e4 + viewDate.second * 1e3;\r\n          } else if (index === 1) {\r\n            selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.second * 1e3;\r\n          } else if (index === 2) {\r\n            selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.minute * 6e4;\r\n          }\r\n          return selectedTime < options.minTime * 1 || selectedTime > options.maxTime * 1;\r\n        };\r\n\r\n        scope.$arrowAction = function (value, index) {\r\n          if (options.arrowBehavior === 'picker') {\r\n            $timepicker.$setTimeByStep(value, index);\r\n          } else {\r\n            $timepicker.$moveIndex(value, index);\r\n          }\r\n        };\r\n\r\n        $timepicker.$setTimeByStep = function (value, index) {\r\n          var newDate = new Date($timepicker.$date || startDate);\r\n          var hours = newDate.getHours();\r\n          var minutes = newDate.getMinutes();\r\n          var seconds = newDate.getSeconds();\r\n          if (index === 0) {\r\n            newDate.setHours(hours - (parseInt(options.hourStep, 10) * value));\r\n          } else if (index === 1) {\r\n            newDate.setMinutes(minutes - (parseInt(options.minuteStep, 10) * value));\r\n          } else if (index === 2) {\r\n            newDate.setSeconds(seconds - (parseInt(options.secondStep, 10) * value));\r\n          }\r\n          $timepicker.select(newDate, index, true);\r\n        };\r\n\r\n        $timepicker.$moveIndex = function (value, index) {\r\n          var targetDate;\r\n          if (index === 0) {\r\n            targetDate = new Date(1970, 0, 1, viewDate.hour + (value * options.length), viewDate.minute, viewDate.second);\r\n            angular.extend(viewDate, {\r\n              hour: targetDate.getHours()\r\n            });\r\n          } else if (index === 1) {\r\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute + (value * options.length * options.minuteStep), viewDate.second);\r\n            angular.extend(viewDate, {\r\n              minute: targetDate.getMinutes()\r\n            });\r\n          } else if (index === 2) {\r\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute, viewDate.second + (value * options.length * options.secondStep));\r\n            angular.extend(viewDate, {\r\n              second: targetDate.getSeconds()\r\n            });\r\n          }\r\n          $timepicker.$build();\r\n        };\r\n\r\n        $timepicker.$onMouseDown = function (evt) {\r\n          // Prevent blur on mousedown on .dropdown-menu\r\n          if (evt.target.nodeName.toLowerCase() !== 'input') evt.preventDefault();\r\n          evt.stopPropagation();\r\n          // Emulate click for mobile devices\r\n          if (isTouch) {\r\n            var targetEl = angular.element(evt.target);\r\n            if (targetEl[0].nodeName.toLowerCase() !== 'button') {\r\n              targetEl = targetEl.parent();\r\n            }\r\n            targetEl.triggerHandler('click');\r\n          }\r\n        };\r\n\r\n        $timepicker.$onKeyDown = function (evt) {\r\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n\r\n          // Close on enter\r\n          if (evt.keyCode === 13) {\r\n            $timepicker.hide(true);\r\n            return;\r\n          }\r\n\r\n          // Navigate with keyboard\r\n          var newDate = new Date($timepicker.$date);\r\n          var hours = newDate.getHours();\r\n          var hoursLength = formatDate(newDate, hoursFormat).length;\r\n          var minutes = newDate.getMinutes();\r\n          var minutesLength = formatDate(newDate, minutesFormat).length;\r\n          var seconds = newDate.getSeconds();\r\n          var secondsLength = formatDate(newDate, secondsFormat).length;\r\n          var sepLength = 1;\r\n          var lateralMove = /(37|39)/.test(evt.keyCode);\r\n          var count = 2 + showSeconds * 1 + showAM * 1;\r\n\r\n          // Navigate indexes (left, right)\r\n          if (lateralMove) {\r\n            if (evt.keyCode === 37) selectedIndex = selectedIndex < 1 ? count - 1 : selectedIndex - 1;\r\n            else if (evt.keyCode === 39) selectedIndex = selectedIndex < count - 1 ? selectedIndex + 1 : 0;\r\n          }\r\n\r\n          // Update values (up, down)\r\n          var selectRange = [0, hoursLength];\r\n          var incr = 0;\r\n          if (evt.keyCode === 38) incr = -1;\r\n          if (evt.keyCode === 40) incr = +1;\r\n          var isSeconds = selectedIndex === 2 && showSeconds;\r\n          var isMeridian = selectedIndex === 2 && !showSeconds || selectedIndex === 3 && showSeconds;\r\n          if (selectedIndex === 0) {\r\n            newDate.setHours(hours + incr * parseInt(options.hourStep, 10));\r\n            // re-calculate hours length because we have changed hours value\r\n            hoursLength = formatDate(newDate, hoursFormat).length;\r\n            selectRange = [0, hoursLength];\r\n          } else if (selectedIndex === 1) {\r\n            newDate.setMinutes(minutes + incr * parseInt(options.minuteStep, 10));\r\n            // re-calculate minutes length because we have changes minutes value\r\n            minutesLength = formatDate(newDate, minutesFormat).length;\r\n            selectRange = [hoursLength + sepLength, minutesLength];\r\n          } else if (isSeconds) {\r\n            newDate.setSeconds(seconds + incr * parseInt(options.secondStep, 10));\r\n            // re-calculate seconds length because we have changes seconds value\r\n            secondsLength = formatDate(newDate, secondsFormat).length;\r\n            selectRange = [hoursLength + sepLength + minutesLength + sepLength, secondsLength];\r\n          } else if (isMeridian) {\r\n            if (!lateralMove) $timepicker.switchMeridian();\r\n            selectRange = [hoursLength + sepLength + minutesLength + sepLength + (secondsLength + sepLength) * showSeconds, 2];\r\n          }\r\n          $timepicker.select(newDate, selectedIndex, true);\r\n          createSelection(selectRange[0], selectRange[1]);\r\n          parentScope.$digest();\r\n        };\r\n\r\n        // Private\r\n\r\n        function createSelection (start, length) {\r\n          var end = start + length;\r\n          if (element[0].createTextRange) {\r\n            var selRange = element[0].createTextRange();\r\n            selRange.collapse(true);\r\n            selRange.moveStart('character', start);\r\n            selRange.moveEnd('character', end);\r\n            selRange.select();\r\n          } else if (element[0].setSelectionRange) {\r\n            element[0].setSelectionRange(start, end);\r\n          } else if (angular.isUndefined(element[0].selectionStart)) {\r\n            element[0].selectionStart = start;\r\n            element[0].selectionEnd = end;\r\n          }\r\n        }\r\n\r\n        function focusElement () {\r\n          element[0].focus();\r\n        }\r\n\r\n        // Overrides\r\n\r\n        var _init = $timepicker.init;\r\n        $timepicker.init = function () {\r\n          if (isNative && options.useNative) {\r\n            element.prop('type', 'time');\r\n            element.css('-webkit-appearance', 'textfield');\r\n            return;\r\n          } else if (isTouch) {\r\n            element.prop('type', 'text');\r\n            element.attr('readonly', 'true');\r\n            element.on('click', focusElement);\r\n          }\r\n          _init();\r\n        };\r\n\r\n        var _destroy = $timepicker.destroy;\r\n        $timepicker.destroy = function () {\r\n          if (isNative && options.useNative) {\r\n            element.off('click', focusElement);\r\n          }\r\n          _destroy();\r\n        };\r\n\r\n        var _show = $timepicker.show;\r\n        $timepicker.show = function () {\r\n          if ((!isTouch && element.attr('readonly')) || element.attr('disabled')) return;\r\n          _show();\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed imediately.\r\n          $timeout(function () {\r\n            if ($timepicker.$element) $timepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\r\n            if (options.keyboard) {\r\n              if (element) element.on('keydown', $timepicker.$onKeyDown);\r\n            }\r\n          }, 0, false);\r\n        };\r\n\r\n        var _hide = $timepicker.hide;\r\n        $timepicker.hide = function (blur) {\r\n          if (!$timepicker.$isShown) return;\r\n          if ($timepicker.$element) $timepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\r\n          if (options.keyboard) {\r\n            if (element) element.off('keydown', $timepicker.$onKeyDown);\r\n          }\r\n          _hide(blur);\r\n        };\r\n\r\n        return $timepicker;\r\n\r\n      }\r\n\r\n      timepickerFactory.defaults = defaults;\r\n      return timepickerFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n\r\n  .directive('bsTimepicker', function ($window, $parse, $q, $dateFormatter, $dateParser, $timepicker) {\r\n\r\n    var defaults = $timepicker.defaults;\r\n    var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        // Directive options\r\n        var options = {\r\n          scope: scope\r\n        };\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'autoclose', 'timeType', 'timeFormat', 'timezone', 'modelTimeFormat', 'useNative', 'hourStep', 'minuteStep', 'secondStep', 'length', 'arrowBehavior', 'iconUp', 'iconDown', 'roundDisplay', 'id', 'prefixClass', 'prefixEvent', 'defaultDate'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container', 'autoclose', 'useNative', 'roundDisplay'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\r\n            options[key] = false;\r\n          }\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Initialize timepicker\r\n        if (isNative && (options.useNative || defaults.useNative)) options.timeFormat = 'HH:mm';\r\n        var timepicker = $timepicker(element, controller, options);\r\n        options = timepicker.$options;\r\n\r\n        var lang = options.lang;\r\n        var formatDate = function (date, format, timezone) {\r\n          return $dateFormatter.formatDate(date, format, lang, timezone);\r\n        };\r\n\r\n        // Visibility binding support\r\n        if (attr.bsShow) {\r\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\r\n            if (!timepicker || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(timepicker),?/i);\r\n            if (newValue === true) {\r\n              timepicker.show();\r\n            } else {\r\n              timepicker.hide();\r\n            }\r\n          });\r\n        }\r\n\r\n        // Initialize parser\r\n        var dateParser = $dateParser({\r\n          format: options.timeFormat,\r\n          lang: lang\r\n        });\r\n\r\n        // Observe attributes for changes\r\n        angular.forEach(['minTime', 'maxTime'], function (key) {\r\n          // console.warn('attr.$observe(%s)', key, attr[key]);\r\n          if (angular.isDefined(attr[key])) {\r\n            attr.$observe(key, function (newValue) {\r\n              timepicker.$options[key] = dateParser.getTimeForAttribute(key, newValue);\r\n              if (!isNaN(timepicker.$options[key])) timepicker.$build();\r\n              validateAgainstMinMaxTime(controller.$dateValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Watch model for changes\r\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\r\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue, controller.$dateValue);\r\n          timepicker.update(controller.$dateValue);\r\n        }, true);\r\n\r\n        function validateAgainstMinMaxTime (parsedTime) {\r\n          if (!angular.isDate(parsedTime)) return;\r\n          var isMinValid = isNaN(options.minTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) >= options.minTime;\r\n          var isMaxValid = isNaN(options.maxTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) <= options.maxTime;\r\n          var isValid = isMinValid && isMaxValid;\r\n          controller.$setValidity('date', isValid);\r\n          controller.$setValidity('min', isMinValid);\r\n          controller.$setValidity('max', isMaxValid);\r\n          // Only update the model when we have a valid date\r\n          if (!isValid) {\r\n            return;\r\n          }\r\n          controller.$dateValue = parsedTime;\r\n        }\r\n\r\n        // viewValue -> $parsers -> modelValue\r\n        controller.$parsers.unshift(function (viewValue) {\r\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\r\n          var date;\r\n          // Null values should correctly reset the model value & validity\r\n          if (!viewValue) {\r\n            // BREAKING CHANGE:\r\n            // return null (not undefined) when input value is empty, so angularjs 1.3\r\n            // ngModelController can go ahead and run validators, like ngRequired\r\n            controller.$setValidity('date', true);\r\n            return null;\r\n          }\r\n          var parsedTime = angular.isDate(viewValue) ? viewValue : dateParser.parse(viewValue, controller.$dateValue);\r\n          if (!parsedTime || isNaN(parsedTime.getTime())) {\r\n            controller.$setValidity('date', false);\r\n            // Return undefined, causes ngModelController to\r\n            // invalidate model value\r\n            return undefined;\r\n          }\r\n          validateAgainstMinMaxTime(parsedTime);\r\n\r\n          if (options.timeType === 'string') {\r\n            date = dateParser.timezoneOffsetAdjust(parsedTime, options.timezone, true);\r\n            return formatDate(date, options.modelTimeFormat || options.timeFormat);\r\n          }\r\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\r\n          if (options.timeType === 'number') {\r\n            return date.getTime();\r\n          } else if (options.timeType === 'unix') {\r\n            return date.getTime() / 1000;\r\n          } else if (options.timeType === 'iso') {\r\n            return date.toISOString();\r\n          }\r\n          return new Date(date);\r\n        });\r\n\r\n        // modelValue -> $formatters -> viewValue\r\n        controller.$formatters.push(function (modelValue) {\r\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n          var date;\r\n          if (angular.isUndefined(modelValue) || modelValue === null) {\r\n            date = NaN;\r\n          } else if (angular.isDate(modelValue)) {\r\n            date = modelValue;\r\n          } else if (options.timeType === 'string') {\r\n            date = dateParser.parse(modelValue, null, options.modelTimeFormat);\r\n          } else if (options.timeType === 'unix') {\r\n            date = new Date(modelValue * 1000);\r\n          } else {\r\n            date = new Date(modelValue);\r\n          }\r\n          // Setup default value?\r\n          // if(isNaN(date.getTime())) date = new Date(new Date().setMinutes(0) + 36e5);\r\n          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\r\n          return getTimeFormattedString();\r\n        });\r\n\r\n        // viewValue -> element\r\n        controller.$render = function () {\r\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\r\n          element.val(getTimeFormattedString());\r\n        };\r\n\r\n        function getTimeFormattedString () {\r\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.timeFormat);\r\n        }\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (timepicker) timepicker.destroy();\r\n          options = null;\r\n          timepicker = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n\r\n// Source: tab\\tab.js\r\nangular.module('mgcrea.ngStrap.tab', [])\r\n\r\n  .provider('$tab', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      template: 'tab/tab.tpl.html',\r\n      navClass: 'nav-tabs',\r\n      activeClass: 'active',\r\n      isVertical: false\r\n    };\r\n    var _tabsHash = {};\r\n\r\n    var _addTabControl = function (key, control) {\r\n      if (!_tabsHash[key]) _tabsHash[key] = control;\r\n    };\r\n\r\n    var controller = this.controller = function ($scope, $element, $attrs, $timeout) {\r\n      var self = this;\r\n\r\n      // Attributes options\r\n      self.$options = angular.copy(defaults);\r\n      angular.forEach(['animation', 'navClass', 'activeClass', 'id', 'isVertical'], function (key) {\r\n        if (angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\r\n      });\r\n\r\n      // use string regex match boolean attr falsy values, leave truthy values be\r\n      var falseValueRegExp = /^(false|0|)$/i;\r\n      angular.forEach(['isVertical'], function (key) {\r\n        if (angular.isDefined($attrs[key]) && falseValueRegExp.test($attrs[key])) self.$options[key] = false;\r\n      });\r\n\r\n      // Publish options on scope\r\n      $scope.$navClass = self.$options.navClass;\r\n      $scope.$activeClass = self.$options.activeClass;\r\n\r\n      $scope.$onClick = function $onClick (evt, pane, index) {\r\n        if (!pane.disabled) {\r\n          self.$setActive(pane.name || index);\r\n          focusCurrentTab();\r\n        }\r\n\r\n        evt.preventDefault();\r\n        evt.stopPropagation();\r\n      };\r\n\r\n      function navigatePane (index, toLeft) {\r\n        var newIndex = 0;\r\n\r\n        if (toLeft) {\r\n          // Moving to the left\r\n          newIndex = index - 1 < 0 ? (self.$panes.length - 1) : (index - 1);\r\n        } else {\r\n          // Moving to the right\r\n          newIndex = (index + 1) >= self.$panes.length ? 0 : (index + 1);\r\n        }\r\n\r\n        if (self.$panes[newIndex].disabled) {\r\n          navigatePane(newIndex, toLeft);\r\n        } else {\r\n          self.$setActive(self.$panes[newIndex].name || newIndex);\r\n          focusCurrentTab();\r\n        }\r\n      }\r\n\r\n      function focusCurrentTab () {\r\n        $timeout(function () {\r\n          var activeAs = angular.element($element[0].querySelectorAll('li.' + self.$options.activeClass));\r\n\r\n          if (activeAs.length > 0 && activeAs[0]) {\r\n            activeAs[0].focus();\r\n          }\r\n        }, 100);\r\n      }\r\n\r\n      self.$panes = $scope.$panes = [];\r\n\r\n      // Please use $activePaneChangeListeners if you use `bsActivePane`\r\n      // Because we removed `ngModel` as default, we rename viewChangeListeners to\r\n      // activePaneChangeListeners to make more sense.\r\n      self.$activePaneChangeListeners = self.$viewChangeListeners = [];\r\n\r\n      self.$push = function (pane) {\r\n        if (angular.isUndefined(self.$panes.$active)) {\r\n          $scope.$setActive(pane.name || 0);\r\n        }\r\n\r\n        self.$panes.push(pane);\r\n\r\n        self.$panes.forEach(function (tabPane, index) {\r\n          // Set an id value for the pane so that it can be used in the template\r\n          tabPane.$describedBy = self.$options.id === undefined ? undefined : self.$options.id + '_$tab_' + index;\r\n          tabPane.$labeledBy = self.$options.id === undefined ? undefined : self.$options.id + '_$tab_' + index + '_a';\r\n        });\r\n      };\r\n\r\n      self.$remove = function (pane) {\r\n        var index = self.$panes.indexOf(pane);\r\n        var active = self.$panes.$active;\r\n        var activeIndex;\r\n        if (angular.isString(active)) {\r\n          activeIndex = self.$panes.map(function (pane) {\r\n            return pane.name;\r\n          }).indexOf(active);\r\n        } else {\r\n          activeIndex = self.$panes.$active;\r\n        }\r\n\r\n        // remove pane from $panes array\r\n        self.$panes.splice(index, 1);\r\n\r\n        if (index < activeIndex) {\r\n          // we removed a pane before the active pane, so we need to\r\n          // decrement the active pane index\r\n          activeIndex--;\r\n        } else if (index === activeIndex && activeIndex === self.$panes.length) {\r\n          // we remove the active pane and it was the one at the end,\r\n          // so select the previous one\r\n          activeIndex--;\r\n        }\r\n        if (activeIndex >= 0 && activeIndex < self.$panes.length) {\r\n          self.$setActive(self.$panes[activeIndex].name || activeIndex);\r\n        } else {\r\n          self.$setActive();\r\n        }\r\n      };\r\n\r\n      self.$setActive = $scope.$setActive = function (value) {\r\n        self.$panes.$active = value;\r\n        self.$activePaneChangeListeners.forEach(function (fn) {\r\n          fn();\r\n        });\r\n      };\r\n\r\n      self.$isActive = $scope.$isActive = function ($pane, $index) {\r\n        return self.$panes.$active === $pane.name || self.$panes.$active === $index;\r\n      };\r\n\r\n      self.$onKeyPress = $scope.$onKeyPress = function (e, name, index) {\r\n        if (e.keyCode === 32 || e.charCode === 32 || e.keyCode === 13 || e.charCode === 13) {\r\n          // If space or enter was pressed\r\n          self.$setActive(name);\r\n\r\n          e.preventDefault();\r\n          e.stopPropagation();\r\n\r\n        } else if (!self.$options.isVertical && (e.keyCode === 37 || e.charCode === 37 || e.keyCode === 39 || e.charCode === 39)) {\r\n          // If the left of right arrow key was pressed.\r\n          navigatePane(index, (e.keyCode === 37 || e.charCode === 37));\r\n        } else if (self.$options.isVertical && (e.keyCode === 38 || e.charCode === 38 || e.keyCode === 40 || e.charCode === 40)) {\r\n          // If the left of right arrow key was pressed.\r\n          navigatePane(index, (e.keyCode === 38 || e.charCode === 38));\r\n        }\r\n      };\r\n    };\r\n\r\n    this.$get = function () {\r\n      var $tab = {};\r\n      $tab.defaults = defaults;\r\n      $tab.controller = controller;\r\n      $tab.addTabControl = _addTabControl;\r\n      $tab.tabsHash = _tabsHash;\r\n      return $tab;\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsTabs', function ($window, $animate, $tab, $parse, $timeout) {\r\n\r\n    var defaults = $tab.defaults;\r\n\r\n    return {\r\n      require: ['?ngModel', 'bsTabs'],\r\n      transclude: true,\r\n      scope: true,\r\n      controller: ['$scope', '$element', '$attrs', '$timeout', $tab.controller],\r\n      templateUrl: function (element, attr) {\r\n        return attr.template || defaults.template;\r\n      },\r\n      link: function postLink (scope, element, attrs, controllers) {\r\n\r\n        var ngModelCtrl = controllers[0];\r\n        var bsTabsCtrl = controllers[1];\r\n\r\n        // Add a way for developers to access tab scope if needed.  This allows for more fine grained control over what\r\n        // tabs are available in the tab component\r\n        if (attrs.tabKey !== '' && attrs.tabKey !== undefined) {\r\n          $tab.addTabControl(attrs.tabKey, bsTabsCtrl);\r\n        }\r\n\r\n        // 'ngModel' does interfere with form validation\r\n        // and status, use `bsActivePane` instead to avoid it\r\n        if (ngModelCtrl) {\r\n\r\n          // Update the modelValue following\r\n          bsTabsCtrl.$activePaneChangeListeners.push(function () {\r\n            ngModelCtrl.$setViewValue(bsTabsCtrl.$panes.$active);\r\n          });\r\n\r\n          // modelValue -> $formatters -> viewValue\r\n          ngModelCtrl.$formatters.push(function (modelValue) {\r\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n            bsTabsCtrl.$setActive(modelValue);\r\n            return modelValue;\r\n          });\r\n        }\r\n\r\n        bsTabsCtrl.$activePaneChangeListeners.push(function () {\r\n          $timeout(function () {\r\n            // get li elements\r\n            var liElements = element.find('li');\r\n            for (var i = 0; i < liElements.length; i++) {\r\n              var iElement = angular.element(liElements[i]);\r\n              if (iElement.hasClass(bsTabsCtrl.$options.activeClass)) {\r\n                // if li is active, set focus to it.\r\n                iElement.find('a')[0].focus();\r\n              }\r\n            }\r\n            // delay, for the class (.active) change to reflect in DOM.\r\n          }, 100);\r\n        });\r\n\r\n        if (attrs.bsActivePane) {\r\n          // adapted from angularjs ngModelController bindings\r\n          // https://github.com/angular/angular.js/blob/v1.3.1/src%2Fng%2Fdirective%2Finput.js#L1730\r\n          var parsedBsActivePane = $parse(attrs.bsActivePane);\r\n\r\n          // Update bsActivePane value with change\r\n          bsTabsCtrl.$activePaneChangeListeners.push(function () {\r\n            parsedBsActivePane.assign(scope, bsTabsCtrl.$panes.$active);\r\n          });\r\n\r\n          // watch bsActivePane for value changes\r\n          scope.$watch(attrs.bsActivePane, function (newValue, oldValue) {\r\n            bsTabsCtrl.$setActive(newValue);\r\n          }, true);\r\n        }\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsPane', function ($window, $animate, $sce) {\r\n\r\n    return {\r\n      require: ['^?ngModel', '^bsTabs'],\r\n      scope: true,\r\n      link: function postLink (scope, element, attrs, controllers) {\r\n\r\n        // var ngModelCtrl = controllers[0];\r\n        var bsTabsCtrl = controllers[1];\r\n\r\n        // Add base class\r\n        element.addClass('tab-pane');\r\n\r\n        // Set up the assistive attributes\r\n        element.attr('role', 'tabpanel');\r\n\r\n        // Observe title attribute for change\r\n        attrs.$observe('title', function (newValue, oldValue) {\r\n          scope.title = $sce.trustAsHtml(newValue);\r\n        });\r\n\r\n        // Save tab name into scope\r\n        scope.name = attrs.name;\r\n        // Save tab id into scope\r\n        scope.id = attrs.id;\r\n\r\n        scope.name = scope.name || scope.id;\r\n\r\n        // Add animation class\r\n        if (bsTabsCtrl.$options.animation) {\r\n          element.addClass(bsTabsCtrl.$options.animation);\r\n        }\r\n\r\n        attrs.$observe('disabled', function (newValue, oldValue) {\r\n          scope.disabled = scope.$eval(newValue);\r\n        });\r\n\r\n        // Push pane to parent bsTabs controller\r\n        bsTabsCtrl.$push(scope);\r\n\r\n        // Once the push has occured when can then update the element with some properties.\r\n        // Update the aria-describedby attribute\r\n        if (scope.$describedBy !== undefined) {\r\n          element.attr('aria-describedby', scope.$describedBy);\r\n        }\r\n\r\n        // remove pane from tab controller when pane is destroyed\r\n        scope.$on('$destroy', function () {\r\n          bsTabsCtrl.$remove(scope);\r\n        });\r\n\r\n        function render () {\r\n          var index = bsTabsCtrl.$panes.indexOf(scope);\r\n\r\n          $animate[bsTabsCtrl.$isActive(scope, index) ? 'addClass' : 'removeClass'](element, bsTabsCtrl.$options.activeClass);\r\n        }\r\n\r\n        bsTabsCtrl.$activePaneChangeListeners.push(function () {\r\n          render();\r\n        });\r\n        render();\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n\r\n// Source: select\\select.js\r\nangular.module('mgcrea.ngStrap.select', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\r\n\r\n  .provider('$select', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      prefixClass: 'select',\r\n      prefixEvent: '$select',\r\n      placement: 'bottom-left',\r\n      templateUrl: 'select/select.tpl.html',\r\n      trigger: 'focus',\r\n      container: false,\r\n      keyboard: true,\r\n      html: false,\r\n      delay: 0,\r\n      multiple: false,\r\n      allNoneButtons: false,\r\n      sort: true,\r\n      caretHtml: '&nbsp;<span class=\"caret\"></span>',\r\n      placeholder: 'Choose among the following...',\r\n      allText: 'All',\r\n      noneText: 'None',\r\n      maxLength: 3,\r\n      maxLengthHtml: 'selected',\r\n      iconCheckmark: 'glyphicon glyphicon-ok',\r\n      toggle: false\r\n    };\r\n\r\n    this.$get = function ($window, $document, $rootScope, $tooltip, $timeout) {\r\n\r\n      // var bodyEl = angular.element($window.document.body);\r\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n      var isTouch = ('createTouch' in $window.document) && isNative;\r\n\r\n      function SelectFactory (element, controller, config) {\r\n\r\n        var $select = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n\r\n        $select = $tooltip(element, options);\r\n        var scope = $select.$scope;\r\n\r\n        scope.$matches = [];\r\n        if (options.multiple) {\r\n          scope.$activeIndex = [];\r\n        } else {\r\n          scope.$activeIndex = -1;\r\n        }\r\n        scope.$isMultiple = options.multiple;\r\n        scope.$showAllNoneButtons = options.allNoneButtons && options.multiple;\r\n        scope.$iconCheckmark = options.iconCheckmark;\r\n        scope.$allText = options.allText;\r\n        scope.$noneText = options.noneText;\r\n\r\n        scope.$activate = function (index) {\r\n          scope.$$postDigest(function () {\r\n            $select.activate(index);\r\n          });\r\n        };\r\n\r\n        scope.$select = function (index, evt) {\r\n          scope.$$postDigest(function () {\r\n            $select.select(index);\r\n          });\r\n        };\r\n\r\n        scope.$isVisible = function () {\r\n          return $select.$isVisible();\r\n        };\r\n\r\n        scope.$isActive = function (index) {\r\n          return $select.$isActive(index);\r\n        };\r\n\r\n        scope.$selectAll = function () {\r\n          for (var i = 0; i < scope.$matches.length; i++) {\r\n            if (!scope.$isActive(i)) {\r\n              scope.$select(i);\r\n            }\r\n          }\r\n        };\r\n\r\n        scope.$selectNone = function () {\r\n          for (var i = 0; i < scope.$matches.length; i++) {\r\n            if (scope.$isActive(i)) {\r\n              scope.$select(i);\r\n            }\r\n          }\r\n        };\r\n\r\n        // Public methods\r\n\r\n        $select.update = function (matches) {\r\n          scope.$matches = matches;\r\n          $select.$updateActiveIndex();\r\n        };\r\n\r\n        $select.activate = function (index) {\r\n          if (options.multiple) {\r\n            if ($select.$isActive(index)) {\r\n              scope.$activeIndex.splice(scope.$activeIndex.indexOf(index), 1);\r\n            } else {\r\n              scope.$activeIndex.push(index);\r\n            }\r\n            if (options.sort) scope.$activeIndex.sort(function (a, b) { return a - b; }); // use numeric sort instead of default sort\r\n          } else {\r\n            scope.$activeIndex = index;\r\n          }\r\n          return scope.$activeIndex;\r\n        };\r\n\r\n        $select.select = function (index) {\r\n          if (angular.isUndefined(index) || index < 0 || index >= scope.$matches.length) { return; }\r\n          var value = scope.$matches[index].value;\r\n          scope.$apply(function () {\r\n            $select.activate(index);\r\n            if (options.multiple) {\r\n              controller.$setViewValue(scope.$activeIndex.map(function (index) {\r\n                if (angular.isUndefined(scope.$matches[index])) {\r\n                  return null;\r\n                }\r\n                return scope.$matches[index].value;\r\n              }));\r\n            } else {\r\n              if (options.toggle) {\r\n                controller.$setViewValue((value === controller.$modelValue) ? undefined : value);\r\n              } else {\r\n                controller.$setViewValue(value);\r\n              }\r\n              // Hide if single select\r\n              $select.hide();\r\n            }\r\n          });\r\n          // Emit event\r\n          scope.$emit(options.prefixEvent + '.select', value, index, $select);\r\n          if (angular.isDefined(options.onSelect) && angular.isFunction(options.onSelect)) {\r\n            options.onSelect(value, index, $select);\r\n          }\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $select.$updateActiveIndex = function () {\r\n          if (options.multiple) {\r\n            if (angular.isArray(controller.$modelValue)) {\r\n              scope.$activeIndex = controller.$modelValue.map(function (value) {\r\n                return $select.$getIndex(value);\r\n              });\r\n            } else {\r\n              scope.$activeIndex = [];\r\n            }\r\n          } else {\r\n            if (angular.isDefined(controller.$modelValue) && scope.$matches.length) {\r\n              scope.$activeIndex = $select.$getIndex(controller.$modelValue);\r\n            } else {\r\n              scope.$activeIndex = -1;\r\n            }\r\n          }\r\n        };\r\n\r\n        $select.$isVisible = function () {\r\n          if (!options.minLength || !controller) {\r\n            return scope.$matches.length;\r\n          }\r\n          // minLength support\r\n          return scope.$matches.length && controller.$viewValue.length >= options.minLength;\r\n        };\r\n\r\n        $select.$isActive = function (index) {\r\n          if (options.multiple) {\r\n            return scope.$activeIndex.indexOf(index) !== -1;\r\n          }\r\n          return scope.$activeIndex === index;\r\n        };\r\n\r\n        $select.$getIndex = function (value) {\r\n          var index;\r\n          for (index = scope.$matches.length; index--;) {\r\n            if (angular.equals(scope.$matches[index].value, value)) break;\r\n          }\r\n          return index;\r\n        };\r\n\r\n        $select.$onMouseDown = function (evt) {\r\n          // Prevent blur on mousedown on .dropdown-menu\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n          // Emulate click for mobile devices\r\n          if (isTouch) {\r\n            var targetEl = angular.element(evt.target);\r\n            var anchor;\r\n\r\n            if (evt.target.nodeName !== 'A') {\r\n              var anchorCandidate = targetEl.parent();\r\n              while (!anchor && anchorCandidate.length > 0) {\r\n                if (anchorCandidate[0].nodeName === 'A') {\r\n                  anchor = anchorCandidate;\r\n                }\r\n                anchorCandidate = anchorCandidate.parent();\r\n              }\r\n            }\r\n\r\n            if (anchor) {\r\n              angular.element(anchor).triggerHandler('click');\r\n            } else {\r\n              targetEl.triggerHandler('click');\r\n            }\r\n          }\r\n        };\r\n\r\n        $select.$onKeyDown = function (evt) {\r\n          if (!/(9|13|38|40)/.test(evt.keyCode)) return;\r\n          // Let tab propagate\r\n          if (evt.keyCode !== 9) {\r\n            evt.preventDefault();\r\n            evt.stopPropagation();\r\n          }\r\n\r\n          // release focus on tab\r\n          if (options.multiple && evt.keyCode === 9) {\r\n            return $select.hide();\r\n          }\r\n\r\n          // Select with enter\r\n          if (!options.multiple && (evt.keyCode === 13 || evt.keyCode === 9)) {\r\n            return $select.select(scope.$activeIndex);\r\n          }\r\n\r\n          if (!options.multiple) {\r\n            // Navigate with keyboard\r\n            if (evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;\r\n            else if (evt.keyCode === 38 && scope.$activeIndex < 0) scope.$activeIndex = scope.$matches.length - 1;\r\n            else if (evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;\r\n            else if (angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;\r\n            scope.$digest();\r\n          }\r\n        };\r\n\r\n        $select.$isIE = function () {\r\n          var ua = $window.navigator.userAgent;\r\n          return ua.indexOf('MSIE ') > 0 || ua.indexOf('Trident/') > 0 || ua.indexOf('Edge/') > 0;\r\n        };\r\n\r\n        $select.$selectScrollFix = function (e) {\r\n          if ($document[0].activeElement.tagName === 'UL') {\r\n            e.preventDefault();\r\n            e.stopImmediatePropagation();\r\n            e.target.focus();\r\n          }\r\n        };\r\n\r\n        // Overrides\r\n\r\n        var _show = $select.show;\r\n        $select.show = function () {\r\n          _show();\r\n          if (options.multiple) {\r\n            $select.$element.addClass('select-multiple');\r\n          }\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed imediately.\r\n          $timeout(function () {\r\n            $select.$element.on(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\r\n            if (options.keyboard) {\r\n              element.on('keydown', $select.$onKeyDown);\r\n            }\r\n          }, 0, false);\r\n        };\r\n\r\n        var _hide = $select.hide;\r\n        $select.hide = function () {\r\n          if (!options.multiple && angular.isUndefined(controller.$modelValue)) {\r\n            scope.$activeIndex = -1;\r\n          }\r\n          $select.$element.off(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\r\n          if (options.keyboard) {\r\n            element.off('keydown', $select.$onKeyDown);\r\n          }\r\n          _hide(true);\r\n        };\r\n\r\n        return $select;\r\n\r\n      }\r\n\r\n      SelectFactory.defaults = defaults;\r\n      return SelectFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsSelect', function ($window, $parse, $q, $select, $parseOptions) {\r\n\r\n    var defaults = $select.defaults;\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        // Directive options\r\n        var options = {scope: scope, placeholder: defaults.placeholder};\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'placeholder', 'allNoneButtons', 'maxLength', 'maxLengthHtml', 'allText', 'noneText', 'iconCheckmark', 'autoClose', 'id', 'sort', 'caretHtml', 'prefixClass', 'prefixEvent', 'toggle'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container', 'allNoneButtons', 'sort'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\r\n            options[key] = false;\r\n          }\r\n        });\r\n\r\n        // bind functions from the attrs to the show, hide and select events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide', 'onSelect'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Only parse data-multiple. Angular sets existence attributes to true (multiple/required/etc), they apply this\r\n        // to data-multiple as well for some reason, so we'll parse this ourselves and disregard multiple\r\n        var dataMultiple = element.attr('data-multiple');\r\n        if (angular.isDefined(dataMultiple)) {\r\n          if (falseValueRegExp.test(dataMultiple)) {\r\n            options.multiple = false;\r\n          } else {\r\n            options.multiple = dataMultiple;\r\n          }\r\n        }\r\n\r\n        // Add support for select markup\r\n        if (element[0].nodeName.toLowerCase() === 'select') {\r\n          var inputEl = element;\r\n          inputEl.css('display', 'none');\r\n          element = angular.element('<button type=\"button\" class=\"btn btn-default\" aria-haspopup=\"true\"></button>');\r\n          inputEl.after(element);\r\n        }\r\n\r\n        // Build proper bsOptions\r\n        var parsedOptions = $parseOptions(attr.bsOptions);\r\n\r\n        // Initialize select\r\n        var select = $select(element, controller, options);\r\n\r\n        if (select.$isIE()) {\r\n          element[0].addEventListener('blur', select.$selectScrollFix);\r\n        }\r\n\r\n        // Watch bsOptions values before filtering for changes\r\n        var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').trim();\r\n        scope.$watch(watchedOptions, function (newValue, oldValue) {\r\n          // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\r\n          parsedOptions.valuesFn(scope, controller)\r\n          .then(function (values) {\r\n            select.update(values);\r\n            controller.$render();\r\n          });\r\n        }, true);\r\n\r\n        // Watch model for changes\r\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\r\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue);\r\n          select.$updateActiveIndex();\r\n          controller.$render();\r\n        }, true);\r\n\r\n        // Model rendering in view\r\n        controller.$render = function () {\r\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\r\n          var selected;\r\n          var index;\r\n          if (options.multiple && angular.isArray(controller.$modelValue)) {\r\n            selected = controller.$modelValue.map(function (value) {\r\n              index = select.$getIndex(value);\r\n              return index !== -1 ? select.$scope.$matches[index].label : false;\r\n            }).filter(angular.isDefined);\r\n            if (selected.length > (options.maxLength || defaults.maxLength)) {\r\n              selected = selected.length + ' ' + (options.maxLengthHtml || defaults.maxLengthHtml);\r\n            } else {\r\n              selected = selected.join(', ');\r\n            }\r\n          } else {\r\n            index = select.$getIndex(controller.$modelValue);\r\n            selected = index !== -1 ? select.$scope.$matches[index].label : false;\r\n          }\r\n          element.html((selected || options.placeholder) + (options.caretHtml || defaults.caretHtml));\r\n        };\r\n\r\n        if (options.multiple) {\r\n          controller.$isEmpty = function (value) {\r\n            return !value || value.length === 0;\r\n          };\r\n        }\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (select) select.destroy();\r\n          options = null;\r\n          select = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n\r\n// Source: scrollspy\\scrollspy.js\r\nangular.module('mgcrea.ngStrap.scrollspy', ['mgcrea.ngStrap.helpers.debounce', 'mgcrea.ngStrap.helpers.dimensions'])\r\n\r\n  .provider('$scrollspy', function () {\r\n\r\n    // Pool of registered spies\r\n    var spies = this.$$spies = {};\r\n\r\n    var defaults = this.defaults = {\r\n      debounce: 150,\r\n      throttle: 100,\r\n      offset: 100\r\n    };\r\n\r\n    this.$get = function ($window, $document, $rootScope, dimensions, debounce, throttle) {\r\n\r\n      var windowEl = angular.element($window);\r\n      var docEl = angular.element($document.prop('documentElement'));\r\n      var bodyEl = angular.element($window.document.body);\r\n\r\n      // Helper functions\r\n\r\n      function nodeName (element, name) {\r\n        return element[0].nodeName && element[0].nodeName.toLowerCase() === name.toLowerCase();\r\n      }\r\n\r\n      function ScrollSpyFactory (config) {\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n        if (!options.element) options.element = bodyEl;\r\n        var isWindowSpy = nodeName(options.element, 'body');\r\n        var scrollEl = isWindowSpy ? windowEl : options.element;\r\n        var scrollId = isWindowSpy ? 'window' : options.id;\r\n\r\n        // Use existing spy\r\n        if (spies[scrollId]) {\r\n          spies[scrollId].$$count++;\r\n          return spies[scrollId];\r\n        }\r\n\r\n        var $scrollspy = {};\r\n\r\n        // Private vars\r\n        var unbindViewContentLoaded;\r\n        var unbindIncludeContentLoaded;\r\n        var trackedElements = $scrollspy.$trackedElements = [];\r\n        var sortedElements = [];\r\n        var activeTarget;\r\n        var debouncedCheckPosition;\r\n        var throttledCheckPosition;\r\n        var debouncedCheckOffsets;\r\n        /* eslint-disable no-unused-vars */\r\n        var viewportHeight;\r\n        /* eslint-enable no-unused-vars */\r\n        var scrollTop;\r\n\r\n        $scrollspy.init = function () {\r\n\r\n          // Setup internal ref counter\r\n          this.$$count = 1;\r\n\r\n          // Bind events\r\n          debouncedCheckPosition = debounce(this.checkPosition, options.debounce);\r\n          throttledCheckPosition = throttle(this.checkPosition, options.throttle);\r\n          scrollEl.on('click', this.checkPositionWithEventLoop);\r\n          windowEl.on('resize', debouncedCheckPosition);\r\n          scrollEl.on('scroll', throttledCheckPosition);\r\n\r\n          debouncedCheckOffsets = debounce(this.checkOffsets, options.debounce);\r\n          unbindViewContentLoaded = $rootScope.$on('$viewContentLoaded', debouncedCheckOffsets);\r\n          unbindIncludeContentLoaded = $rootScope.$on('$includeContentLoaded', debouncedCheckOffsets);\r\n          debouncedCheckOffsets();\r\n\r\n          // Register spy for reuse\r\n          if (scrollId) {\r\n            spies[scrollId] = $scrollspy;\r\n          }\r\n\r\n        };\r\n\r\n        $scrollspy.destroy = function () {\r\n\r\n          // Check internal ref counter\r\n          this.$$count--;\r\n          if (this.$$count > 0) {\r\n            return;\r\n          }\r\n\r\n          // Unbind events\r\n          scrollEl.off('click', this.checkPositionWithEventLoop);\r\n          windowEl.off('resize', debouncedCheckPosition);\r\n          scrollEl.off('scroll', throttledCheckPosition);\r\n          unbindViewContentLoaded();\r\n          unbindIncludeContentLoaded();\r\n          if (scrollId) {\r\n            delete spies[scrollId];\r\n          }\r\n        };\r\n\r\n        $scrollspy.checkPosition = function () {\r\n\r\n          // Not ready yet\r\n          if (!sortedElements.length) return;\r\n\r\n          // Calculate the scroll position\r\n          scrollTop = (isWindowSpy ? $window.pageYOffset : scrollEl.prop('scrollTop')) || 0;\r\n\r\n          // Calculate the viewport height for use by the components\r\n          viewportHeight = Math.max($window.innerHeight, docEl.prop('clientHeight'));\r\n\r\n          // Activate first element if scroll is smaller\r\n          if (scrollTop < sortedElements[0].offsetTop && activeTarget !== sortedElements[0].target) {\r\n            return $scrollspy.$activateElement(sortedElements[0]);\r\n          }\r\n\r\n          // Activate proper element\r\n          for (var i = sortedElements.length; i--;) {\r\n            if (angular.isUndefined(sortedElements[i].offsetTop) || sortedElements[i].offsetTop === null) continue;\r\n            if (activeTarget === sortedElements[i].target) continue;\r\n            if (scrollTop < sortedElements[i].offsetTop) continue;\r\n            if (sortedElements[i + 1] && scrollTop > sortedElements[i + 1].offsetTop) continue;\r\n            return $scrollspy.$activateElement(sortedElements[i]);\r\n          }\r\n\r\n        };\r\n\r\n        $scrollspy.checkPositionWithEventLoop = function () {\r\n          // IE 9 throws an error if we use 'this' instead of '$scrollspy'\r\n          // in this setTimeout call\r\n          setTimeout($scrollspy.checkPosition, 1);\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $scrollspy.$activateElement = function (element) {\r\n          if (activeTarget) {\r\n            var activeElement = $scrollspy.$getTrackedElement(activeTarget);\r\n            if (activeElement) {\r\n              activeElement.source.removeClass('active');\r\n              if (nodeName(activeElement.source, 'li') && nodeName(activeElement.source.parent().parent(), 'li')) {\r\n                activeElement.source.parent().parent().removeClass('active');\r\n              }\r\n            }\r\n          }\r\n          activeTarget = element.target;\r\n          element.source.addClass('active');\r\n          if (nodeName(element.source, 'li') && nodeName(element.source.parent().parent(), 'li')) {\r\n            element.source.parent().parent().addClass('active');\r\n          }\r\n        };\r\n\r\n        $scrollspy.$getTrackedElement = function (target) {\r\n          return trackedElements.filter(function (obj) {\r\n            return obj.target === target;\r\n          })[0];\r\n        };\r\n\r\n        // Track offsets behavior\r\n\r\n        $scrollspy.checkOffsets = function () {\r\n\r\n          angular.forEach(trackedElements, function (trackedElement) {\r\n            var targetElement = document.querySelector(trackedElement.target);\r\n            trackedElement.offsetTop = targetElement ? dimensions.offset(targetElement).top : null;\r\n            if (options.offset && trackedElement.offsetTop !== null) trackedElement.offsetTop -= options.offset * 1;\r\n          });\r\n\r\n          sortedElements = trackedElements\r\n          .filter(function (el) {\r\n            return el.offsetTop !== null;\r\n          })\r\n          .sort(function (a, b) {\r\n            return a.offsetTop - b.offsetTop;\r\n          });\r\n\r\n          debouncedCheckPosition();\r\n\r\n        };\r\n\r\n        $scrollspy.trackElement = function (target, source) {\r\n          trackedElements.push({target: target, source: source});\r\n        };\r\n\r\n        $scrollspy.untrackElement = function (target, source) {\r\n          var toDelete;\r\n          for (var i = trackedElements.length; i--;) {\r\n            if (trackedElements[i].target === target && trackedElements[i].source === source) {\r\n              toDelete = i;\r\n              break;\r\n            }\r\n          }\r\n          trackedElements.splice(toDelete, 1);\r\n        };\r\n\r\n        $scrollspy.activate = function (i) {\r\n          trackedElements[i].addClass('active');\r\n        };\r\n\r\n        // Initialize plugin\r\n\r\n        $scrollspy.init();\r\n        return $scrollspy;\r\n\r\n      }\r\n\r\n      return ScrollSpyFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsScrollspy', function ($rootScope, debounce, dimensions, $scrollspy) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      link: function postLink (scope, element, attr) {\r\n\r\n        var options = {scope: scope};\r\n        angular.forEach(['offset', 'target'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        var scrollspy = $scrollspy(options);\r\n        scrollspy.trackElement(options.target, element);\r\n\r\n        scope.$on('$destroy', function () {\r\n          if (scrollspy) {\r\n            scrollspy.untrackElement(options.target, element);\r\n            scrollspy.destroy();\r\n          }\r\n          options = null;\r\n          scrollspy = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n\r\n  .directive('bsScrollspyList', function ($rootScope, debounce, dimensions, $scrollspy) {\r\n\r\n    return {\r\n      restrict: 'A',\r\n      compile: function postLink (element, attr) {\r\n        var children = element[0].querySelectorAll('li > a[href]');\r\n        angular.forEach(children, function (child) {\r\n          var childEl = angular.element(child);\r\n          childEl.parent().attr('bs-scrollspy', '').attr('data-target', childEl.attr('href'));\r\n        });\r\n      }\r\n\r\n    };\r\n\r\n  });\r\n\r\n// Source: popover\\popover.js\r\nangular.module('mgcrea.ngStrap.popover', ['mgcrea.ngStrap.tooltip'])\r\n\r\n  .provider('$popover', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      customClass: '',\r\n      // uncommenting the next two lines will break backwards compatability\r\n      // prefixClass: 'popover',\r\n      // prefixEvent: 'popover',\r\n      container: false,\r\n      target: false,\r\n      placement: 'right',\r\n      templateUrl: 'popover/popover.tpl.html',\r\n      contentTemplate: false,\r\n      trigger: 'click',\r\n      keyboard: true,\r\n      html: false,\r\n      title: '',\r\n      content: '',\r\n      delay: 0,\r\n      autoClose: false\r\n    };\r\n\r\n    this.$get = function ($tooltip) {\r\n\r\n      function PopoverFactory (element, config) {\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n\r\n        var $popover = $tooltip(element, options);\r\n\r\n        // Support scope as string options [/*title, */content]\r\n        if (options.content) {\r\n          $popover.$scope.content = options.content;\r\n        }\r\n\r\n        return $popover;\r\n\r\n      }\r\n\r\n      return PopoverFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsPopover', function ($window, $sce, $popover) {\r\n\r\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink (scope, element, attr) {\r\n\r\n        var popover;\r\n        // Directive options\r\n        var options = {scope: scope};\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'customClass', 'autoClose', 'id', 'prefixClass', 'prefixEvent', 'bsEnabled'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container', 'autoClose'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // should not parse target attribute (anchor tag), only data-target #1454\r\n        var dataTarget = element.attr('data-target');\r\n        if (angular.isDefined(dataTarget)) {\r\n          if (falseValueRegExp.test(dataTarget)) {\r\n            options.target = false;\r\n          } else {\r\n            options.target = dataTarget;\r\n          }\r\n        }\r\n\r\n        // Support scope as data-attrs\r\n        angular.forEach(['title', 'content'], function (key) {\r\n          if (attr[key]) {\r\n            attr.$observe(key, function (newValue, oldValue) {\r\n              scope[key] = $sce.trustAsHtml(newValue);\r\n              if (angular.isDefined(oldValue)) {\r\n                requestAnimationFrame(function () {\r\n                  if (popover) popover.$applyPlacement();\r\n                });\r\n              }\r\n            });\r\n          }\r\n        });\r\n\r\n        // Support scope as an object\r\n        if (attr.bsPopover) {\r\n          scope.$watch(attr.bsPopover, function (newValue, oldValue) {\r\n            if (angular.isObject(newValue)) {\r\n              angular.extend(scope, newValue);\r\n            } else {\r\n              scope.content = newValue;\r\n            }\r\n            if (angular.isDefined(oldValue)) {\r\n              requestAnimationFrame(function () {\r\n                if (popover) popover.$applyPlacement();\r\n              });\r\n            }\r\n          }, true);\r\n        }\r\n\r\n        // Visibility binding support\r\n        if (attr.bsShow) {\r\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\r\n            if (!popover || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(popover),?/i);\r\n            if (newValue === true) {\r\n              popover.show();\r\n            } else {\r\n              popover.hide();\r\n            }\r\n          });\r\n        }\r\n\r\n        // Enabled binding support\r\n        if (attr.bsEnabled) {\r\n          scope.$watch(attr.bsEnabled, function (newValue) {\r\n            if (!popover || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(popover),?/i);\r\n            if (newValue === false) {\r\n              popover.setEnabled(false);\r\n            } else {\r\n              popover.setEnabled(true);\r\n            }\r\n          });\r\n        }\r\n\r\n        // Viewport support\r\n        if (attr.viewport) {\r\n          scope.$watch(attr.viewport, function (newValue) {\r\n            if (!popover || !angular.isDefined(newValue)) return;\r\n            popover.setViewport(newValue);\r\n          });\r\n        }\r\n\r\n        // Initialize popover\r\n        popover = $popover(element, options);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (popover) popover.destroy();\r\n          options = null;\r\n          popover = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n\r\n// Source: navbar\\navbar.js\r\nangular.module('mgcrea.ngStrap.navbar', [])\r\n\r\n  .provider('$navbar', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      activeClass: 'active',\r\n      routeAttr: 'data-match-route',\r\n      strict: false\r\n    };\r\n\r\n    this.$get = function () {\r\n      return {defaults: defaults};\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsNavbar', function ($window, $location, $navbar) {\r\n\r\n    var defaults = $navbar.defaults;\r\n\r\n    return {\r\n      restrict: 'A',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        // Directive options\r\n        var options = angular.copy(defaults);\r\n        angular.forEach(Object.keys(defaults), function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // Watch for the $location\r\n        scope.$watch(function () {\r\n\r\n          return $location.path();\r\n\r\n        }, function (newValue, oldValue) {\r\n\r\n          var liElements = element[0].querySelectorAll('li[' + options.routeAttr + ']');\r\n\r\n          angular.forEach(liElements, function (li) {\r\n\r\n            var liElement = angular.element(li);\r\n            var pattern = liElement.attr(options.routeAttr).replace('/', '\\\\/');\r\n            if (options.strict) {\r\n              pattern = '^' + pattern + '$';\r\n            }\r\n            var regexp = new RegExp(pattern, 'i');\r\n\r\n            if (regexp.test(newValue)) {\r\n              liElement.addClass(options.activeClass);\r\n            } else {\r\n              liElement.removeClass(options.activeClass);\r\n            }\r\n\r\n          });\r\n\r\n        });\r\n\r\n      }\r\n\r\n    };\r\n\r\n  });\r\n\r\n// Source: modal\\modal.js\r\nangular.module('mgcrea.ngStrap.modal', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\r\n\r\n  .provider('$modal', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      backdropAnimation: 'am-fade',\r\n      customClass: '',\r\n      prefixClass: 'modal',\r\n      prefixEvent: 'modal',\r\n      placement: 'top',\r\n      templateUrl: 'modal/modal.tpl.html',\r\n      template: '',\r\n      contentTemplate: false,\r\n      container: false,\r\n      element: null,\r\n      backdrop: true,\r\n      keyboard: true,\r\n      html: false,\r\n      show: true,\r\n      size: null,\r\n      zIndex: null,\r\n      containerElement: null\r\n    };\r\n\r\n    this.$get = function ($window, $rootScope, $bsCompiler, $animate, $timeout, $sce, dimensions) {\r\n\r\n      var forEach = angular.forEach;\r\n      var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\r\n      var bodyElement = angular.element($window.document.body);\r\n\r\n      var layoutHideElement = angular.element('#layoutContainer');\r\n\r\n      var backdropCount = 0;\r\n      var dialogBaseZindex = 1050;\r\n      var backdropBaseZindex = 1040;\r\n\r\n      var validSizes = {\r\n        lg: 'modal-lg',\r\n        sm: 'modal-sm'\r\n      };\r\n\r\n      function ModalFactory (config) {\r\n\r\n        var $modal = {};\r\n\r\n        // Common vars\r\n        var options = $modal.$options = angular.extend({}, defaults, config);\r\n\r\n        var promise = $modal.$promise = $bsCompiler.compile(options);\r\n        var scope = $modal.$scope = options.scope && options.scope.$new() || $rootScope.$new();\r\n\r\n        if (options.containerElement) {\r\n          layoutHideElement = angular.element(options.containerElement);\r\n        }\r\n        if (!options.element && !options.container) {\r\n          options.container = 'body';\r\n        }\r\n\r\n        if (options.zIndex) {\r\n          dialogBaseZindex = parseInt(options.zIndex, 10);\r\n          backdropBaseZindex = dialogBaseZindex - 10;\r\n        }\r\n\r\n        // Store $id to identify the triggering element in events\r\n        // give priority to options.id, otherwise, try to use\r\n        // element id if defined\r\n        $modal.$id = options.id || options.element && options.element.attr('id') || '';\r\n\r\n        $modal.returnFocus = function () {\r\n\r\n        };\r\n\r\n        // Support scope as string options\r\n        forEach(['title', 'content'], function (key) {\r\n          if (options[key]) scope[key] = $sce.trustAsHtml(options[key]);\r\n        });\r\n\r\n        // Provide scope helpers\r\n        scope.$hide = function () {\r\n          scope.$$postDigest(function () {\r\n            $modal.hide();\r\n          });\r\n        };\r\n        scope.$show = function () {\r\n          scope.$$postDigest(function () {\r\n            $modal.show();\r\n          });\r\n        };\r\n        scope.$toggle = function () {\r\n          scope.$$postDigest(function () {\r\n            $modal.toggle();\r\n          });\r\n        };\r\n        // Publish isShown as a protected var on scope\r\n        $modal.$isShown = scope.$isShown = false;\r\n\r\n        // Fetch, compile then initialize modal\r\n        var compileData;\r\n        var modalElement;\r\n        var modalScope;\r\n        var backdropElement = angular.element('<div class=\"' + options.prefixClass + '-backdrop\"/>');\r\n        backdropElement.css({\r\n          position: 'fixed',\r\n          top: '0px',\r\n          left: '0px',\r\n          bottom: '0px',\r\n          right: '0px'\r\n        });\r\n        promise.then(function (data) {\r\n          compileData = data;\r\n          $modal.init();\r\n        });\r\n\r\n        $modal.init = function () {\r\n\r\n          // Options: show\r\n          if (options.show) {\r\n            scope.$$postDigest(function () {\r\n              $modal.show();\r\n            });\r\n          }\r\n\r\n        };\r\n\r\n        $modal.destroy = function () {\r\n\r\n          // Remove element\r\n          destroyModalElement();\r\n\r\n          // remove backdrop element\r\n          if (backdropElement) {\r\n            backdropElement.remove();\r\n            backdropElement = null;\r\n          }\r\n\r\n          // Destroy scope\r\n          scope.$destroy();\r\n        };\r\n\r\n        $modal.show = function () {\r\n          if ($modal.$isShown) return;\r\n\r\n          var parent;\r\n          var after;\r\n          if (angular.isElement(options.container)) {\r\n            parent = options.container;\r\n            after = options.container[0].lastChild ? angular.element(options.container[0].lastChild) : null;\r\n          } else {\r\n            if (options.container) {\r\n              parent = findElement(options.container);\r\n              after = parent[0] && parent[0].lastChild ? angular.element(parent[0].lastChild) : null;\r\n            } else {\r\n              parent = null;\r\n              after = options.element;\r\n            }\r\n          }\r\n\r\n          // destroy any existing modal elements\r\n          if (modalElement) destroyModalElement();\r\n\r\n          // create a new scope, so we can destroy it and all child scopes\r\n          // when destroying the modal element\r\n          modalScope = $modal.$scope.$new();\r\n          // Fetch a cloned element linked from template (noop callback is required)\r\n          modalElement = $modal.$element = compileData.link(modalScope, function (clonedElement, scope) {});\r\n\r\n          if (options.backdrop) {\r\n            // set z-index\r\n            modalElement.css({\r\n              'z-index': dialogBaseZindex + (backdropCount * 20)\r\n            });\r\n            backdropElement.css({\r\n              'z-index': backdropBaseZindex + (backdropCount * 20)\r\n            });\r\n\r\n            // increment number of backdrops\r\n            backdropCount++;\r\n          }\r\n\r\n          if (scope.$emit(options.prefixEvent + '.show.before', $modal).defaultPrevented) {\r\n            return;\r\n          }\r\n          if (angular.isDefined(options.onBeforeShow) && angular.isFunction(options.onBeforeShow)) {\r\n            options.onBeforeShow($modal);\r\n          }\r\n\r\n          // Set the initial positioning.\r\n          modalElement.css({\r\n            display: 'block'\r\n          }).addClass(options.placement);\r\n\r\n          // Options: customClass\r\n          if (options.customClass) {\r\n            modalElement.addClass(options.customClass);\r\n          }\r\n\r\n          // Options: size\r\n          if (options.size && validSizes[options.size]) {\r\n            angular.element(findElement('.modal-dialog', modalElement[0])).addClass(validSizes[options.size]);\r\n          }\r\n\r\n          // Options: animation\r\n          if (options.animation) {\r\n            if (options.backdrop) {\r\n              backdropElement.addClass(options.backdropAnimation);\r\n            }\r\n            modalElement.addClass(options.animation);\r\n          }\r\n\r\n          if (options.backdrop) {\r\n            $animate.enter(backdropElement, bodyElement, null);\r\n          }\r\n\r\n          // Support v1.2+ $animate\r\n          // https://github.com/angular/angular.js/issues/11713\r\n          if (angular.version.minor <= 2) {\r\n            $animate.enter(modalElement, parent, after, enterAnimateCallback);\r\n          } else {\r\n            $animate.enter(modalElement, parent, after).then(enterAnimateCallback);\r\n          }\r\n\r\n          $modal.$isShown = scope.$isShown = true;\r\n          safeDigest(scope);\r\n          // Focus once the enter-animation has started\r\n          // Weird PhantomJS bug hack\r\n          var el = modalElement[0];\r\n          requestAnimationFrame(function () {\r\n            el.focus();\r\n          });\r\n\r\n          bodyElement.addClass(options.prefixClass + '-open');\r\n\r\n          layoutHideElement.attr('aria-hidden', 'true');\r\n\r\n          if (options.animation) {\r\n            bodyElement.addClass(options.prefixClass + '-with-' + options.animation);\r\n          }\r\n\r\n          // Bind events\r\n          bindBackdropEvents();\r\n          bindKeyboardEvents();\r\n        };\r\n\r\n        function enterAnimateCallback () {\r\n          scope.$emit(options.prefixEvent + '.show', $modal);\r\n          if (angular.isDefined(options.onShow) && angular.isFunction(options.onShow)) {\r\n            options.onShow($modal);\r\n          }\r\n\r\n          modalElement.attr('aria-hidden', 'false');\r\n\r\n          var focusableElement = angular.element(findElement('.modal'));\r\n\r\n          if (focusableElement.length > 0) {\r\n            focusableElement.attr('tabindex', '0');\r\n            setTimeout(function () {\r\n              focusableElement.focus();\r\n            }, 500);\r\n          }\r\n        }\r\n\r\n        $modal.hide = function () {\r\n          if (!$modal.$isShown) return;\r\n\r\n          if (scope.$emit(options.prefixEvent + '.hide.before', $modal).defaultPrevented) {\r\n            return;\r\n          }\r\n          if (angular.isDefined(options.onBeforeHide) && angular.isFunction(options.onBeforeHide)) {\r\n            options.onBeforeHide($modal);\r\n          }\r\n\r\n          modalElement.attr('aria-hidden', 'true');\r\n\r\n          if ($modal.returnFocus && typeof $modal.returnFocus === 'function') $modal.returnFocus();\r\n\r\n          // Support v1.2+ $animate\r\n          // https://github.com/angular/angular.js/issues/11713\r\n          if (angular.version.minor <= 2) {\r\n            $animate.leave(modalElement, leaveAnimateCallback);\r\n          } else {\r\n            $animate.leave(modalElement).then(leaveAnimateCallback);\r\n          }\r\n\r\n          if (options.backdrop) {\r\n            // decrement number of backdrops\r\n            backdropCount--;\r\n            $animate.leave(backdropElement);\r\n          }\r\n          $modal.$isShown = scope.$isShown = false;\r\n          safeDigest(scope);\r\n\r\n          // Unbind events\r\n          unbindBackdropEvents();\r\n          unbindKeyboardEvents();\r\n        };\r\n\r\n        function leaveAnimateCallback () {\r\n          scope.$emit(options.prefixEvent + '.hide', $modal);\r\n          if (angular.isDefined(options.onHide) && angular.isFunction(options.onHide)) {\r\n            options.onHide($modal);\r\n          }\r\n          if (findElement('.modal').length <= 0) {\r\n            bodyElement.removeClass(options.prefixClass + '-open');\r\n            layoutHideElement.attr('aria-hidden', 'false');\r\n          }\r\n          if (options.animation) {\r\n            bodyElement.removeClass(options.prefixClass + '-with-' + options.animation);\r\n          }\r\n        }\r\n\r\n        function findFocusableElements () {\r\n          // Add all elements we want to include in our selection\r\n          var focusableElements = 'a:not([disabled]), button:not([disabled]), input:not([disabled]), [tabindex]:not([disabled]):not([tabindex=\"-1\"])';\r\n          if (document.activeElement) {\r\n            var focusable = Array.prototype.filter.call(modalElement[0].querySelectorAll(focusableElements),\r\n              function (element) {\r\n                // Check for visibility while always include the current activeElement\r\n                return element.offsetWidth > 0 || element.offsetHeight > 0 || element === document.activeElement;\r\n              });\r\n\r\n            return focusable;\r\n          }\r\n        }\r\n\r\n        function findNextFocusableElement (inReverse) {\r\n          if (document.activeElement) {\r\n            var focusable = findFocusableElements();\r\n            if (focusable === undefined) return;\r\n            if (inReverse) {\r\n              focusable = Array.prototype.reverse.call(focusable);\r\n            }\r\n\r\n            var index = focusable.indexOf(document.activeElement);\r\n            return focusable[index + 1];\r\n          }\r\n        }\r\n\r\n        $modal.toggle = function () {\r\n          if ($modal.$isShown) {\r\n            $modal.hide();\r\n          } else {\r\n            $modal.show();\r\n          }\r\n        };\r\n\r\n        $modal.focus = function () {\r\n          modalElement[0].focus();\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $modal.$onKeyUp = function (evt) {\r\n\r\n          // Escape was pressed on an open modal. Hide it.  Backspace key, nothing happen.\r\n          if ((evt.which === 8||evt.which === 27) && $modal.$isShown) {\r\n            if (evt.which === 27) {\r\n               $modal.hide();\r\n            }\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        $modal.$onKeyDown = function (evt) {\r\n          if (options.keyboard) {\r\n            if (evt.keyCode === 8 && evt.target.tagName!=='TEXTAREA' && evt.target.tagName!=='INPUT') {\r\n                evt.preventDefault();\r\n            }\t\t\t\t\r\n\t\t\t  \r\n            if (evt.keyCode === 9) {\r\n\r\n              var nextFocusable = findNextFocusableElement(evt.shiftKey);\r\n              if (nextFocusable === undefined) {\r\n                if (evt.preventDefault) evt.preventDefault();\r\n                if (evt.stopPropagation) evt.stopPropagation();\r\n\r\n                var focusable = findFocusableElements();\r\n                if (evt.shiftKey) {\r\n                  focusable[focusable.length - 1].focus();\r\n                } else {\r\n                  focusable[0].focus();\r\n                }\r\n              }\r\n            }\r\n          }\r\n        };\r\n\r\n        function bindBackdropEvents () {\r\n          if (options.backdrop) {\r\n            modalElement.on('click', hideOnBackdropClick);\r\n            backdropElement.on('click', hideOnBackdropClick);\r\n            backdropElement.on('wheel', preventEventDefault);\r\n          }\r\n        }\r\n\r\n        function unbindBackdropEvents () {\r\n          if (options.backdrop) {\r\n            modalElement.off('click', hideOnBackdropClick);\r\n            backdropElement.off('click', hideOnBackdropClick);\r\n            backdropElement.off('wheel', preventEventDefault);\r\n          }\r\n        }\r\n\r\n        function bindKeyboardEvents () {\r\n          if (options.keyboard) {\r\n            modalElement.on('keyup', $modal.$onKeyUp);\r\n            modalElement.on('keydown', $modal.$onKeyDown);\r\n          }\r\n        }\r\n\r\n        function unbindKeyboardEvents () {\r\n          if (options.keyboard) {\r\n            modalElement.off('keyup', $modal.$onKeyUp);\r\n            modalElement.off('keydown', $modal.$onKeyDown);\r\n          }\r\n        }\r\n\r\n        // Private helpers\r\n\r\n        function hideOnBackdropClick (evt) {\r\n          if (evt.target !== evt.currentTarget) return;\r\n          if (options.backdrop === 'static') {\r\n            $modal.focus();\r\n          } else {\r\n            $modal.hide();\r\n          }\r\n        }\r\n\r\n        function preventEventDefault (evt) {\r\n          evt.preventDefault();\r\n        }\r\n\r\n        function destroyModalElement () {\r\n          if ($modal.$isShown && modalElement !== null) {\r\n            // un-bind events\r\n            unbindBackdropEvents();\r\n            unbindKeyboardEvents();\r\n          }\r\n\r\n          if (modalScope) {\r\n            modalScope.$destroy();\r\n            modalScope = null;\r\n          }\r\n\r\n          if (modalElement) {\r\n            modalElement.remove();\r\n            modalElement = $modal.$element = null;\r\n          }\r\n        }\r\n\r\n        return $modal;\r\n\r\n      }\r\n\r\n      // Helper functions\r\n\r\n      function safeDigest (scope) {\r\n        /* eslint-disable no-unused-expressions */\r\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\r\n        /* eslint-enable no-unused-expressions */\r\n      }\r\n\r\n      function findElement (query, element) {\r\n        return angular.element((element || document).querySelectorAll(query));\r\n      }\r\n\r\n      return ModalFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsModal', function ($window, $sce, $parse, $modal) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink (scope, element, attr, transclusion) {\r\n\r\n        // Directive options\r\n        var options = {\r\n          scope: scope,\r\n          element: element,\r\n          show: false\r\n        };\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation', 'backdropAnimation', 'id', 'prefixEvent', 'prefixClass', 'customClass', 'modalClass', 'size', 'zIndex'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // Options: alias modalClass to customClass\r\n        if (options.modalClass) {\r\n          options.customClass = options.modalClass;\r\n        }\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['backdrop', 'keyboard', 'html', 'container'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Support scope as data-attrs\r\n        angular.forEach(['title', 'content'], function (key) {\r\n          if (attr[key]) {\r\n            attr.$observe(key, function (newValue, oldValue) {\r\n              scope[key] = $sce.trustAsHtml(newValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Support scope as an object\r\n        if (attr.bsModal) {\r\n          scope.$watch(attr.bsModal, function (newValue, oldValue) {\r\n            if (angular.isObject(newValue)) {\r\n              angular.extend(scope, newValue);\r\n            } else {\r\n              scope.content = newValue;\r\n            }\r\n          }, true);\r\n        }\r\n\r\n        // Initialize modal\r\n        var modal = $modal(options);\r\n\r\n        if (options.keyboard) {\r\n          modal.returnFocus = function () {\r\n            element[0].focus();\r\n          };\r\n        }\r\n\r\n        // Trigger\r\n        element.on(attr.trigger || 'click', modal.toggle);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (modal) modal.destroy();\r\n          options = null;\r\n          modal = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n\r\n// Source: helpers\\raf.js\r\nif (angular.version.minor < 3 && angular.version.dot < 14) {\r\n  angular.module('ng')\r\n\r\n  .factory('$$rAF', function ($window, $timeout) {\r\n\r\n    var requestAnimationFrame = $window.requestAnimationFrame ||\r\n                                $window.webkitRequestAnimationFrame ||\r\n                                $window.mozRequestAnimationFrame;\r\n\r\n    var cancelAnimationFrame = $window.cancelAnimationFrame ||\r\n                               $window.webkitCancelAnimationFrame ||\r\n                               $window.mozCancelAnimationFrame ||\r\n                               $window.webkitCancelRequestAnimationFrame;\r\n\r\n    var rafSupported = !!requestAnimationFrame;\r\n    var raf = rafSupported ?\r\n      function (fn) {\r\n        var id = requestAnimationFrame(fn);\r\n        return function () {\r\n          cancelAnimationFrame(id);\r\n        };\r\n      } :\r\n      function (fn) {\r\n        var timer = $timeout(fn, 16.66, false); // 1000 / 60 = 16.666\r\n        return function () {\r\n          $timeout.cancel(timer);\r\n        };\r\n      };\r\n\r\n    raf.supported = rafSupported;\r\n\r\n    return raf;\r\n\r\n  });\r\n}\r\n\r\n// Source: helpers\\parse-options.js\r\nangular.module('mgcrea.ngStrap.helpers.parseOptions', [])\r\n\r\n  .provider('$parseOptions', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      regexp: /^\\s*(.*?)(?:\\s+as\\s+(.*?))?(?:\\s+group\\s+by\\s+(.*))?\\s+for\\s+(?:([\\$\\w][\\$\\w]*)|(?:\\(\\s*([\\$\\w][\\$\\w]*)\\s*,\\s*([\\$\\w][\\$\\w]*)\\s*\\)))\\s+in\\s+(.*?)(?:\\s+track\\s+by\\s+(.*?))?$/\r\n    };\r\n\r\n    this.$get = function ($parse, $q) {\r\n\r\n      function ParseOptionsFactory (attr, config) {\r\n\r\n        var $parseOptions = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n        $parseOptions.$values = [];\r\n\r\n        // Private vars\r\n        var match;\r\n        var displayFn;\r\n        var valueName;\r\n        /* eslint-disable no-unused-vars */\r\n        var keyName;\r\n        var groupByFn;\r\n        /* eslint-enable no-unused-vars */\r\n        var valueFn;\r\n        var valuesFn;\r\n\r\n        $parseOptions.init = function () {\r\n          $parseOptions.$match = match = attr.match(options.regexp);\r\n          displayFn = $parse(match[2] || match[1]);\r\n          valueName = match[4] || match[6];\r\n          keyName = match[5];\r\n          groupByFn = $parse(match[3] || '');\r\n          valueFn = $parse(match[2] ? match[1] : valueName);\r\n          valuesFn = $parse(match[7]);\r\n        };\r\n\r\n        $parseOptions.valuesFn = function (scope, controller) {\r\n          return $q.when(valuesFn(scope, controller))\r\n          .then(function (values) {\r\n            if (!angular.isArray(values)) {\r\n              values = [];\r\n            }\r\n            $parseOptions.$values = values.length ? parseValues(values, scope) : [];\r\n            return $parseOptions.$values;\r\n          });\r\n        };\r\n\r\n        $parseOptions.displayValue = function (modelValue) {\r\n          var scope = {};\r\n          scope[valueName] = modelValue;\r\n          return displayFn(scope);\r\n        };\r\n\r\n        // Private functions\r\n\r\n        function parseValues (values, scope) {\r\n          return values.map(function (match, index) {\r\n            var locals = {};\r\n            var label;\r\n            var value;\r\n            locals[valueName] = match;\r\n            label = displayFn(scope, locals);\r\n            value = valueFn(scope, locals);\r\n            return {label: label, value: value, index: index};\r\n          });\r\n        }\r\n\r\n        $parseOptions.init();\r\n        return $parseOptions;\r\n\r\n      }\r\n\r\n      return ParseOptionsFactory;\r\n\r\n    };\r\n\r\n  });\r\n\r\n// Source: helpers\\focus-out.js\r\nangular.module('mgcrea.ngStrap.helpers.ngFocusOut', [])\r\n  .directive('ngFocusOut', ['$parse', '$rootScope', function ($parse, $rootScope) {\r\n    return {\r\n      restrict: 'A',\r\n      compile: function ($element, attr) {\r\n        // NOTE:\r\n        // We expose the powerful `$event` object on the scope that provides access to the Window,\r\n        // etc. This is OK, because expressions are not sandboxed any more (and the expression\r\n        // sandbox was never meant to be a security feature anyway).\r\n        var fn = $parse(attr.ngFocusOut);\r\n\r\n        return function link (scope, element) {\r\n          function ngEventHandler (event) {\r\n            var callback = function () {\r\n              fn(scope, {\r\n                $event: event\r\n              });\r\n            };\r\n            if ($rootScope.$$phase) {\r\n              scope.$evalAsync(callback);\r\n            } else {\r\n              scope.$apply(callback);\r\n            }\r\n          }\r\n\r\n          // setup the handler\r\n          element.on('focusout', ngEventHandler);\r\n\r\n          scope.$on('$destroy', function () {\r\n            // tear down the handler\r\n            element.off('focusout', ngEventHandler);\r\n          });\r\n        };\r\n      }\r\n    };\r\n  }]);\r\n\r\n// Source: helpers\\focus-element.js\r\nangular.module('mgcrea.ngStrap.helpers.focusElement', [])\r\n  .directive('focusElement', ['$timeout', '$parse', function ($timeout, $parse) {\r\n    return {\r\n      link: function (scope, element, attrs) {\r\n        scope.$watch(attrs.focusElement, function (value) {\r\n          if (value === true) {\r\n            $timeout(function () {\r\n              element[0].focus();\r\n            });\r\n          }\r\n        });\r\n      }\r\n    };\r\n  }]);\r\n\r\n// Source: helpers\\dimensions.js\r\nangular.module('mgcrea.ngStrap.helpers.dimensions', [])\r\n\r\n  .factory('dimensions', function () {\r\n\r\n    var fn = {};\r\n\r\n    /**\r\n     * Test the element nodeName\r\n     * @param element\r\n     * @param name\r\n     */\r\n    var nodeName = fn.nodeName = function (element, name) {\r\n      return element.nodeName && element.nodeName.toLowerCase() === name.toLowerCase();\r\n    };\r\n\r\n    /**\r\n     * Returns the element computed style\r\n     * @param element\r\n     * @param prop\r\n     * @param extra\r\n     */\r\n    fn.css = function (element, prop, extra) {\r\n      var value;\r\n      if (element.currentStyle) { // IE\r\n        value = element.currentStyle[prop];\r\n      } else if (window.getComputedStyle) {\r\n        value = window.getComputedStyle(element)[prop];\r\n      } else {\r\n        value = element.style[prop];\r\n      }\r\n      return extra === true ? parseFloat(value) || 0 : value;\r\n    };\r\n\r\n    /**\r\n     * Provides read-only equivalent of jQuery's offset function:\r\n     * @required-by bootstrap-tooltip, bootstrap-affix\r\n     * @url http://api.jquery.com/offset/\r\n     * @param element\r\n     */\r\n    fn.offset = function (element) {\r\n      var boxRect = element.getBoundingClientRect();\r\n      var docElement = element.ownerDocument;\r\n      return {\r\n        width: boxRect.width || element.offsetWidth,\r\n        height: boxRect.height || element.offsetHeight,\r\n        top: boxRect.top + (window.pageYOffset || docElement.documentElement.scrollTop) - (docElement.documentElement.clientTop || 0),\r\n        left: boxRect.left + (window.pageXOffset || docElement.documentElement.scrollLeft) - (docElement.documentElement.clientLeft || 0)\r\n      };\r\n    };\r\n\r\n    /**\r\n     * Provides set equivalent of jQuery's offset function:\r\n     * @required-by bootstrap-tooltip\r\n     * @url http://api.jquery.com/offset/\r\n     * @param element\r\n     * @param options\r\n     * @param i\r\n     */\r\n    fn.setOffset = function (element, options, i) {\r\n      var curPosition;\r\n      var curLeft;\r\n      var curCSSTop;\r\n      var curTop;\r\n      var curOffset;\r\n      var curCSSLeft;\r\n      var calculatePosition;\r\n      var position = fn.css(element, 'position');\r\n      var curElem = angular.element(element);\r\n      var props = {};\r\n\r\n      // Set position first, in-case top/left are set even on static elem\r\n      if (position === 'static') {\r\n        element.style.position = 'relative';\r\n      }\r\n\r\n      curOffset = fn.offset(element);\r\n      curCSSTop = fn.css(element, 'top');\r\n      curCSSLeft = fn.css(element, 'left');\r\n      calculatePosition = (position === 'absolute' || position === 'fixed') &&\r\n                          (curCSSTop + curCSSLeft).indexOf('auto') > -1;\r\n\r\n      // Need to be able to calculate position if either\r\n      // top or left is auto and position is either absolute or fixed\r\n      if (calculatePosition) {\r\n        curPosition = fn.position(element);\r\n        curTop = curPosition.top;\r\n        curLeft = curPosition.left;\r\n      } else {\r\n        curTop = parseFloat(curCSSTop) || 0;\r\n        curLeft = parseFloat(curCSSLeft) || 0;\r\n      }\r\n\r\n      if (angular.isFunction(options)) {\r\n        options = options.call(element, i, curOffset);\r\n      }\r\n\r\n      if (options.top !== null) {\r\n        props.top = (options.top - curOffset.top) + curTop;\r\n      }\r\n      if (options.left !== null) {\r\n        props.left = (options.left - curOffset.left) + curLeft;\r\n      }\r\n\r\n      if ('using' in options) {\r\n        options.using.call(curElem, props);\r\n      } else {\r\n        curElem.css({\r\n          top: props.top + 'px',\r\n          left: props.left + 'px'\r\n        });\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Provides read-only equivalent of jQuery's position function\r\n     * @required-by bootstrap-tooltip, bootstrap-affix\r\n     * @url http://api.jquery.com/offset/\r\n     * @param element\r\n     */\r\n    fn.position = function (element) {\r\n\r\n      var offsetParentRect = {top: 0, left: 0};\r\n      var offsetParentEl;\r\n      var offset;\r\n\r\n      // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\r\n      if (fn.css(element, 'position') === 'fixed') {\r\n\r\n        // We assume that getBoundingClientRect is available when computed position is fixed\r\n        offset = element.getBoundingClientRect();\r\n\r\n      } else {\r\n\r\n        // Get *real* offsetParentEl\r\n        offsetParentEl = offsetParentElement(element);\r\n\r\n        // Get correct offsets\r\n        offset = fn.offset(element);\r\n        if (!nodeName(offsetParentEl, 'html')) {\r\n          offsetParentRect = fn.offset(offsetParentEl);\r\n        }\r\n\r\n        // Add offsetParent borders\r\n        offsetParentRect.top += fn.css(offsetParentEl, 'borderTopWidth', true);\r\n        offsetParentRect.left += fn.css(offsetParentEl, 'borderLeftWidth', true);\r\n      }\r\n\r\n      // Subtract parent offsets and element margins\r\n      return {\r\n        width: element.offsetWidth,\r\n        height: element.offsetHeight,\r\n        top: offset.top - offsetParentRect.top - fn.css(element, 'marginTop', true),\r\n        left: offset.left - offsetParentRect.left - fn.css(element, 'marginLeft', true)\r\n      };\r\n\r\n    };\r\n\r\n    /**\r\n     * Returns the closest, non-statically positioned offsetParent of a given element\r\n     * @required-by fn.position\r\n     * @param element\r\n     */\r\n    function offsetParentElement (element) {\r\n      var docElement = element.ownerDocument;\r\n      var offsetParent = element.offsetParent || docElement;\r\n      if (nodeName(offsetParent, '#document')) return docElement.documentElement;\r\n      while (offsetParent && !nodeName(offsetParent, 'html') && fn.css(offsetParent, 'position') === 'static') {\r\n        offsetParent = offsetParent.offsetParent;\r\n      }\r\n      return offsetParent || docElement.documentElement;\r\n    }\r\n\r\n    /**\r\n     * Provides equivalent of jQuery's height function\r\n     * @required-by bootstrap-affix\r\n     * @url http://api.jquery.com/height/\r\n     * @param element\r\n     * @param outer\r\n     */\r\n    fn.height = function (element, outer) {\r\n      var value = element.offsetHeight;\r\n      if (outer) {\r\n        value += fn.css(element, 'marginTop', true) + fn.css(element, 'marginBottom', true);\r\n      } else {\r\n        value -= fn.css(element, 'paddingTop', true) + fn.css(element, 'paddingBottom', true) + fn.css(element, 'borderTopWidth', true) + fn.css(element, 'borderBottomWidth', true);\r\n      }\r\n      return value;\r\n    };\r\n\r\n    /**\r\n     * Provides equivalent of jQuery's width function\r\n     * @required-by bootstrap-affix\r\n     * @url http://api.jquery.com/width/\r\n     * @param element\r\n     * @param outer\r\n     */\r\n    fn.width = function (element, outer) {\r\n      var value = element.offsetWidth;\r\n      if (outer) {\r\n        value += fn.css(element, 'marginLeft', true) + fn.css(element, 'marginRight', true);\r\n      } else {\r\n        value -= fn.css(element, 'paddingLeft', true) + fn.css(element, 'paddingRight', true) + fn.css(element, 'borderLeftWidth', true) + fn.css(element, 'borderRightWidth', true);\r\n      }\r\n      return value;\r\n    };\r\n\r\n    return fn;\r\n\r\n  });\r\n\r\n// Source: helpers\\debounce.js\r\nangular.module('mgcrea.ngStrap.helpers.debounce', [])\r\n\r\n// @source jashkenas/underscore\r\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L693\r\n.factory('debounce', function ($timeout) {\r\n  return function (func, wait, immediate) {\r\n    var timeout = null;\r\n    return function () {\r\n      var context = this;\r\n      var args = arguments;\r\n      var callNow = immediate && !timeout;\r\n      if (timeout) {\r\n        $timeout.cancel(timeout);\r\n      }\r\n      timeout = $timeout(function later () {\r\n        timeout = null;\r\n        if (!immediate) {\r\n          func.apply(context, args);\r\n        }\r\n      }, wait, false);\r\n      if (callNow) {\r\n        func.apply(context, args);\r\n      }\r\n      return timeout;\r\n    };\r\n  };\r\n})\r\n\r\n\r\n// @source jashkenas/underscore\r\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L661\r\n.factory('throttle', function ($timeout) {\r\n  return function (func, wait, options) {\r\n    var timeout = null;\r\n    if (!options) options = {};\r\n    return function () {\r\n      var context = this;\r\n      var args = arguments;\r\n      if (!timeout) {\r\n        if (options.leading !== false) {\r\n          func.apply(context, args);\r\n        }\r\n        timeout = $timeout(function later () {\r\n          timeout = null;\r\n          if (options.trailing !== false) {\r\n            func.apply(context, args);\r\n          }\r\n        }, wait, false);\r\n      }\r\n    };\r\n  };\r\n});\r\n\r\n// Source: helpers\\date-parser.js\r\nangular.module('mgcrea.ngStrap.helpers.dateParser', [])\r\n\r\n.provider('$dateParser', function ($localeProvider) {\r\n\r\n  // define a custom ParseDate object to use instead of native Date\r\n  // to avoid date values wrapping when setting date component values\r\n  function ParseDate () {\r\n    this.year = 1970;\r\n    this.month = 0;\r\n    this.day = 1;\r\n    this.hours = 0;\r\n    this.minutes = 0;\r\n    this.seconds = 0;\r\n    this.milliseconds = 0;\r\n  }\r\n\r\n  ParseDate.prototype.setMilliseconds = function (value) { this.milliseconds = value; };\r\n  ParseDate.prototype.setSeconds = function (value) { this.seconds = value; };\r\n  ParseDate.prototype.setMinutes = function (value) { this.minutes = value; };\r\n  ParseDate.prototype.setHours = function (value) { this.hours = value; };\r\n  ParseDate.prototype.getHours = function () { return this.hours; };\r\n  ParseDate.prototype.setDate = function (value) { this.day = value; };\r\n  ParseDate.prototype.setMonth = function (value) { this.month = value; };\r\n  ParseDate.prototype.setFullYear = function (value) { this.year = value; };\r\n  ParseDate.prototype.fromDate = function (value) {\r\n    this.year = value.getFullYear();\r\n    this.month = value.getMonth();\r\n    this.day = value.getDate();\r\n    this.hours = value.getHours();\r\n    this.minutes = value.getMinutes();\r\n    this.seconds = value.getSeconds();\r\n    this.milliseconds = value.getMilliseconds();\r\n    return this;\r\n  };\r\n\r\n  ParseDate.prototype.toDate = function () {\r\n    return new Date(this.year, this.month, this.day, this.hours, this.minutes, this.seconds, this.milliseconds);\r\n  };\r\n\r\n  var proto = ParseDate.prototype;\r\n\r\n  function noop () {\r\n  }\r\n\r\n  function isNumeric (n) {\r\n    return !isNaN(parseFloat(n)) && isFinite(n);\r\n  }\r\n\r\n  function indexOfCaseInsensitive (array, value) {\r\n    var len = array.length;\r\n    var str = value.toString().toLowerCase();\r\n    for (var i = 0; i < len; i++) {\r\n      if (array[i].toLowerCase() === str) { return i; }\r\n    }\r\n    return -1; // Return -1 per the \"Array.indexOf()\" method.\r\n  }\r\n\r\n  var defaults = this.defaults = {\r\n    format: 'shortDate',\r\n    strict: false\r\n  };\r\n\r\n  this.$get = function ($locale, dateFilter) {\r\n\r\n    var DateParserFactory = function (config) {\r\n\r\n      var options = angular.extend({}, defaults, config);\r\n\r\n      var $dateParser = {};\r\n\r\n      /* eslint-disable key-spacing, quote-props */\r\n      var regExpMap = {\r\n        'sss'   : '[0-9]{3}',\r\n        'ss'    : '[0-5][0-9]',\r\n        's'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\r\n        'mm'    : '[0-5][0-9]',\r\n        'm'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\r\n        'HH'    : '[01][0-9]|2[0-3]',\r\n        'H'     : options.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',\r\n        'hh'    : '[0][1-9]|[1][012]',\r\n        'h'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\r\n        'a'     : 'AM|PM',\r\n        'EEEE'  : $locale.DATETIME_FORMATS.DAY.join('|'),\r\n        'EEE'   : $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\r\n        'dd'    : '0[1-9]|[12][0-9]|3[01]',\r\n        'd'     : options.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',\r\n        'MMMM'  : $locale.DATETIME_FORMATS.MONTH.join('|'),\r\n        'MMM'   : $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\r\n        'MM'    : '0[1-9]|1[012]',\r\n        'M'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\r\n        'yyyy'  : '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',\r\n        'yy'    : '[0-9]{2}',\r\n        'y'     : options.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}'\r\n      };\r\n\r\n      var setFnMap = {\r\n        'sss'   : proto.setMilliseconds,\r\n        'ss'    : proto.setSeconds,\r\n        's'     : proto.setSeconds,\r\n        'mm'    : proto.setMinutes,\r\n        'm'     : proto.setMinutes,\r\n        'HH'    : proto.setHours,\r\n        'H'     : proto.setHours,\r\n        'hh'    : proto.setHours,\r\n        'h'     : proto.setHours,\r\n        'EEEE'  : noop,\r\n        'EEE'   : noop,\r\n        'dd'    : proto.setDate,\r\n        'd'     : proto.setDate,\r\n        'a'     : function (value) { var hours = this.getHours() % 12; return this.setHours(value.match(/pm/i) ? hours + 12 : hours); },\r\n        'MMMM'  : function (value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.MONTH, value)); },\r\n        'MMM'   : function (value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.SHORTMONTH, value)); },\r\n        'MM'    : function (value) { return this.setMonth(1 * value - 1); },\r\n        'M'     : function (value) { return this.setMonth(1 * value - 1); },\r\n        'yyyy'  : proto.setFullYear,\r\n        'yy'    : function (value) { return this.setFullYear(2000 + 1 * value); },\r\n        'y'     : function (value) { return (1 * value <= 50 && value.length === 2) ? this.setFullYear(2000 + 1 * value) : this.setFullYear(1 * value); }\r\n      };\r\n      /* eslint-enable key-spacing, quote-props */\r\n\r\n      var regex;\r\n      var setMap;\r\n\r\n      $dateParser.init = function () {\r\n        $dateParser.$format = $locale.DATETIME_FORMATS[options.format] || options.format;\r\n        regex = regExpForFormat($dateParser.$format);\r\n        setMap = setMapForFormat($dateParser.$format);\r\n      };\r\n\r\n      $dateParser.isValid = function (date) {\r\n        if (angular.isDate(date)) return !isNaN(date.getTime());\r\n        return regex.test(date);\r\n      };\r\n\r\n      $dateParser.parse = function (value, baseDate, format, timezone) {\r\n        // check for date format special names\r\n        if (format) format = $locale.DATETIME_FORMATS[format] || format;\r\n        if (angular.isDate(value)) value = dateFilter(value, format || $dateParser.$format, timezone);\r\n        var formatRegex = format ? regExpForFormat(format) : regex;\r\n        var formatSetMap = format ? setMapForFormat(format) : setMap;\r\n        var matches = formatRegex.exec(value);\r\n        if (!matches) return false;\r\n        // use custom ParseDate object to set parsed values\r\n        var date = baseDate && !isNaN(baseDate.getTime()) ? new ParseDate().fromDate(baseDate) : new ParseDate().fromDate(new Date(1970, 0, 1, 0));\r\n        for (var i = 0; i < matches.length - 1; i++) {\r\n          if (formatSetMap[i]) formatSetMap[i].call(date, matches[i + 1]);\r\n        }\r\n        // convert back to native Date object\r\n        var newDate = date.toDate();\r\n\r\n        // check new native Date object for day values overflow\r\n        if (parseInt(date.day, 10) !== newDate.getDate()) {\r\n          return false;\r\n        }\r\n\r\n        return newDate;\r\n      };\r\n\r\n      $dateParser.getDateForAttribute = function (key, value) {\r\n        var date;\r\n\r\n        if (value === 'today') {\r\n          var today = new Date();\r\n          date = new Date(today.getFullYear(), today.getMonth(), today.getDate() + (key === 'maxDate' ? 1 : 0), 0, 0, 0, (key === 'minDate' ? 0 : -1));\r\n        } else if (angular.isString(value) && value.match(/^\".+\"$/)) { // Support {{ dateObj }}\r\n          if (value.match(/Z/)) {\r\n            date = new Date(value.substr(1, value.length - 3));\r\n          } else {\r\n            date = new Date(value.substr(1, value.length - 2));\r\n          }\r\n        } else if (isNumeric(value)) {\r\n          date = new Date(parseInt(value, 10));\r\n        } else if (angular.isString(value) && value.length === 0) { // Reset date\r\n          date = key === 'minDate' ? -Infinity : +Infinity;\r\n        } else {\r\n          date = new Date(value);\r\n        }\r\n\r\n        return date;\r\n      };\r\n\r\n      $dateParser.getTimeForAttribute = function (key, value) {\r\n        var time;\r\n\r\n        if (value === 'now') {\r\n          time = new Date().setFullYear(1970, 0, 1);\r\n        } else if (angular.isString(value) && value.match(/^\".+\"$/)) {\r\n          time = new Date(value.substr(1, value.length - 2)).setFullYear(1970, 0, 1);\r\n        } else if (isNumeric(value)) {\r\n          time = new Date(parseInt(value, 10)).setFullYear(1970, 0, 1);\r\n        } else if (angular.isString(value) && value.length === 0) { // Reset time\r\n          time = key === 'minTime' ? -Infinity : +Infinity;\r\n        } else {\r\n          time = $dateParser.parse(value, new Date(1970, 0, 1, 0));\r\n        }\r\n\r\n        return time;\r\n      };\r\n\r\n      /* Handle switch to/from daylight saving.\r\n      * Hours may be non-zero on daylight saving cut-over:\r\n      * > 12 when midnight changeover, but then cannot generate\r\n      * midnight datetime, so jump to 1AM, otherwise reset.\r\n      * @param  date  (Date) the date to check\r\n      * @return  (Date) the corrected date\r\n      *\r\n      * __ copied from jquery ui datepicker __\r\n      */\r\n      $dateParser.daylightSavingAdjust = function (date) {\r\n        if (!date) {\r\n          return null;\r\n        }\r\n        date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);\r\n        return date;\r\n      };\r\n\r\n      /* Correct the date for timezone offset.\r\n      * @param  date  (Date) the date to adjust\r\n      * @param  timezone  (string) the timezone to adjust for\r\n      * @param  undo  (boolean) to add or subtract timezone offset\r\n      * @return  (Date) the corrected date\r\n      */\r\n      $dateParser.timezoneOffsetAdjust = function (date, timezone, undo) {\r\n        if (!date) {\r\n          return null;\r\n        }\r\n        // Right now, only 'UTC' is supported.\r\n        if (timezone && timezone === 'UTC') {\r\n          date = new Date(date.getTime());\r\n          date.setMinutes(date.getMinutes() + (undo ? -1 : 1) * date.getTimezoneOffset());\r\n        }\r\n        return date;\r\n      };\r\n\r\n      // Private functions\r\n\r\n      function regExpForFormat (format) {\r\n        // `format` string can contain literal values.\r\n        // These need to be escaped by surrounding with\r\n        // single quotes (e.g. `\"h 'in the morning'\"`).\r\n        // In order to output a single quote, escape it - i.e.,\r\n        // two single quotes in a sequence (e.g. `\"h 'o''clock'\"`).\r\n\r\n        var re = buildDateAbstractRegex(format);\r\n        return buildDateParseRegex(re);\r\n      }\r\n\r\n      function buildDateAbstractRegex (format) {\r\n        var escapedFormat = escapeReservedSymbols(format);\r\n        var escapedLiteralFormat = escapedFormat.replace(/''/g, '\\\\\\'');\r\n        var literalRegex = /('(?:\\\\'|.)*?')/;\r\n        var formatParts = escapedLiteralFormat.split(literalRegex);\r\n        var dateElements = Object.keys(regExpMap);\r\n        var dateRegexParts = [];\r\n\r\n        angular.forEach(formatParts, function (part) {\r\n          if (isFormatStringLiteral(part)) {\r\n            part = trimLiteralEscapeChars(part);\r\n          } else {\r\n            // Abstract replaces to avoid collisions\r\n            for (var i = 0; i < dateElements.length; i++) {\r\n              part = part.split(dateElements[i]).join('${' + i + '}');\r\n            }\r\n          }\r\n          dateRegexParts.push(part);\r\n        });\r\n\r\n        return dateRegexParts.join('');\r\n      }\r\n\r\n      function escapeReservedSymbols (text) {\r\n        return text.replace(/\\\\/g, '[\\\\\\\\]')\r\n                   .replace(/-/g, '[-]')\r\n                   .replace(/\\./g, '[.]')\r\n                   .replace(/\\*/g, '[*]')\r\n                   .replace(/\\+/g, '[+]')\r\n                   .replace(/\\?/g, '[?]')\r\n                   .replace(/\\$/g, '[$]')\r\n                   .replace(/\\^/g, '[^]')\r\n                   .replace(/\\//g, '[/]')\r\n                   .replace(/\\\\s/g, '[\\\\s]');\r\n      }\r\n\r\n      function isFormatStringLiteral (text) {\r\n        return /^'.*'$/.test(text);\r\n      }\r\n\r\n      function trimLiteralEscapeChars (text) {\r\n        return text.replace(/^'(.*)'$/, '$1');\r\n      }\r\n\r\n      function buildDateParseRegex (abstractRegex) {\r\n        var dateElements = Object.keys(regExpMap);\r\n        var re = abstractRegex;\r\n\r\n        // Replace abstracted values\r\n        for (var i = 0; i < dateElements.length; i++) {\r\n          re = re.split('${' + i + '}').join('(' + regExpMap[dateElements[i]] + ')');\r\n        }\r\n\r\n        return new RegExp('^' + re + '$', ['i']);\r\n      }\r\n\r\n      function setMapForFormat (format) {\r\n        var re = buildDateAbstractRegex(format);\r\n        return buildDateParseValuesMap(re);\r\n      }\r\n\r\n      function buildDateParseValuesMap (abstractRegex) {\r\n        var dateElements = Object.keys(regExpMap);\r\n        var valuesRegex = new RegExp('\\\\${(\\\\d+)}', 'g');\r\n        var valuesMatch;\r\n        var keyIndex;\r\n        var valueKey;\r\n        var valueFunction;\r\n        var valuesFunctionMap = [];\r\n\r\n        /* eslint-disable no-cond-assign */\r\n        while ((valuesMatch = valuesRegex.exec(abstractRegex)) !== null) {\r\n          keyIndex = valuesMatch[1];\r\n          valueKey = dateElements[keyIndex];\r\n          valueFunction = setFnMap[valueKey];\r\n\r\n          valuesFunctionMap.push(valueFunction);\r\n        }\r\n\r\n        return valuesFunctionMap;\r\n      }\r\n\r\n      $dateParser.init();\r\n      return $dateParser;\r\n\r\n    };\r\n\r\n    return DateParserFactory;\r\n\r\n  };\r\n\r\n});\r\n\r\n// Source: helpers\\date-formatter.js\r\nangular.module('mgcrea.ngStrap.helpers.dateFormatter', [])\r\n\r\n  .service('$dateFormatter', function ($locale, dateFilter) {\r\n\r\n    // The unused `lang` arguments are on purpose. The default implementation does not\r\n    // use them and it always uses the locale loaded into the `$locale` service.\r\n    // Custom implementations might use it, thus allowing different directives to\r\n    // have different languages.\r\n\r\n    this.getDefaultLocale = function () {\r\n      return $locale.id;\r\n    };\r\n\r\n    // Format is either a data format name, e.g. \"shortTime\" or \"fullDate\", or a date format\r\n    // Return either the corresponding date format or the given date format.\r\n    this.getDatetimeFormat = function (format, lang) {\r\n      return $locale.DATETIME_FORMATS[format] || format;\r\n    };\r\n\r\n    this.weekdaysShort = function (lang) {\r\n      return $locale.DATETIME_FORMATS.SHORTDAY;\r\n    };\r\n\r\n    this.weekdays = function (lang) {\r\n      return $locale.DATETIME_FORMATS.DAY;\r\n    };\r\n\r\n    function splitTimeFormat (format) {\r\n      return /(h+)([:\\.])?(m+)([:\\.])?(s*)[ ]?(a?)/i.exec(format).slice(1);\r\n    }\r\n\r\n    // h:mm a => h\r\n    this.hoursFormat = function (timeFormat) {\r\n      return splitTimeFormat(timeFormat)[0];\r\n    };\r\n\r\n    // h:mm a => mm\r\n    this.minutesFormat = function (timeFormat) {\r\n      return splitTimeFormat(timeFormat)[2];\r\n    };\r\n\r\n    // h:mm:ss a => ss\r\n    this.secondsFormat = function (timeFormat) {\r\n      return splitTimeFormat(timeFormat)[4];\r\n    };\r\n\r\n    // h:mm a => :\r\n    this.timeSeparator = function (timeFormat) {\r\n      return splitTimeFormat(timeFormat)[1];\r\n    };\r\n\r\n    // h:mm:ss a => true, h:mm a => false\r\n    this.showSeconds = function (timeFormat) {\r\n      return !!splitTimeFormat(timeFormat)[4];\r\n    };\r\n\r\n    // h:mm a => true, H.mm => false\r\n    this.showAM = function (timeFormat) {\r\n      return !!splitTimeFormat(timeFormat)[5];\r\n    };\r\n\r\n    this.formatDate = function (date, format, lang, timezone) {\r\n      return dateFilter(date, format, timezone);\r\n    };\r\n\r\n  });\r\n\r\n// Source: helpers\\compiler.js\r\n// NOTICE: This file was forked from the angular-material project (github.com/angular/material)\r\n// MIT Licensed - Copyright (c) 2014-2015 Google, Inc. http://angularjs.org\r\n\r\nangular.module('mgcrea.ngStrap.core', [])\r\n  .service('$bsCompiler', bsCompilerService);\r\n\r\nfunction bsCompilerService ($q, $http, $injector, $compile, $controller, $templateCache) {\r\n\r\n  /*\r\n   * @ngdoc service\r\n   * @name $bsCompiler\r\n   * @module material.core\r\n   * @description\r\n   * The $bsCompiler service is an abstraction of angular's compiler, that allows the developer\r\n   * to easily compile an element with a templateUrl, controller, and locals.\r\n   *\r\n   * @usage\r\n   * <hljs lang=\"js\">\r\n   * $bsCompiler.compile({\r\n   *   templateUrl: 'modal.html',\r\n   *   controller: 'ModalCtrl',\r\n   *   locals: {\r\n   *     modal: myModalInstance;\r\n   *   }\r\n   * }).then(function(compileData) {\r\n   *   compileData.element; // modal.html's template in an element\r\n   *   compileData.link(myScope); //attach controller & scope to element\r\n   * });\r\n   * </hljs>\r\n   */\r\n\r\n   /*\r\n    * @ngdoc method\r\n    * @name $bsCompiler#compile\r\n    * @description A helper to compile an HTML template/templateUrl with a given controller,\r\n    * locals, and scope.\r\n    * @param {object} options An options object, with the following properties:\r\n    *\r\n    *    - `controller` - `{(string=|function()=}` Controller fn that should be associated with\r\n    *      newly created scope or the name of a registered controller if passed as a string.\r\n    *    - `controllerAs` - `{string=}` A controller alias name. If present the controller will be\r\n    *      published to scope under the `controllerAs` name.\r\n    *    - `template` - `{string=}` An html template as a string.\r\n    *    - `templateUrl` - `{string=}` A path to an html template.\r\n    *    - `transformTemplate` - `{function(template)=}` A function which transforms the template after\r\n    *      it is loaded. It will be given the template string as a parameter, and should\r\n    *      return a a new string representing the transformed template.\r\n    *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should\r\n    *      be injected into the controller. If any of these dependencies are promises, the compiler\r\n    *      will wait for them all to be resolved, or if one is rejected before the controller is\r\n    *      instantiated `compile()` will fail..\r\n    *      * `key` - `{string}`: a name of a dependency to be injected into the controller.\r\n    *      * `factory` - `{string|function}`: If `string` then it is an alias for a service.\r\n    *        Otherwise if function, then it is injected and the return value is treated as the\r\n    *        dependency. If the result is a promise, it is resolved before its value is\r\n    *        injected into the controller.\r\n    *\r\n    * @returns {object=} promise A promise, which will be resolved with a `compileData` object.\r\n    * `compileData` has the following properties:\r\n    *\r\n    *   - `element` - `{element}`: an uncompiled element matching the provided template.\r\n    *   - `link` - `{function(scope)}`: A link function, which, when called, will compile\r\n    *     the element and instantiate the provided controller (if given).\r\n    *   - `locals` - `{object}`: The locals which will be passed into the controller once `link` is\r\n    *     called. If `bindToController` is true, they will be coppied to the ctrl instead\r\n    *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in.\r\n    */\r\n  this.compile = function (options) {\r\n\r\n    if (options.template && /\\.html$/.test(options.template)) {\r\n      console.warn('Deprecated use of `template` option to pass a file. Please use the `templateUrl` option instead.');\r\n      options.templateUrl = options.template;\r\n      options.template = '';\r\n    }\r\n\r\n    var templateUrl = options.templateUrl;\r\n    var template = options.template || '';\r\n    var controller = options.controller;\r\n    var controllerAs = options.controllerAs;\r\n    var resolve = options.resolve || {};\r\n    var locals = options.locals || {};\r\n    var transformTemplate = options.transformTemplate || angular.identity;\r\n    var bindToController = options.bindToController;\r\n\r\n    // Take resolve values and invoke them.\r\n    // Resolves can either be a string (value: 'MyRegisteredAngularConst'),\r\n    // or an invokable 'factory' of sorts: (value: function ValueGetter($dependency) {})\r\n    angular.forEach(resolve, function (value, key) {\r\n      if (angular.isString(value)) {\r\n        resolve[key] = $injector.get(value);\r\n      } else {\r\n        resolve[key] = $injector.invoke(value);\r\n      }\r\n    });\r\n    // Add the locals, which are just straight values to inject\r\n    // eg locals: { three: 3 }, will inject three into the controller\r\n    angular.extend(resolve, locals);\r\n\r\n    if (template) {\r\n      resolve.$template = $q.when(template);\r\n    } else if (templateUrl) {\r\n      resolve.$template = fetchTemplate(templateUrl);\r\n    } else {\r\n      throw new Error('Missing `template` / `templateUrl` option.');\r\n    }\r\n\r\n    if (options.titleTemplate) {\r\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.titleTemplate)])\r\n        .then(function (templates) {\r\n          var templateEl = angular.element(templates[0]);\r\n          findElement('[ng-bind=\"title\"]', templateEl[0])\r\n            .removeAttr('ng-bind')\r\n            .html(templates[1]);\r\n          return templateEl[0].outerHTML;\r\n        });\r\n    }\r\n\r\n    if (options.contentTemplate) {\r\n      // TODO(mgcrea): deprecate?\r\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.contentTemplate)])\r\n        .then(function (templates) {\r\n          var templateEl = angular.element(templates[0]);\r\n          var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0])\r\n            .removeAttr('ng-bind')\r\n            .html(templates[1]);\r\n          // Drop the default footer as you probably don't want it if you use a custom contentTemplate\r\n          if (!options.templateUrl) contentEl.next().remove();\r\n          return templateEl[0].outerHTML;\r\n        });\r\n    }\r\n\r\n    // Wait for all the resolves to finish if they are promises\r\n    return $q.all(resolve).then(function (locals) {\r\n\r\n      var template = transformTemplate(locals.$template);\r\n      if (options.html) {\r\n        template = template.replace(/ng-bind=\"/ig, 'ng-bind-html=\"');\r\n      }\r\n      // var element = options.element || angular.element('<div>').html(template.trim()).contents();\r\n      var element = angular.element('<div>').html(template.trim()).contents();\r\n      var linkFn = $compile(element);\r\n\r\n      // Return a linking function that can be used later when the element is ready\r\n      return {\r\n        locals: locals,\r\n        element: element,\r\n        link: function link (scope) {\r\n          locals.$scope = scope;\r\n\r\n          // Instantiate controller if it exists, because we have scope\r\n          if (controller) {\r\n            var invokeCtrl = $controller(controller, locals, true);\r\n            if (bindToController) {\r\n              angular.extend(invokeCtrl.instance, locals);\r\n            }\r\n            // Support angular@~1.2 invokeCtrl\r\n            var ctrl = angular.isObject(invokeCtrl) ? invokeCtrl : invokeCtrl();\r\n            // See angular-route source for this logic\r\n            element.data('$ngControllerController', ctrl);\r\n            element.children().data('$ngControllerController', ctrl);\r\n\r\n            if (controllerAs) {\r\n              scope[controllerAs] = ctrl;\r\n            }\r\n          }\r\n\r\n          return linkFn.apply(null, arguments);\r\n        }\r\n      };\r\n    });\r\n\r\n  };\r\n\r\n  function findElement (query, element) {\r\n    return angular.element((element || document).querySelectorAll(query));\r\n  }\r\n\r\n  var fetchPromises = {};\r\n  function fetchTemplate (template) {\r\n    if (fetchPromises[template]) return fetchPromises[template];\r\n    return (fetchPromises[template] = $http.get(template, {cache: $templateCache})\r\n      .then(function (res) {\r\n        return res.data;\r\n      }));\r\n  }\r\n\r\n}\r\n\r\n// Source: dropdown\\dropdown.js\r\nangular.module('mgcrea.ngStrap.dropdown', ['mgcrea.ngStrap.tooltip'])\r\n\r\n  .provider('$dropdown', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      prefixClass: 'dropdown',\r\n      prefixEvent: 'dropdown',\r\n      placement: 'bottom-left',\r\n      templateUrl: 'dropdown/dropdown.tpl.html',\r\n      trigger: 'click',\r\n      container: false,\r\n      keyboard: true,\r\n      html: false,\r\n      delay: 0\r\n    };\r\n\r\n    this.$get = function ($window, $rootScope, $tooltip, $timeout) {\r\n\r\n      var bodyEl = angular.element($window.document.body);\r\n      var matchesSelector = Element.prototype.matchesSelector || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector;\r\n\r\n      function DropdownFactory (element, config) {\r\n\r\n        var $dropdown = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n        /* var scope = */\r\n        $dropdown.$scope = options.scope && options.scope.$new() || $rootScope.$new();\r\n\r\n        $dropdown = $tooltip(element, options);\r\n        var parentEl = element.parent();\r\n\r\n        if (element && element[0] && element[0].tagName.toUpperCase() === 'BUTTON') {\r\n          element.attr('aria-haspopup', 'true');\r\n          element.attr('data-toggle', 'dropdown');\r\n          element.attr('aria-expanded', 'false');\r\n          element.attr('role', 'button');\r\n        }\r\n\r\n        // Protected methods\r\n\r\n        $dropdown.$onKeyDown = function (evt) {\r\n          if ((/(9)/.test(evt.keyCode) && !options.keyboard) || /27/.test(evt.keyCode)) {\r\n            $dropdown.hide(/27/.test(evt.keyCode));\r\n            return;\r\n          }\r\n          if (!/(38|40)/.test(evt.keyCode)) return;\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n\r\n          // Retrieve focused index\r\n          var items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider) a'));\r\n          if (!items.length) return;\r\n          var index;\r\n          angular.forEach(items, function (el, i) {\r\n            if (matchesSelector && matchesSelector.call(el, ':focus')) index = i;\r\n          });\r\n\r\n          // Navigate with keyboard\r\n          if (evt.keyCode === 38 && index > 0) index--;\r\n          else if (evt.keyCode === 40 && index < items.length - 1) index++;\r\n          else if (evt.keyCode === 40 && index === items.length - 1) index = 0;\r\n          else if (angular.isUndefined(index)) index = 0;\r\n          items.eq(index)[0].focus();\r\n\r\n        };\r\n\r\n        $dropdown.$onFocusOut = function (evt) {\r\n          // find out if the related target's parents contain the datepicker's $element\r\n          var inMenu = false;\r\n          var parent = angular.element(evt.relatedTarget);\r\n          while (parent !== undefined && parent.length && parent[0] !== $window.document.body) {\r\n            parent = parent.parent();\r\n            if (parent !== undefined && parent[0] === $dropdown.$element[0]) {\r\n              inMenu = true;\r\n              break;\r\n            } else {\r\n              inMenu = false;\r\n            }\r\n          }\r\n\r\n          if (!inMenu) {\r\n            $dropdown.hide();\r\n          } else {\r\n            evt.preventDefault();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        // Overrides\r\n\r\n        var show = $dropdown.show;\r\n        $dropdown.show = function () {\r\n          show();\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed imediately.\r\n          $timeout(function () {\r\n            // Set assistive technology properties\r\n            element.attr('aria-expanded', 'true');\r\n            if ($dropdown.$element) {\r\n              $dropdown.$element.attr('aria-hidden', 'false');\r\n              $dropdown.$element.attr('role', 'menu');\r\n              $dropdown.$element.attr('tabindex', '-1');\r\n            }\r\n            if (options.keyboard && $dropdown.$element) {\r\n              $dropdown.$element.on('keydown', $dropdown.$onKeyDown);\r\n              $dropdown.$element.on('focusout', $dropdown.$onFocusOut);\r\n            }\r\n\r\n            bodyEl.on('click', onBodyClick);\r\n\r\n            if ($dropdown.$element) {\r\n              var items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider)'));\r\n              items.attr('role', 'presentation');\r\n\r\n              angular.element($dropdown.$element[0].querySelectorAll('li.divider')).attr('role', 'seperator');\r\n\r\n              items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider) a'));\r\n              items.attr('role', 'menuitem');\r\n              if (items.length && options.keyboard) {\r\n                items[0].focus();\r\n              }\r\n            }\r\n          }, 0, false);\r\n          if (parentEl.hasClass('dropdown')) parentEl.addClass('open');\r\n        };\r\n\r\n        var hide = $dropdown.hide;\r\n        $dropdown.hide = function (returnFocus) {\r\n          if (!$dropdown.$isShown) return;\r\n\r\n          element.attr('aria-expanded', 'true');\r\n          $dropdown.$element.attr('aria-hidden', 'true');\r\n\r\n          if (options.keyboard && $dropdown.$element) {\r\n            $dropdown.$element.off('keydown', $dropdown.$onKeyDown);\r\n            $dropdown.$element.off('focusout', $dropdown.$onFocusOut);\r\n          }\r\n\r\n          bodyEl.off('click', onBodyClick);\r\n          if (parentEl.hasClass('dropdown')) parentEl.removeClass('open');\r\n          $timeout(function () {\r\n            hide();\r\n            if (returnFocus) {\r\n              $timeout(function () {\r\n                if (element && element[0]) {\r\n                  element[0].focus();\r\n                }\r\n              }, 0, false);\r\n            }\r\n          }, 200);\r\n        };\r\n\r\n        var destroy = $dropdown.destroy;\r\n        $dropdown.destroy = function () {\r\n          bodyEl.off('click', onBodyClick);\r\n          destroy();\r\n        };\r\n\r\n        // Private functions\r\n\r\n        function onBodyClick (evt) {\r\n          if (evt.target === element[0]) return undefined;\r\n          return evt.target !== element[0] && $dropdown.hide();\r\n        }\r\n\r\n        return $dropdown;\r\n\r\n      }\r\n\r\n      return DropdownFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsDropdown', function ($window, $sce, $dropdown) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      compile: function (tElement, tAttrs) {\r\n\r\n        // Support for inlined template (next sibling)\r\n        // It must be fetched before compilation\r\n        if (!tAttrs.bsDropdown) {\r\n          var nextSibling = tElement[0].nextSibling;\r\n          while (nextSibling && nextSibling.nodeType !== 1) {\r\n            nextSibling = nextSibling.nextSibling;\r\n          }\r\n          if (nextSibling && nextSibling.className.split(' ').indexOf('dropdown-menu') >= 0) {\r\n            tAttrs.template = nextSibling.outerHTML;\r\n            tAttrs.templateUrl = undefined;\r\n            nextSibling.parentNode.removeChild(nextSibling);\r\n          }\r\n        }\r\n\r\n        return function postLink (scope, element, attr) {\r\n\r\n          // Directive options\r\n          var options = {\r\n            scope: scope\r\n          };\r\n          angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'id', 'autoClose'], function (key) {\r\n            if (angular.isDefined(tAttrs[key])) options[key] = tAttrs[key];\r\n          });\r\n\r\n          // use string regex match boolean attr falsy values, leave truthy values be\r\n          var falseValueRegExp = /^(false|0|)$/i;\r\n          angular.forEach(['html', 'container'], function (key) {\r\n            if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n          });\r\n\r\n          // bind functions from the attrs to the show and hide events\r\n          angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n            var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n            if (angular.isDefined(attr[bsKey])) {\r\n              options[key] = scope.$eval(attr[bsKey]);\r\n            }\r\n          });\r\n\r\n          // Support scope as an object\r\n          if (attr.bsDropdown) {\r\n            scope.$watch(attr.bsDropdown, function (newValue, oldValue) {\r\n              scope.content = newValue;\r\n            }, true);\r\n          }\r\n\r\n          // Initialize dropdown\r\n          var dropdown = $dropdown(element, options);\r\n\r\n          // Visibility binding support\r\n          if (attr.bsShow) {\r\n            scope.$watch(attr.bsShow, function (newValue, oldValue) {\r\n              if (!dropdown || !angular.isDefined(newValue)) return;\r\n              if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(dropdown),?/i);\r\n              if (newValue === true) {\r\n                dropdown.show();\r\n              } else {\r\n                dropdown.hide();\r\n              }\r\n            });\r\n          }\r\n\r\n          // Garbage collection\r\n          scope.$on('$destroy', function () {\r\n            if (dropdown) dropdown.destroy();\r\n            options = null;\r\n            dropdown = null;\r\n          });\r\n\r\n        };\r\n      }\r\n    };\r\n\r\n  });\r\n\r\n// Source: datepicker\\datepicker.js\r\nangular.module('mgcrea.ngStrap.datepicker', ['mgcrea.ngStrap.helpers.dateParser', 'mgcrea.ngStrap.helpers.dateFormatter', 'mgcrea.ngStrap.helpers.focusElement', 'mgcrea.ngStrap.helpers.ngFocusOut', 'mgcrea.ngStrap.tooltip'])\r\n  .provider('$datepicker', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      // Uncommenting the following line will break backwards compatability\r\n      // prefixEvent: 'datepicker',\r\n      prefixClass: 'datepicker',\r\n      placement: 'bottom-left',\r\n      templateUrl: 'datepicker/datepicker.tpl.html',\r\n      trigger: 'focus',\r\n      container: false,\r\n      keyboard: true,\r\n      html: false,\r\n      delay: 0,\r\n      // lang: $locale.id,\r\n      useNative: false,\r\n      dateType: 'date',\r\n      dateFormat: 'shortDate',\r\n      timezone: null,\r\n      modelDateFormat: null,\r\n      dayFormat: 'dd',\r\n      monthFormat: 'MMM',\r\n      yearFormat: 'yyyy',\r\n      monthTitleFormat: 'MMMM yyyy',\r\n      yearTitleFormat: 'yyyy',\r\n      strictFormat: false,\r\n      autoclose: false,\r\n      minDate: -Infinity,\r\n      maxDate: +Infinity,\r\n      startView: 0,\r\n      minView: 0,\r\n      startWeek: 0,\r\n      daysOfWeekDisabled: '',\r\n      hasToday: false,\r\n      hasClear: false,\r\n      iconLeft: 'glyphicon glyphicon-chevron-left',\r\n      iconRight: 'glyphicon glyphicon-chevron-right',\r\n      // The format that will be given to the screen reader values placed in the DOM.\r\n      screenReaderDateFormat: 'fullDate',\r\n      // Focuses the table element in the dropdown upon display of the picker.\r\n      // Used mainly in 508 situations when a button is pressed via a keyboard to show the calendar.\r\n      focusOnOpen: false\r\n    };\r\n\r\n    this.$get = function ($window, $document, $rootScope, $sce, $dateFormatter, datepickerViews, $tooltip, $timeout) {\r\n\r\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n      var isTouch = ('createTouch' in $window.document) && isNative;\r\n      if (!defaults.lang) defaults.lang = $dateFormatter.getDefaultLocale();\r\n\r\n      function DatepickerFactory (element, controller, config) {\r\n\r\n        // The datepicker is based on the tooltip control. Build a basic tooltip from the\r\n        // defaults and the configuration passed.\r\n        var $datepicker = $tooltip(element, angular.extend({}, defaults, config));\r\n        var parentScope = config.scope;\r\n        var options = $datepicker.$options;\r\n        var scope = $datepicker.$scope;\r\n        if (options.startView) options.startView -= options.minView;\r\n\r\n        // Add assistive technology helper attributes.\r\n        element.attr('aria-expanded', 'false').attr('aria-haspopup', 'true');\r\n\r\n        // View vars\r\n\r\n        // Initialize the datepicker view collection by passing a reference to the base object.\r\n        var pickerViews = datepickerViews($datepicker);\r\n        $datepicker.$views = pickerViews.views;\r\n        var viewDate = pickerViews.viewDate;\r\n        /*\r\n         * View mode for the date picker.\r\n         * 0: days\r\n         * 1: months\r\n         * 2: years\r\n         */\r\n        scope.$mode = options.startView;\r\n        // icon class override\r\n        scope.$iconLeft = options.iconLeft;\r\n        scope.$iconRight = options.iconRight;\r\n        // Show buttons at the bottom of the picker.\r\n        scope.$hasToday = options.hasToday;\r\n        scope.$hasClear = options.hasClear;\r\n        /*\r\n         * An id on the element is necessary when working with assistive technologies. The view will use the id to build out the\r\n         * aria attributes which are linked via ids.\r\n         */\r\n        scope.id = options.id !== null && options.id !== undefined ? options.id : undefined;\r\n        scope.dropdownId = options.id !== null && options.id !== undefined ? (options.id + '_dropdown') : undefined;\r\n        scope.keyboard = options.keyboard;\r\n        scope.focusOnOpen = options.focusOnOpen;\r\n\r\n        // labels\r\n        scope.$nextLabel = options.labelNext;\r\n        scope.$previousLabel = options.labelPrevious;\r\n\r\n        // This is the actual current picker view.\r\n        var $picker = $datepicker.$views[scope.$mode];\r\n\r\n        // Internal handlers\r\n\r\n        function handleOnKeyDown (evt, apply) {\r\n          if (!/(33|34|38|37|39|40|13)/.test(evt.keyCode) &&\r\n            !(/(33|34|38|37|39|40|13)/.test(evt.keyCode) && evt.shiftKey) &&\r\n            !(/(33|34|38|37|39|40|13)/.test(evt.keyCode) && evt.altKey)) {\r\n            return false;\r\n          }\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n\r\n          if (evt.keyCode === 13) {\r\n            if (!scope.$mode) {\r\n              $datepicker.hide(true);\r\n              if (options.focusOnOpen) return true;\r\n            } else {\r\n              if (apply === undefined || apply) {\r\n                scope.$apply(function () {\r\n                  $datepicker.setMode(scope.$mode - 1);\r\n                });\r\n              } else {\r\n                $datepicker.setMode(scope.$mode - 1);\r\n              }\r\n            }\r\n            return false;\r\n          }\r\n\r\n          return true;\r\n        }\r\n\r\n        // Scope methods\r\n\r\n        /**\r\n         * Pass through from the scope to the provider for the selection of a date.\r\n         */\r\n        scope.$select = function (date, disabled) {\r\n          if (disabled) return;\r\n          $datepicker.select(date);\r\n        };\r\n        scope.$selectPane = function (value) {\r\n          $datepicker.$selectPane(value);\r\n        };\r\n        scope.$toggleMode = function () {\r\n          $datepicker.setMode((scope.$mode + 1) % $datepicker.$views.length);\r\n        };\r\n        scope.$setToday = function () {\r\n          if (options.autoclose) {\r\n            $datepicker.setMode(0);\r\n            $datepicker.select(new Date());\r\n          } else {\r\n            $datepicker.select(new Date(), true);\r\n          }\r\n        };\r\n        scope.$clear = function () {\r\n          if (options.autoclose) {\r\n            $datepicker.setMode(0);\r\n            $datepicker.select(null);\r\n          } else {\r\n            $datepicker.select(null, true);\r\n          }\r\n        };\r\n        scope.$focused = function (dayInfo) {\r\n          scope.selectedDayId = dayInfo.id;\r\n          if (dayInfo.isNext && !scope.selected) {\r\n            if (scope.$mode) {\r\n              $datepicker.update(dayInfo.date);\r\n            } else {\r\n              scope.$select(dayInfo.date);\r\n            }\r\n          }\r\n        };\r\n        scope.$onKeyDown = function (evt, day) {\r\n          var continueHandling = handleOnKeyDown(evt, false);\r\n\r\n          if (continueHandling) {\r\n            // Navigate with keyboard\r\n            $picker.onKeyDown(evt);\r\n          }\r\n        };\r\n        scope.$onFocusOut = function (evt) {\r\n          // find out if the related target's parents contain the datepicker's $element\r\n          var inTable = false;\r\n          var parent = angular.element(evt.relatedTarget);\r\n          while (parent !== undefined && parent.length && parent[0] !== $window.document.body) {\r\n            parent = parent.parent();\r\n            if (parent !== undefined && parent[0] === $datepicker.$element[0]) {\r\n              inTable = true;\r\n              break;\r\n            } else {\r\n              inTable = false;\r\n            }\r\n          }\r\n\r\n          // In Chrome there is an issue when moving from month to month, year to year, etc.\r\n          //\r\n\r\n          if (!inTable && !evt.relatedTarget) {\r\n            // hmm\r\n          } else if (!inTable) {\r\n            $datepicker.hide();\r\n          } else {\r\n            evt.stopPropagation();\r\n            evt.preventDefault();\r\n          }\r\n        };\r\n\r\n        // Public methods\r\n\r\n        $datepicker.update = function (date) {\r\n          // console.warn('$datepicker.update() newValue=%o', date);\r\n          if (angular.isDate(date) && !isNaN(date.getTime())) {\r\n            $datepicker.$date = date;\r\n            $picker.update.call($picker, date);\r\n          }\r\n          // Build only if pristine\r\n          $datepicker.$build(true);\r\n        };\r\n\r\n        $datepicker.updateDisabledDates = function (dateRanges) {\r\n          options.disabledDateRanges = dateRanges;\r\n          for (var i = 0, l = scope.rows.length; i < l; i++) {\r\n            angular.forEach(scope.rows[i], $datepicker.$setDisabledEl);\r\n          }\r\n        };\r\n\r\n        $datepicker.select = function (date, keep) {\r\n          // console.warn('$datepicker.select', date, scope.$mode);\r\n          if (angular.isDate(date)) {\r\n            if (!angular.isDate(controller.$dateValue) || isNaN(controller.$dateValue.getTime())) {\r\n              controller.$dateValue = new Date(date);\r\n            }\r\n          } else {\r\n            controller.$dateValue = null;\r\n          }\r\n          if (!scope.$mode || keep) {\r\n            controller.$setViewValue(angular.copy(date));\r\n            controller.$render();\r\n            if (options.autoclose && !keep) {\r\n              $timeout(function () {\r\n                $datepicker.hide(true);\r\n              });\r\n            }\r\n          } else {\r\n            angular.extend(viewDate, {\r\n              year: date.getFullYear(),\r\n              month: date.getMonth(),\r\n              date: date.getDate()\r\n            });\r\n            $datepicker.setMode(scope.$mode - 1);\r\n            $datepicker.$build();\r\n          }\r\n        };\r\n\r\n        /**\r\n         * This changes the mode of the picker. By setting the mode the view for the picker will be\r\n         * rebuilt. The views are days, months, and years.\r\n         * @param {int} mode View mode for the datepicker. 0: day view, 1: month view, 2: year view.\r\n         */\r\n        $datepicker.setMode = function setMode (mode) {\r\n          scope.$mode = mode;\r\n          $picker = $datepicker.$views[scope.$mode];\r\n          // The picker has been changed so the view needs to be built.\r\n          $datepicker.$build();\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        /**\r\n         * Builds the datepicker's view based on the picker that is currently set.\r\n         */\r\n        $datepicker.$build = function $build (pristine) {\r\n          // console.warn('$datepicker.$build() viewDate=%o', viewDate);\r\n          if (pristine === true && $picker.built) return;\r\n          if (pristine === false && !$picker.built) return;\r\n          $picker.build.call($picker);\r\n        };\r\n\r\n        $datepicker.$updateSelected = function () {\r\n          for (var i = 0, l = scope.rows.length; i < l; i++) {\r\n            angular.forEach(scope.rows[i], function (day) {\r\n              updateSelected(day);\r\n              if (day.selected) scope.selected = day;\r\n            });\r\n          }\r\n        };\r\n\r\n        $datepicker.$isSelected = function (date) {\r\n          return $picker.isSelected(date);\r\n        };\r\n\r\n        $datepicker.$setDisabledEl = function (el) {\r\n          el.disabled = $picker.isDisabled(el.date);\r\n        };\r\n\r\n        $datepicker.$selectPane = function (value) {\r\n          var steps = $picker.steps;\r\n          // set targetDate to first day of month to avoid problems with\r\n          // date values rollover. This assumes the viewDate does not\r\n          // depend on the day of the month\r\n          var targetDate = new Date(Date.UTC(viewDate.year + ((steps.year || 0) * value), viewDate.month + ((steps.month || 0) * value), 1));\r\n          angular.extend(viewDate, {\r\n            year: targetDate.getUTCFullYear(),\r\n            month: targetDate.getUTCMonth(),\r\n            date: targetDate.getUTCDate()\r\n          });\r\n          $datepicker.$build();\r\n        };\r\n\r\n        $datepicker.$onMouseDown = function (evt) {\r\n          // Prevent blur on mousedown on .dropdown-menu\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n          // Emulate click for mobile devices\r\n          if (isTouch) {\r\n            var targetEl = angular.element(evt.target);\r\n            if (targetEl[0].nodeName.toLowerCase() !== 'button') {\r\n              targetEl = targetEl.parent();\r\n            }\r\n            targetEl.triggerHandler('click');\r\n          }\r\n        };\r\n\r\n        /**\r\n         * Handles the onKeyDown event from the element that this datepicker is bound.\r\n         * In the standard case this will be an input element. If the trigger is set\r\n         * to click and is bound to a button then it is likely we're servicing a 508\r\n         * type situation where the implementation will no longer uses. Focus will be\r\n         * given to the table.\r\n         */\r\n        $datepicker.$onKeyDown = function (evt) {\r\n          var continueHandling = handleOnKeyDown(evt);\r\n\r\n          if (continueHandling) {\r\n            // Navigate with keyboard\r\n            $picker.onKeyDown(evt);\r\n            parentScope.$digest();\r\n          }\r\n        };\r\n\r\n        // $datepicker.$onFocusOut = function (evt) {\r\n        //   // find out if the related target's parents contain the datepicker's $element\r\n        //   var inTable = false;\r\n        //   var parent = angular.element(evt.relatedTarget);\r\n        //   while (parent !== undefined && parent.length && parent[0] !== $window.document.body) {\r\n        //     parent = parent.parent();\r\n        //     if (parent !== undefined && parent[0] === $datepicker.$element[0]) {\r\n        //       inTable = true;\r\n        //       break;\r\n        //     } else {\r\n        //       inTable = false;\r\n        //     }\r\n        //   }\r\n\r\n        //   // In Chrome there is an issue when moving from month to month, year to year, etc.\r\n        //   //\r\n\r\n        //   if (!inTable && !evt.relatedTarget) {\r\n        //     // hmm\r\n        //   } else if (!inTable) {\r\n        //     $datepicker.hide();\r\n        //   } else {\r\n        //     evt.stopPropagation();\r\n        //     evt.preventDefault();\r\n        //   }\r\n        // };\r\n\r\n        // Private\r\n\r\n        function updateSelected (el) {\r\n          el.selected = $datepicker.$isSelected(el.date);\r\n          el.focused = el.selected;\r\n        }\r\n\r\n        function focusElement () {\r\n          element[0].focus();\r\n        }\r\n\r\n        // Overrides\r\n\r\n        // The datepicker will override the init functionality of the tool\r\n        var _init = $datepicker.init;\r\n        /**\r\n         * Initialize the datepicker.\r\n         */\r\n        $datepicker.init = function () {\r\n          if (isNative && options.useNative) {\r\n            element.prop('type', 'date');\r\n            element.css('-webkit-appearance', 'textfield');\r\n            return;\r\n          } else if (isTouch) {\r\n            element.prop('type', 'text');\r\n            element.attr('readonly', 'true');\r\n            element.on('click', focusElement);\r\n          }\r\n          _init();\r\n        };\r\n\r\n        // The datepicker will override the destroy functionalty of the tooltip. Storing a ref to the\r\n        // tooltip's destroy function so that it can be invoked when the datepicker needs to be destroyed.\r\n        var _destroy = $datepicker.destroy;\r\n\r\n        /**\r\n         * Destroys the datepicker by removing bound events. Calls the destroy function on the tooltip.\r\n         */\r\n        $datepicker.destroy = function () {\r\n          if (isNative && options.useNative) {\r\n            element.off('click', focusElement);\r\n          }\r\n          _destroy();\r\n        };\r\n\r\n        // The datepicker will override the show functionality of the tooltip. Store a ref to the\r\n        // tooltip's show function so that it can be invoked at the appropriate time when the picker\r\n        // is to be shown.\r\n        var _show = $datepicker.show;\r\n\r\n        /**\r\n         * Override for the tooltip's show function.\r\n         *\r\n         * Checks the element for readonly or disabled before showing the \"tooltip\".\r\n         * Once shown it sets up the appropriate events.\r\n         */\r\n        $datepicker.show = function show () {\r\n          // If the input the directive is bound to is readonly or disabled then do not show a picker.\r\n          if ((!isTouch && element.attr('readonly')) || element.attr('disabled')) return;\r\n\r\n          // Call the \"overriden base\" function on the tooltip.\r\n          _show();\r\n\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed imediately.\r\n          $timeout(function () {\r\n            // if $datepicker is no longer showing, don't setup events\r\n            if (!$datepicker.$isShown) return;\r\n\r\n            // Update assistive technologies for view changes:\r\n            $datepicker.$element.attr('aria-hidden', 'false');\r\n            element.attr('aria-expanded', 'true');\r\n\r\n            // Setup the event mouse click event. TODO: Can this be wired up in the view?\r\n            $datepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\r\n\r\n            // If keyboard navigation is enabled (true by default).\r\n            if (options.keyboard) {\r\n              // $datepicker.$element.on('keydown', $datepicker.$onKeyDown);\r\n              // Check to see if the table element should receive the focus when the picker is shown.\r\n              if (options.focusOnOpen) {\r\n                // Focus the table element.\r\n                // $datepicker.$element.find('table')[0].focus();\r\n                // $datepicker.$element.on('focusout', $datepicker.$onFocusOut);\r\n              } else {\r\n                element.on('keydown', $datepicker.$onKeyDown);\r\n              }\r\n            }\r\n          }, 0, false);\r\n        };\r\n\r\n        // The datepicker will override the hide functionality of the tooltip. Store a ref to the\r\n        // tooltip's show function so that it can be invoked at the appropriate time when the picker\r\n        // is to be hidden.\r\n        var _hide = $datepicker.hide;\r\n\r\n        /**\r\n         * Overrid efor the tooltip's hide function.\r\n         *\r\n         * Updates attributes for assistive technologies and unbinds events.\r\n         */\r\n        $datepicker.hide = function (blur) {\r\n          // If the picker is already hidden don't do anything.\r\n          if (!$datepicker.$isShown) return;\r\n\r\n          // Update the attributes used by assisteive technologies\r\n          $datepicker.$element.attr('aria-hidden', 'true');\r\n          element.attr('aria-expanded', 'false');\r\n\r\n          // Unbind the mouse and touch events\r\n          $datepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\r\n\r\n          // If keyboard events were bound then unbind them.\r\n          if (options.keyboard) {\r\n            element.off('keydown', $datepicker.$onKeyDown);\r\n            $datepicker.$element.off('keydown', $datepicker.$onKeyDown);\r\n          }\r\n          if (options.focusOnOpen) {\r\n            // $datepicker.$element.off('focusout', $datepicker.$onFocusOut);\r\n            element[0].focus();\r\n          }\r\n          // Call the tooltip's hide function.\r\n          _hide(blur);\r\n        };\r\n\r\n        return $datepicker;\r\n      }\r\n\r\n      DatepickerFactory.defaults = defaults;\r\n      return DatepickerFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsDatepicker', function ($window, $parse, $q, $dateFormatter, $dateParser, $datepicker) {\r\n\r\n    // var defaults = $datepicker.defaults;\r\n    var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        // Directive options\r\n        var options = {\r\n          scope: scope\r\n        };\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'autoclose', 'dateType', 'dateFormat', 'timezone', 'modelDateFormat', 'dayFormat', 'strictFormat', 'startWeek', 'startDate', 'useNative', 'lang', 'startView', 'minView', 'iconLeft', 'iconRight', 'daysOfWeekDisabled', 'id', 'prefixClass', 'prefixEvent', 'hasToday', 'hasClear', 'focusOnOpen', 'labelNext', 'labelPrevious', 'labelMonth', 'labelYear', 'labelDays'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container', 'autoclose', 'useNative', 'hasToday', 'hasClear', 'focusOnOpen'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\r\n            options[key] = false;\r\n          }\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Initialize datepicker\r\n        var datepicker = $datepicker(element, controller, options);\r\n        options = datepicker.$options;\r\n        // Set expected iOS format\r\n        if (isNative && options.useNative) options.dateFormat = 'yyyy-MM-dd';\r\n\r\n        var lang = options.lang;\r\n\r\n        var formatDate = function (date, format) {\r\n          return $dateFormatter.formatDate(date, format, lang);\r\n        };\r\n\r\n        var dateParser = $dateParser({\r\n          format: options.dateFormat,\r\n          lang: lang,\r\n          strict: options.strictFormat\r\n        });\r\n\r\n        // Visibility binding support\r\n        if (attr.bsShow) {\r\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\r\n            if (!datepicker || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(datepicker),?/i);\r\n            if (newValue === true) {\r\n              datepicker.show();\r\n            } else {\r\n              datepicker.hide();\r\n            }\r\n          });\r\n        }\r\n\r\n        // Observe attributes for changes\r\n        angular.forEach(['minDate', 'maxDate'], function (key) {\r\n          // console.warn('attr.$observe(%s)', key, attr[key]);\r\n          if (angular.isDefined(attr[key])) {\r\n            attr.$observe(key, function (newValue) {\r\n              // console.warn('attr.$observe(%s)=%o', key, newValue);\r\n              datepicker.$options[key] = dateParser.getDateForAttribute(key, newValue);\r\n              // Build only if dirty\r\n              if (!isNaN(datepicker.$options[key])) datepicker.$build(false);\r\n              validateAgainstMinMaxDate(controller.$dateValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Observe date format\r\n        if (angular.isDefined(attr.dateFormat)) {\r\n          attr.$observe('dateFormat', function (newValue) {\r\n            datepicker.$options.dateFormat = newValue;\r\n          });\r\n        }\r\n\r\n        // Watch model for changes\r\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\r\n          datepicker.update(controller.$dateValue);\r\n        }, true);\r\n\r\n        // Normalize undefined/null/empty array,\r\n        // so that we don't treat changing from undefined->null as a change.\r\n        function normalizeDateRanges (ranges) {\r\n          if (!ranges || !ranges.length) return null;\r\n          return ranges;\r\n        }\r\n\r\n        if (angular.isDefined(attr.disabledDates)) {\r\n          scope.$watch(attr.disabledDates, function (disabledRanges, previousValue) {\r\n            disabledRanges = normalizeDateRanges(disabledRanges);\r\n            previousValue = normalizeDateRanges(previousValue);\r\n\r\n            if (disabledRanges) {\r\n              datepicker.updateDisabledDates(disabledRanges);\r\n            }\r\n          });\r\n        }\r\n\r\n        function validateAgainstMinMaxDate (parsedDate) {\r\n          if (!angular.isDate(parsedDate)) return;\r\n          var isMinValid = isNaN(datepicker.$options.minDate) || parsedDate.getTime() >= datepicker.$options.minDate;\r\n          var isMaxValid = isNaN(datepicker.$options.maxDate) || parsedDate.getTime() <= datepicker.$options.maxDate;\r\n          var isValid = isMinValid && isMaxValid;\r\n          controller.$setValidity('date', isValid);\r\n          controller.$setValidity('min', isMinValid);\r\n          controller.$setValidity('max', isMaxValid);\r\n          // Only update the model when we have a valid date\r\n          if (isValid) controller.$dateValue = parsedDate;\r\n        }\r\n\r\n        // viewValue -> $parsers -> modelValue\r\n        controller.$parsers.unshift(function (viewValue) {\r\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\r\n          var date;\r\n          // Null values should correctly reset the model value & validity\r\n          if (!viewValue) {\r\n            controller.$setValidity('date', true);\r\n            // BREAKING CHANGE:\r\n            // return null (not undefined) when input value is empty, so angularjs 1.3\r\n            // ngModelController can go ahead and run validators, like ngRequired\r\n            return null;\r\n          }\r\n          var parsedDate = dateParser.parse(viewValue, controller.$dateValue);\r\n          if (!parsedDate || isNaN(parsedDate.getTime())) {\r\n            controller.$setValidity('date', false);\r\n            // return undefined, causes ngModelController to\r\n            // invalidate model value\r\n            return;\r\n          }\r\n          validateAgainstMinMaxDate(parsedDate);\r\n\r\n          if (options.dateType === 'string') {\r\n            date = dateParser.timezoneOffsetAdjust(parsedDate, options.timezone, true);\r\n            return formatDate(date, options.modelDateFormat || options.dateFormat);\r\n          }\r\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\r\n          if (options.dateType === 'number') {\r\n            return date.getTime();\r\n          } else if (options.dateType === 'unix') {\r\n            return date.getTime() / 1000;\r\n          } else if (options.dateType === 'iso') {\r\n            return date.toISOString();\r\n          }\r\n          return new Date(date);\r\n        });\r\n\r\n        // modelValue -> $formatters -> viewValue\r\n        controller.$formatters.push(function (modelValue) {\r\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n          var date;\r\n          if (angular.isUndefined(modelValue) || modelValue === null) {\r\n            date = NaN;\r\n          } else if (angular.isDate(modelValue)) {\r\n            date = modelValue;\r\n          } else if (options.dateType === 'string') {\r\n            date = dateParser.parse(modelValue, null, options.modelDateFormat);\r\n          } else if (options.dateType === 'unix') {\r\n            date = new Date(modelValue * 1000);\r\n          } else {\r\n            date = new Date(modelValue);\r\n          }\r\n          // Setup default value?\r\n          // if (isNaN(date.getTime())) {\r\n          //   var today = new Date();\r\n          //   date = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0);\r\n          // }\r\n          // do not adjust date if timezone is UTC\r\n          if (options.timezone === 'UTC') {\r\n            controller.$dateValue = date;\r\n          } else {\r\n            controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\r\n          }\r\n          return getDateFormattedString();\r\n        });\r\n\r\n        // viewValue -> element\r\n        controller.$render = function () {\r\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\r\n          element.val(getDateFormattedString());\r\n        };\r\n\r\n        function getDateFormattedString () {\r\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.dateFormat);\r\n        }\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (datepicker) datepicker.destroy();\r\n          options = null;\r\n          datepicker = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsDatepickerDisplay', function ($datepicker, $dateParser, $dateFormatter) {\r\n    return {\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n        // Directive options\r\n        var options = {\r\n          scope: scope\r\n        };\r\n        angular.forEach(['dateType', 'dateFormat', 'timezone', 'modelDateFormat', 'dayFormat', 'strictFormat', 'lang'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        options = angular.extend({}, $datepicker.defaults, options);\r\n\r\n        var lang = options.lang;\r\n\r\n        var formatDate = function (date, format) {\r\n          return $dateFormatter.formatDate(date, format, lang);\r\n        };\r\n\r\n        var dateParser = $dateParser({\r\n          format: options.dateFormat,\r\n          lang: lang,\r\n          strict: options.strictFormat\r\n        });\r\n\r\n        // Observe attributes for changes\r\n        angular.forEach(['minDate', 'maxDate'], function (key) {\r\n          if (angular.isDefined(attr[key])) {\r\n            attr.$observe(key, function (newValue) {\r\n              options[key] = dateParser.getDateForAttribute(key, newValue);\r\n              validateAgainstMinMaxDate(controller.$dateValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Observe date format\r\n        if (angular.isDefined(attr.dateFormat)) {\r\n          attr.$observe('dateFormat', function (newValue) {\r\n            options.dateFormat = newValue;\r\n          });\r\n        }\r\n\r\n        function validateAgainstMinMaxDate (parsedDate) {\r\n          if (!angular.isDate(parsedDate)) return;\r\n          var isMinValid = isNaN(options.minDate) || parsedDate.getTime() >= options.minDate;\r\n          var isMaxValid = isNaN(options.maxDate) || parsedDate.getTime() <= options.maxDate;\r\n          var isValid = isMinValid && isMaxValid;\r\n          controller.$setValidity('date', isValid);\r\n          controller.$setValidity('min', isMinValid);\r\n          controller.$setValidity('max', isMaxValid);\r\n          // Only update the model when we have a valid date\r\n          if (isValid) controller.$dateValue = parsedDate;\r\n        }\r\n\r\n        // viewValue -> $parsers -> modelValue\r\n        controller.$parsers.unshift(function (viewValue) {\r\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\r\n          var date;\r\n          // Null values should correctly reset the model value & validity\r\n          if (!viewValue) {\r\n            controller.$setValidity('date', true);\r\n            // BREAKING CHANGE:\r\n            // return null (not undefined) when input value is empty, so angularjs 1.3\r\n            // ngModelController can go ahead and run validators, like ngRequired\r\n            return null;\r\n          }\r\n          var parsedDate = dateParser.parse(viewValue, controller.$dateValue);\r\n          if (!parsedDate || isNaN(parsedDate.getTime())) {\r\n            controller.$setValidity('date', false);\r\n            // return undefined, causes ngModelController to\r\n            // invalidate model value\r\n            return;\r\n          }\r\n          validateAgainstMinMaxDate(parsedDate);\r\n\r\n          if (options.dateType === 'string') {\r\n            date = dateParser.timezoneOffsetAdjust(parsedDate, options.timezone, true);\r\n            return formatDate(date, options.modelDateFormat || options.dateFormat);\r\n          }\r\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\r\n          if (options.dateType === 'number') {\r\n            return date.getTime();\r\n          } else if (options.dateType === 'unix') {\r\n            return date.getTime() / 1000;\r\n          } else if (options.dateType === 'iso') {\r\n            return date.toISOString();\r\n          }\r\n\r\n          return date === null ? null : new Date(date);\r\n        });\r\n\r\n        // modelValue -> $formatters -> viewValue\r\n        controller.$formatters.push(function (modelValue) {\r\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n          var date;\r\n          if (angular.isUndefined(modelValue) || modelValue === null) {\r\n            date = NaN;\r\n          } else if (angular.isDate(modelValue)) {\r\n            date = modelValue;\r\n          } else if (options.dateType === 'string') {\r\n            date = dateParser.parse(modelValue, null, options.modelDateFormat);\r\n          } else if (options.dateType === 'unix') {\r\n            date = new Date(modelValue * 1000);\r\n          } else {\r\n            date = new Date(modelValue);\r\n          }\r\n          // Setup default value?\r\n          // if (isNaN(date.getTime())) {\r\n          //   var today = new Date();\r\n          //   date = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0);\r\n          // }\r\n          // do not adjust date if timezone is UTC\r\n          if (options.timezone === 'UTC') {\r\n            controller.$dateValue = date;\r\n          } else {\r\n            controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\r\n          }\r\n\r\n          return getDateFormattedString();\r\n        });\r\n\r\n        function getDateFormattedString () {\r\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.dateFormat);\r\n        }\r\n      }\r\n    };\r\n  })\r\n\r\n  .provider('datepickerViews', function () {\r\n\r\n    // var defaults = this.defaults = {\r\n    //   dayFormat: 'dd',\r\n    //   daySplit: 7\r\n    // };\r\n\r\n    // Split array into smaller arrays\r\n    function split (arr, size) {\r\n      var arrays = [];\r\n      while (arr.length > 0) {\r\n        arrays.push(arr.splice(0, size));\r\n      }\r\n      return arrays;\r\n    }\r\n\r\n    // Modulus operator\r\n    function mod (n, m) {\r\n      return ((n % m) + m) % m;\r\n    }\r\n\r\n    this.$get = function ($dateFormatter, $dateParser, $sce) {\r\n\r\n      return function (picker) {\r\n\r\n        var scope = picker.$scope;\r\n        var options = picker.$options;\r\n\r\n        var lang = options.lang;\r\n        var formatDate = function (date, format) {\r\n          return $dateFormatter.formatDate(date, format, lang);\r\n        };\r\n        var dateParser = $dateParser({\r\n          format: options.dateFormat,\r\n          lang: lang,\r\n          strict: options.strictFormat\r\n        });\r\n\r\n        var weekDaysMin = $dateFormatter.weekdaysShort(lang);\r\n        var weekDaysLong = $dateFormatter.weekdays(lang);\r\n        var weekDaysShortLabels = weekDaysMin.slice(options.startWeek).concat(weekDaysMin.slice(0, options.startWeek));\r\n        var weekDaysLongLabels = weekDaysLong.slice(options.startWeek).concat(weekDaysMin.slice(0, options.startWeek));\r\n\r\n        var weekDaysLabelsHtml = '';\r\n        for (var i = 0; i < weekDaysShortLabels.length; i++) {\r\n          var weekDayShortLabel = weekDaysShortLabels[i];\r\n          var weekDayLabel = weekDaysLongLabels[i];\r\n          weekDaysLabelsHtml += '<th scope=\"col\" role=\"columnheader\" class=\"dow text-center\" aria-label=\"' + weekDayLabel + '\"><abbr title=\"' + weekDayLabel + '\">' + weekDayShortLabel + '</abbr></th>';\r\n        }\r\n        weekDaysLabelsHtml = $sce.trustAsHtml(weekDaysLabelsHtml);\r\n\r\n        var startDate = picker.$date || (options.startDate ? dateParser.getDateForAttribute('startDate', options.startDate) : new Date());\r\n        var viewDate = {\r\n          year: startDate.getFullYear(),\r\n          month: startDate.getMonth(),\r\n          date: startDate.getDate()\r\n        };\r\n\r\n        var views = [{\r\n          format: options.dayFormat,\r\n          split: 7,\r\n          steps: {\r\n            month: 1\r\n          },\r\n          update: function (date, force) {\r\n            if (!this.built || force || date.getFullYear() !== viewDate.year || date.getMonth() !== viewDate.month) {\r\n              angular.extend(viewDate, {\r\n                year: picker.$date.getFullYear(),\r\n                month: picker.$date.getMonth(),\r\n                date: picker.$date.getDate()\r\n              });\r\n              picker.$build();\r\n            } else if (date.getDate() !== viewDate.date || date.getDate() === 1) {\r\n              // chaging picker current month will cause viewDate.date to be set to first day of the month,\r\n              // in $datepicker.$selectPane, so picker would not update selected day display if\r\n              // user picks first day of the new month.\r\n              // As a workaround, we are always forcing update when picked date is first day of month.\r\n              viewDate.date = picker.$date.getDate();\r\n              picker.$updateSelected();\r\n            }\r\n          },\r\n          build: function () {\r\n            var firstDayOfMonth = new Date(viewDate.year, viewDate.month, 1);\r\n            var firstDayOfMonthOffset = firstDayOfMonth.getTimezoneOffset();\r\n            var firstDate = new Date(+firstDayOfMonth - mod(firstDayOfMonth.getDay() - options.startWeek, 7) * 864e5);\r\n            var firstDateOffset = firstDate.getTimezoneOffset();\r\n            var today = dateParser.timezoneOffsetAdjust(new Date(), options.timezone).toDateString();\r\n            // Handle daylight time switch\r\n            if (firstDateOffset !== firstDayOfMonthOffset) firstDate = new Date(+firstDate + (firstDateOffset - firstDayOfMonthOffset) * 60e3);\r\n            var days = [];\r\n            var day;\r\n            var selectedDay;\r\n            var todayDay;\r\n            for (var i = 0; i < 42; i++) { // < 7 * 6\r\n              day = dateParser.daylightSavingAdjust(new Date(firstDate.getFullYear(), firstDate.getMonth(), firstDate.getDate() + i));\r\n              // push the day information onto the collection\r\n              var dayItem = {\r\n                id: options.id !== null && options.id !== undefined ? (options.id + '_cell_' + i) : undefined,\r\n                date: day,\r\n                value: day.getDate(),\r\n                isToday: day.toDateString() === today,\r\n                label: formatDate(day, this.format),\r\n                screenReaderLabel: formatDate(day, $dateFormatter.getDatetimeFormat(options.screenReaderDateFormat)),\r\n                selected: picker.$date && this.isSelected(day),\r\n                muted: day.getMonth() !== viewDate.month,\r\n                disabled: this.isDisabled(day)\r\n              };\r\n\r\n              if (dayItem.selected) selectedDay = dayItem;\r\n              if (dayItem.isToday) todayDay = dayItem;\r\n\r\n              days.push(dayItem);\r\n            }\r\n\r\n            scope.selected = null;\r\n\r\n            var defaultFirstDayTabIndex = false;\r\n            // Setup the focusing\r\n            if (options.focusOnOpen) {\r\n              if (selectedDay) {\r\n                scope.selectedDayId = selectedDay.id;\r\n                if (todayDay) todayDay.focused = false;\r\n                // Needs to fire after the today focusing is unset in case the selected day is today.\r\n                selectedDay.focused = true;\r\n                scope.selected = selectedDay;\r\n              } else if (todayDay) {\r\n                todayDay.focused = true;\r\n              } else {\r\n                defaultFirstDayTabIndex = true;\r\n              }\r\n            }\r\n\r\n            scope.title = formatDate(firstDayOfMonth, options.monthTitleFormat);\r\n            scope.showLabels = true;\r\n            scope.labels = weekDaysLabelsHtml;\r\n            scope.rows = split(days, this.split);\r\n            if (defaultFirstDayTabIndex) {\r\n              scope.rows[0][0].isNext = true;\r\n            }\r\n            scope.isTodayDisabled = this.isDisabled(new Date());\r\n            scope.hasSelectedDate = picker.$date != null;\r\n            scope.$modeLabel = options.labelMonth;\r\n            this.built = true;\r\n          },\r\n          isSelected: function (date) {\r\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear() &&\r\n              date.getMonth() === picker.$date.getMonth() &&\r\n              date.getDate() === picker.$date.getDate();\r\n          },\r\n          isDisabled: function (date) {\r\n            var time = date.getTime();\r\n\r\n            // Disabled because of min/max date.\r\n            if (time < options.minDate || time > options.maxDate) return true;\r\n\r\n            // Disabled due to being a disabled day of the week\r\n            if (options.daysOfWeekDisabled.indexOf(date.getDay()) !== -1) return true;\r\n\r\n            // Disabled because of disabled date range.\r\n            if (options.disabledDateRanges) {\r\n              for (var i = 0; i < options.disabledDateRanges.length; i++) {\r\n                if (time >= options.disabledDateRanges[i].start && time <= options.disabledDateRanges[i].end) {\r\n                  return true;\r\n                }\r\n              }\r\n            }\r\n\r\n            return false;\r\n          },\r\n          onKeyDown: function (evt) {\r\n            var actualTime;\r\n\r\n            // If the picker doesn't have a date selected and the event comes from the today TD\r\n            // then set the picker's $date to today and set the actual time to its value.\r\n            if (options.keyboard &&\r\n              options.focusOnOpen &&\r\n              !picker.$date) {\r\n              if (angular.element(evt.target).find('span').hasClass('btn-today')) {\r\n                picker.$date = new Date();\r\n              } else {\r\n                picker.$date = dateParser.parse(angular.element(evt.target).attr('aria-label'), null, options.screenReaderDateFormat);\r\n              }\r\n            }\r\n\r\n            if (!picker.$date) {\r\n              return false;\r\n            }\r\n\r\n            actualTime = picker.$date.getTime();\r\n\r\n            var newDate;\r\n\r\n            switch (evt.keyCode) {\r\n              // enter\r\n              case 13:\r\n                if (options.focusOnOpen) {\r\n                  picker.select(new Date(actualTime), true);\r\n                  return false;\r\n                }\r\n                break;\r\n                // pageup\r\n              case 33:\r\n                if (evt.altKey) { // move back a year\r\n                  newDate = new Date(picker.$date.getFullYear() - 1, picker.$date.getMonth(), picker.$date.getDate());\r\n                } else { // move back a month\r\n                  newDate = new Date(picker.$date.getFullYear(), picker.$date.getMonth() - 1, picker.$date.getDate());\r\n                  if (newDate.getMonth() > (picker.$date.getMonth() - 1)) {\r\n                    newDate = new Date(picker.$date.getFullYear(), picker.$date.getMonth(), 0);\r\n                  }\r\n                }\r\n                break;\r\n\r\n                // pagedown\r\n              case 34:\r\n                if (evt.altKey) { // move forward a year\r\n                  newDate = new Date(picker.$date.getFullYear() + 1, picker.$date.getMonth(), picker.$date.getDate());\r\n                } else { // move forward a month\r\n                  newDate = new Date(picker.$date.getFullYear(), picker.$date.getMonth() + 1, picker.$date.getDate());\r\n                  if (newDate.getMonth() > (picker.$date.getMonth() + 1)) {\r\n                    newDate = new Date(picker.$date.getFullYear(), picker.$date.getMonth() + 1, 1);\r\n                  }\r\n                }\r\n\r\n                break;\r\n\r\n                // left arrow\r\n              case 37:\r\n                newDate = new Date(actualTime - 1 * 864e5);\r\n                break;\r\n\r\n                // up arrow\r\n              case 38:\r\n                newDate = new Date(actualTime - 7 * 864e5);\r\n                break;\r\n\r\n                // right arrow\r\n              case 39:\r\n                newDate = new Date(actualTime + 1 * 864e5);\r\n                break;\r\n\r\n                // down arrow\r\n              case 40:\r\n                newDate = new Date(actualTime + 7 * 864e5);\r\n                break;\r\n\r\n              default:\r\n                return false;\r\n            }\r\n\r\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\r\n\r\n            if (evt && evt.stopPropagation) evt.stopPropagation();\r\n\r\n            return false;\r\n          }\r\n        }, {\r\n          name: 'month',\r\n          format: options.monthFormat,\r\n          split: 4,\r\n          steps: {\r\n            year: 1\r\n          },\r\n          update: function (date, force) {\r\n            if (!this.built || date.getFullYear() !== viewDate.year) {\r\n              angular.extend(viewDate, {\r\n                year: picker.$date.getFullYear(),\r\n                month: picker.$date.getMonth(),\r\n                date: picker.$date.getDate()\r\n              });\r\n              picker.$build();\r\n            } else if (date.getMonth() !== viewDate.month) {\r\n              angular.extend(viewDate, {\r\n                month: picker.$date.getMonth(),\r\n                date: picker.$date.getDate()\r\n              });\r\n              picker.$updateSelected();\r\n            }\r\n          },\r\n          build: function () {\r\n            // var firstMonth = new Date(viewDate.year, 0, 1);\r\n            var months = [];\r\n            var month;\r\n            var thisMonthDate = new Date((new Date()).getFullYear(), (new Date()).getMonth(), 1);\r\n            var selectedMonth;\r\n            var thisMonth;\r\n            for (var i = 0; i < 12; i++) {\r\n              month = new Date(viewDate.year, i, 1);\r\n\r\n              var monthItem = {\r\n                date: month,\r\n                label: formatDate(month, this.format),\r\n                selected: picker.$isSelected(month),\r\n                isToday: month.getFullYear() === thisMonthDate.getFullYear() && month.getMonth() === thisMonthDate.getMonth(),\r\n                disabled: this.isDisabled(month)\r\n              };\r\n\r\n              if (monthItem.selected) selectedMonth = monthItem;\r\n              if (monthItem.isToday) thisMonth = monthItem;\r\n\r\n              months.push(monthItem);\r\n            }\r\n\r\n            scope.selected = null;\r\n\r\n            var defaultFirstDayTabIndex = false;\r\n            // Setup the focusing\r\n            if (options.focusOnOpen) {\r\n              if (selectedMonth) {\r\n                scope.selectedDayId = selectedMonth.id;\r\n                if (thisMonth) thisMonth.focused = false;\r\n                // Needs to fire after the today focusing is unset in case the selected day is today.\r\n                selectedMonth.focused = true;\r\n                scope.selected = selectedMonth;\r\n              } else if (thisMonth) {\r\n                thisMonth.focused = true;\r\n              } else {\r\n                defaultFirstDayTabIndex = true;\r\n              }\r\n            }\r\n\r\n            scope.title = formatDate(month, options.yearTitleFormat);\r\n            scope.showLabels = false;\r\n            scope.rows = split(months, this.split);\r\n            if (defaultFirstDayTabIndex) {\r\n              scope.rows[0][0].isNext = true;\r\n            }\r\n            scope.$modeLabel = options.labelYear;\r\n            this.built = true;\r\n          },\r\n          isSelected: function (date) {\r\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth();\r\n          },\r\n          isDisabled: function (date) {\r\n            var lastDate = +new Date(date.getFullYear(), date.getMonth() + 1, 0);\r\n            return lastDate < options.minDate || date.getTime() > options.maxDate;\r\n          },\r\n          onKeyDown: function (evt) {\r\n            // If the picker doesn't have a date selected and the event comes from the today TD\r\n            // then set the picker's $date to today and set the actual time to its value.\r\n            if (options.keyboard &&\r\n              options.focusOnOpen &&\r\n              !picker.$date &&\r\n              angular.element(evt.target).find('span').hasClass('btn-today')) {\r\n              picker.$date = new Date((new Date()).getFullYear(), (new Date()).getMonth(), 1);\r\n            }\r\n\r\n            if (!picker.$date) {\r\n              return;\r\n            }\r\n            var actualMonth = picker.$date.getMonth();\r\n            var newDate = new Date(picker.$date);\r\n\r\n            if (evt.keyCode === 37) newDate.setMonth(actualMonth - 1);\r\n            else if (evt.keyCode === 38) newDate.setMonth(actualMonth - 4);\r\n            else if (evt.keyCode === 39) newDate.setMonth(actualMonth + 1);\r\n            else if (evt.keyCode === 40) newDate.setMonth(actualMonth + 4);\r\n\r\n            if (options.focusOnOpen && evt.keyCode === 13) picker.select(new Date(picker.$date));\r\n            else if (!this.isDisabled(newDate)) picker.select(newDate, true);\r\n          }\r\n        }, {\r\n          name: 'year',\r\n          format: options.yearFormat,\r\n          split: 4,\r\n          steps: {\r\n            year: 12\r\n          },\r\n          update: function (date, force) {\r\n            if (!this.built || force || parseInt(date.getFullYear() / 20, 10) !== parseInt(viewDate.year / 20, 10)) {\r\n              angular.extend(viewDate, {\r\n                year: picker.$date.getFullYear(),\r\n                month: picker.$date.getMonth(),\r\n                date: picker.$date.getDate()\r\n              });\r\n              picker.$build();\r\n            } else if (date.getFullYear() !== viewDate.year) {\r\n              angular.extend(viewDate, {\r\n                year: picker.$date.getFullYear(),\r\n                month: picker.$date.getMonth(),\r\n                date: picker.$date.getDate()\r\n              });\r\n              picker.$updateSelected();\r\n            }\r\n          },\r\n          build: function () {\r\n            var firstYear = viewDate.year - viewDate.year % (this.split * 3);\r\n            var years = [];\r\n            var year;\r\n            var selectedYear;\r\n            var thisYear;\r\n            for (var i = 0; i < 12; i++) {\r\n              year = new Date(firstYear + i, 0, 1);\r\n\r\n              var yearItem = {\r\n                date: year,\r\n                label: formatDate(year, this.format),\r\n                selected: picker.$isSelected(year),\r\n                isToday: year.getFullYear() === (new Date()).getFullYear(),\r\n                disabled: this.isDisabled(year)\r\n              };\r\n\r\n              if (yearItem.selected) selectedYear = yearItem;\r\n              if (yearItem.isToday) thisYear = yearItem;\r\n\r\n              years.push(yearItem);\r\n            }\r\n\r\n            scope.selected = null;\r\n\r\n            var defaultFirstDayTabIndex = false;\r\n            // Setup the focusing\r\n            if (options.focusOnOpen) {\r\n              if (selectedYear) {\r\n                scope.selectedDayId = selectedYear.id;\r\n                if (thisYear) thisYear.focused = false;\r\n                // Needs to fire after the today focusing is unset in case the selected day is today.\r\n                selectedYear.focused = true;\r\n                scope.selected = selectedYear;\r\n              } else if (thisYear) {\r\n                thisYear.focused = true;\r\n              } else {\r\n                defaultFirstDayTabIndex = true;\r\n              }\r\n            }\r\n\r\n            scope.title = years[0].label + '-' + years[years.length - 1].label;\r\n            scope.showLabels = false;\r\n            scope.rows = split(years, this.split);\r\n            if (defaultFirstDayTabIndex) {\r\n              scope.rows[0][0].isNext = true;\r\n            }\r\n            scope.$modelLabel = options.labelDays;\r\n            this.built = true;\r\n          },\r\n          isSelected: function (date) {\r\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear();\r\n          },\r\n          isDisabled: function (date) {\r\n            var lastDate = +new Date(date.getFullYear() + 1, 0, 0);\r\n            return lastDate < options.minDate || date.getTime() > options.maxDate;\r\n          },\r\n          onKeyDown: function (evt) {\r\n            // If the picker doesn't have a date selected and the event comes from the today TD\r\n            // then set the picker's $date to today and set the actual time to its value.\r\n            if (options.keyboard &&\r\n              options.focusOnOpen &&\r\n              !picker.$date &&\r\n              angular.element(evt.target).find('span').hasClass('btn-today')) {\r\n              picker.$date = new Date((new Date()).getFullYear(), 0, 1);\r\n            }\r\n\r\n            if (!picker.$date) {\r\n              return;\r\n            }\r\n            var actualYear = picker.$date.getFullYear();\r\n            var newDate = new Date(picker.$date);\r\n\r\n            if (evt.keyCode === 37) newDate.setYear(actualYear - 1);\r\n            else if (evt.keyCode === 38) newDate.setYear(actualYear - 4);\r\n            else if (evt.keyCode === 39) newDate.setYear(actualYear + 1);\r\n            else if (evt.keyCode === 40) newDate.setYear(actualYear + 4);\r\n\r\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\r\n          }\r\n        }];\r\n\r\n        return {\r\n          views: options.minView ? Array.prototype.slice.call(views, options.minView) : views,\r\n          viewDate: viewDate\r\n        };\r\n\r\n      };\r\n\r\n    };\r\n\r\n  });\r\n\r\n// Source: collapse\\collapse.js\r\nangular.module('mgcrea.ngStrap.collapse', [])\r\n\r\n  .provider('$collapse', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-collapse',\r\n      disallowToggle: false,\r\n      activeClass: 'in',\r\n      startCollapsed: false,\r\n      allowMultiple: false\r\n    };\r\n\r\n    var controller = this.controller = function ($scope, $element, $attrs) {\r\n      var self = this;\r\n\r\n      // Attributes options\r\n      self.$options = angular.copy(defaults);\r\n      angular.forEach(['animation', 'disallowToggle', 'activeClass', 'startCollapsed', 'allowMultiple'], function (key) {\r\n        if (angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\r\n      });\r\n\r\n      // use string regex match boolean attr falsy values, leave truthy values be\r\n      var falseValueRegExp = /^(false|0|)$/i;\r\n      angular.forEach(['disallowToggle', 'startCollapsed', 'allowMultiple'], function (key) {\r\n        if (angular.isDefined($attrs[key]) && falseValueRegExp.test($attrs[key])) {\r\n          self.$options[key] = false;\r\n        }\r\n      });\r\n\r\n      self.$toggles = [];\r\n      self.$targets = [];\r\n\r\n      self.$viewChangeListeners = [];\r\n\r\n      self.$registerToggle = function (element) {\r\n        self.$toggles.push(element);\r\n        element.attr('aria-expanded', 'false');\r\n      };\r\n      self.$registerTarget = function (element) {\r\n        self.$targets.push(element);\r\n\r\n        var i = 0;\r\n        if (self.$targets) {\r\n          for (i = 0; i < self.$targets.length; i++) {\r\n            self.$targets[i].attr('aria-hidden', 'true');\r\n          }\r\n          for (i = 0; i < self.$targets.$active.length; i++) {\r\n            if (self.$targets[self.$targets.$active[i]]) {\r\n              self.$targets[self.$targets.$active[i]].attr('aria-hidden', 'false');\r\n            }\r\n            if (self.$toggles[self.$targets.$active[i]]) {\r\n              self.$toggles[self.$targets.$active[i]].attr('aria-expanded', 'true');\r\n            }\r\n          }\r\n        }\r\n      };\r\n\r\n      self.$unregisterToggle = function (element) {\r\n        var index = self.$toggles.indexOf(element);\r\n        // remove toggle from $toggles array\r\n        self.$toggles.splice(index, 1);\r\n      };\r\n      self.$unregisterTarget = function (element) {\r\n        var index = self.$targets.indexOf(element);\r\n\r\n        // remove element from $targets array\r\n        self.$targets.splice(index, 1);\r\n\r\n        if (self.$options.allowMultiple) {\r\n          // remove target index from $active array values\r\n          deactivateItem(element);\r\n        }\r\n\r\n        // fix active item indexes\r\n        fixActiveItemIndexes(index);\r\n\r\n        self.$viewChangeListeners.forEach(function (fn) {\r\n          fn();\r\n        });\r\n      };\r\n\r\n      // use array to store all the currently open panels\r\n      self.$targets.$active = !self.$options.startCollapsed ? [0] : [];\r\n      self.$setActive = $scope.$setActive = function (value) {\r\n        if (angular.isArray(value)) {\r\n          self.$targets.$active = value;\r\n        } else if (!self.$options.disallowToggle && isActive(value)) {\r\n          deactivateItem(value);\r\n        } else {\r\n          activateItem(value);\r\n        }\r\n\r\n        self.$viewChangeListeners.forEach(function (fn) {\r\n          fn();\r\n        });\r\n      };\r\n\r\n      self.$activeIndexes = function () {\r\n        if (self.$options.allowMultiple) {\r\n          return self.$targets.$active;\r\n        }\r\n        return self.$targets.$active.length === 1 ? self.$targets.$active[0] : -1;\r\n      };\r\n\r\n      function fixActiveItemIndexes (index) {\r\n        // item with index was removed, so we\r\n        // need to adjust other items index values\r\n        var activeIndexes = self.$targets.$active;\r\n        for (var i = 0; i < activeIndexes.length; i++) {\r\n          if (index < activeIndexes[i]) {\r\n            activeIndexes[i] = activeIndexes[i] - 1;\r\n          }\r\n\r\n          // the last item is active, so we need to\r\n          // adjust its index\r\n          if (activeIndexes[i] === self.$targets.length) {\r\n            activeIndexes[i] = self.$targets.length - 1;\r\n          }\r\n        }\r\n      }\r\n\r\n      function isActive (value) {\r\n        var activeItems = self.$targets.$active;\r\n        return activeItems.indexOf(value) !== -1;\r\n      }\r\n\r\n      function deactivateItem (value) {\r\n        var index = self.$targets.$active.indexOf(value);\r\n        if (index !== -1) {\r\n          self.$targets[self.$targets.$active[index]].attr('aria-hidden', 'true');\r\n          self.$toggles[self.$targets.$active[index]].attr('aria-expanded', 'false');\r\n          self.$targets.$active.splice(index, 1);\r\n        }\r\n      }\r\n\r\n      function activateItem (value) {\r\n        if (!self.$options.allowMultiple) {\r\n          // remove current selected item\r\n          if (self.$targets[self.$targets.$active[0]] !== undefined) {\r\n            self.$targets[self.$targets.$active[0]].attr('aria-hidden', 'true');\r\n          }\r\n          if (self.$toggles[self.$targets.$active[0]]) {\r\n            self.$toggles[self.$targets.$active[0]].attr('aria-expanded', 'false');\r\n          }\r\n          self.$targets.$active.splice(0, 1);\r\n        }\r\n\r\n        if (self.$targets.$active.indexOf(value) === -1) {\r\n          self.$targets.$active.push(value);\r\n\r\n          if (self.$targets[self.$targets.$active[self.$targets.$active.length - 1]] !== undefined) {\r\n            self.$targets[self.$targets.$active[self.$targets.$active.length - 1]].attr('aria-hidden', 'false');\r\n          }\r\n          if (self.$toggles[self.$targets.$active[self.$targets.$active.length - 1]] !== undefined) {\r\n            self.$toggles[self.$targets.$active[self.$targets.$active.length - 1]].attr('aria-expanded', 'true');\r\n          }\r\n        }\r\n      }\r\n\r\n    };\r\n\r\n    this.$get = function () {\r\n      var $collapse = {};\r\n      $collapse.defaults = defaults;\r\n      $collapse.controller = controller;\r\n      return $collapse;\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsCollapse', function ($window, $animate, $collapse) {\r\n\r\n    return {\r\n      require: ['?ngModel', 'bsCollapse'],\r\n      controller: ['$scope', '$element', '$attrs', $collapse.controller],\r\n      link: function postLink (scope, element, attrs, controllers) {\r\n\r\n        var ngModelCtrl = controllers[0];\r\n        var bsCollapseCtrl = controllers[1];\r\n\r\n        if (ngModelCtrl) {\r\n\r\n          // Update the modelValue following\r\n          bsCollapseCtrl.$viewChangeListeners.push(function () {\r\n            ngModelCtrl.$setViewValue(bsCollapseCtrl.$activeIndexes());\r\n          });\r\n\r\n          // modelValue -> $formatters -> viewValue\r\n          ngModelCtrl.$formatters.push(function (modelValue) {\r\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n            if (angular.isArray(modelValue)) {\r\n              // model value is an array, so just replace\r\n              // the active items directly\r\n              bsCollapseCtrl.$setActive(modelValue);\r\n            } else {\r\n              var activeIndexes = bsCollapseCtrl.$activeIndexes();\r\n\r\n              if (angular.isArray(activeIndexes)) {\r\n                // we have an array of selected indexes\r\n                if (activeIndexes.indexOf(modelValue * 1) === -1) {\r\n                  // item with modelValue index is not active\r\n                  bsCollapseCtrl.$setActive(modelValue * 1);\r\n                }\r\n              } else if (activeIndexes !== modelValue * 1) {\r\n                bsCollapseCtrl.$setActive(modelValue * 1);\r\n              }\r\n            }\r\n            return modelValue;\r\n          });\r\n\r\n        }\r\n\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsCollapseToggle', function () {\r\n    var KEY_CODES = {\r\n      ENTER: 13,\r\n      SPACE: 32\r\n    };\r\n    return {\r\n      require: ['^?ngModel', '^bsCollapse'],\r\n      link: function postLink (scope, element, attrs, controllers) {\r\n\r\n        // var ngModelCtrl = controllers[0];\r\n        var bsCollapseCtrl = controllers[1];\r\n\r\n        // Add base attr\r\n        element.attr('data-toggle', 'collapse');\r\n\r\n        // Push pane to parent bsCollapse controller\r\n        bsCollapseCtrl.$registerToggle(element);\r\n\r\n        // remove toggle from collapse controller when toggle is destroyed\r\n        scope.$on('$destroy', function () {\r\n          bsCollapseCtrl.$unregisterToggle(element);\r\n        });\r\n\r\n        var actionEventHandler = function () {\r\n          if (!attrs.disabled) {\r\n            var index = attrs.bsCollapseToggle && attrs.bsCollapseToggle !== 'bs-collapse-toggle' ? attrs.bsCollapseToggle : bsCollapseCtrl.$toggles.indexOf(element);\r\n            bsCollapseCtrl.$setActive(index * 1);\r\n            scope.$apply();\r\n          }\r\n        };\r\n\r\n        element.on('click', actionEventHandler);\r\n        element.bind('keydown keypress', function (e) {\r\n          if (e.which === KEY_CODES.ENTER || e.which === KEY_CODES.SPACE) {\r\n            console.log('key handler handling');\r\n            actionEventHandler();\r\n            e.preventDefault();\r\n          }\r\n        });\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsCollapseTarget', function ($animate) {\r\n\r\n    return {\r\n      require: ['^?ngModel', '^bsCollapse'],\r\n      // scope: true,\r\n      link: function postLink (scope, element, attrs, controllers) {\r\n\r\n        // var ngModelCtrl = controllers[0];\r\n        var bsCollapseCtrl = controllers[1];\r\n\r\n        // Add base class\r\n        element.addClass('collapse');\r\n\r\n        // Add animation class\r\n        if (bsCollapseCtrl.$options.animation) {\r\n          element.addClass(bsCollapseCtrl.$options.animation);\r\n        }\r\n\r\n        // Push pane to parent bsCollapse controller\r\n        bsCollapseCtrl.$registerTarget(element);\r\n\r\n        // remove pane target from collapse controller when target is destroyed\r\n        scope.$on('$destroy', function () {\r\n          bsCollapseCtrl.$unregisterTarget(element);\r\n        });\r\n\r\n        function render () {\r\n          var index = bsCollapseCtrl.$targets.indexOf(element);\r\n          var active = bsCollapseCtrl.$activeIndexes();\r\n          var action = 'removeClass';\r\n          if (angular.isArray(active)) {\r\n            if (active.indexOf(index) !== -1) {\r\n              action = 'addClass';\r\n            }\r\n          } else if (index === active) {\r\n            action = 'addClass';\r\n          }\r\n\r\n          $animate[action](element, bsCollapseCtrl.$options.activeClass);\r\n        }\r\n\r\n        bsCollapseCtrl.$viewChangeListeners.push(function () {\r\n          render();\r\n        });\r\n        render();\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n\r\n// Source: aside\\aside.js\r\nangular.module('mgcrea.ngStrap.aside', ['mgcrea.ngStrap.modal'])\r\n\r\n  .provider('$aside', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade-and-slide-right',\r\n      prefixClass: 'aside',\r\n      prefixEvent: 'aside',\r\n      placement: 'right',\r\n      templateUrl: 'aside/aside.tpl.html',\r\n      contentTemplate: false,\r\n      container: false,\r\n      element: null,\r\n      backdrop: true,\r\n      keyboard: true,\r\n      html: false,\r\n      show: true\r\n    };\r\n\r\n    this.$get = function ($modal) {\r\n\r\n      function AsideFactory (config) {\r\n\r\n        var $aside = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n\r\n        $aside = $modal(options);\r\n\r\n        return $aside;\r\n\r\n      }\r\n\r\n      return AsideFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsAside', function ($window, $sce, $aside) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink (scope, element, attr, transclusion) {\r\n        // Directive options\r\n        var options = {scope: scope, element: element, show: false};\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['backdrop', 'keyboard', 'html', 'container'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Support scope as data-attrs\r\n        angular.forEach(['title', 'content'], function (key) {\r\n          if (attr[key]) {\r\n            attr.$observe(key, function (newValue, oldValue) {\r\n              scope[key] = $sce.trustAsHtml(newValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Support scope as an object\r\n        if (attr.bsAside) {\r\n          scope.$watch(attr.bsAside, function (newValue, oldValue) {\r\n            if (angular.isObject(newValue)) {\r\n              angular.extend(scope, newValue);\r\n            } else {\r\n              scope.content = newValue;\r\n            }\r\n          }, true);\r\n        }\r\n\r\n        // Initialize aside\r\n        var aside = $aside(options);\r\n\r\n        // Trigger\r\n        element.on(attr.trigger || 'click', aside.toggle);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (aside) aside.destroy();\r\n          options = null;\r\n          aside = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n\r\n// Source: alert\\alert.js\r\n// @BUG: following snippet won't compile correctly\r\n\r\nangular.module('mgcrea.ngStrap.alert', ['mgcrea.ngStrap.modal'])\r\n\r\n  .provider('$alert', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      prefixClass: 'alert',\r\n      prefixEvent: 'alert',\r\n      placement: null,\r\n      templateUrl: 'alert/alert.tpl.html',\r\n      container: false,\r\n      element: null,\r\n      backdrop: false,\r\n      keyboard: true,\r\n      show: true,\r\n      // Specific options\r\n      duration: false,\r\n      type: false,\r\n      dismissable: true\r\n    };\r\n\r\n    this.$get = function ($modal, $timeout) {\r\n\r\n      function AlertFactory (config) {\r\n\r\n        var $alert = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n\r\n        $alert = $modal(options);\r\n\r\n        // Support scope as string options [/*title, content, */ type, dismissable]\r\n        $alert.$scope.dismissable = !!options.dismissable;\r\n        if (options.type) {\r\n          $alert.$scope.type = options.type;\r\n        }\r\n\r\n        // Support auto-close duration\r\n        var show = $alert.show;\r\n        if (options.duration) {\r\n          $alert.show = function () {\r\n            show();\r\n            $timeout(function () {\r\n              $alert.hide();\r\n            }, options.duration * 1000);\r\n          };\r\n        }\r\n\r\n        return $alert;\r\n\r\n      }\r\n\r\n      return AlertFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsAlert', function ($window, $sce, $alert) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink (scope, element, attr, transclusion) {\r\n\r\n        // Directive options\r\n        var options = {scope: scope, element: element, show: false};\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'keyboard', 'html', 'container', 'animation', 'duration', 'dismissable'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['keyboard', 'html', 'container', 'dismissable'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // overwrite inherited title value when no value specified\r\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\r\n        if (!scope.hasOwnProperty('title')) {\r\n          scope.title = '';\r\n        }\r\n\r\n        // Support scope as data-attrs\r\n        angular.forEach(['title', 'content', 'type'], function (key) {\r\n          if (attr[key]) {\r\n            attr.$observe(key, function (newValue, oldValue) {\r\n              scope[key] = $sce.trustAsHtml(newValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Support scope as an object\r\n        if (attr.bsAlert) {\r\n          scope.$watch(attr.bsAlert, function (newValue, oldValue) {\r\n            if (angular.isObject(newValue)) {\r\n              angular.extend(scope, newValue);\r\n            } else {\r\n              scope.content = newValue;\r\n            }\r\n          }, true);\r\n        }\r\n\r\n        // Initialize alert\r\n        var alert = $alert(options);\r\n\r\n        // Trigger\r\n        element.on(attr.trigger || 'click', alert.toggle);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (alert) alert.destroy();\r\n          options = null;\r\n          alert = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n\r\n// Source: affix\\affix.js\r\nangular.module('mgcrea.ngStrap.affix', ['mgcrea.ngStrap.helpers.dimensions', 'mgcrea.ngStrap.helpers.debounce'])\r\n\r\n  .provider('$affix', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      offsetTop: 'auto',\r\n      inlineStyles: true,\r\n      setWidth: true\r\n    };\r\n\r\n    this.$get = function ($window, debounce, dimensions) {\r\n\r\n      var bodyEl = angular.element($window.document.body);\r\n      var windowEl = angular.element($window);\r\n\r\n      function AffixFactory (element, config) {\r\n\r\n        var $affix = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n        var targetEl = options.target;\r\n\r\n        // Initial private vars\r\n        var reset = 'affix affix-top affix-bottom';\r\n        var setWidth = false;\r\n        var initialAffixTop = 0;\r\n        var initialOffsetTop = 0;\r\n        var offsetTop = 0;\r\n        var offsetBottom = 0;\r\n        var affixed = null;\r\n        var unpin = null;\r\n\r\n        var parent = element.parent();\r\n        // Options: custom parent\r\n        if (options.offsetParent) {\r\n          if (options.offsetParent.match(/^\\d+$/)) {\r\n            for (var i = 0; i < (options.offsetParent * 1) - 1; i++) {\r\n              parent = parent.parent();\r\n            }\r\n          } else {\r\n            parent = angular.element(options.offsetParent);\r\n          }\r\n        }\r\n\r\n        $affix.init = function () {\r\n\r\n          this.$parseOffsets();\r\n          initialOffsetTop = dimensions.offset(element[0]).top + initialAffixTop;\r\n          setWidth = options.setWidth && !element[0].style.width;\r\n\r\n          // Bind events\r\n          targetEl.on('scroll', this.checkPosition);\r\n          targetEl.on('click', this.checkPositionWithEventLoop);\r\n          windowEl.on('resize', this.$debouncedOnResize);\r\n\r\n          // Both of these checkPosition() calls are necessary for the case where\r\n          // the user hits refresh after scrolling to the bottom of the page.\r\n          this.checkPosition();\r\n          this.checkPositionWithEventLoop();\r\n\r\n        };\r\n\r\n        $affix.destroy = function () {\r\n\r\n          // Unbind events\r\n          targetEl.off('scroll', this.checkPosition);\r\n          targetEl.off('click', this.checkPositionWithEventLoop);\r\n          windowEl.off('resize', this.$debouncedOnResize);\r\n\r\n        };\r\n\r\n        $affix.checkPositionWithEventLoop = function () {\r\n\r\n          // IE 9 throws an error if we use 'this' instead of '$affix'\r\n          // in this setTimeout call\r\n          setTimeout($affix.checkPosition, 1);\r\n\r\n        };\r\n\r\n        $affix.checkPosition = function () {\r\n          // if (!this.$element.is(':visible')) return\r\n\r\n          var scrollTop = getScrollTop();\r\n          var position = dimensions.offset(element[0]);\r\n          var elementHeight = dimensions.height(element[0]);\r\n\r\n          // Get required affix class according to position\r\n          var affix = getRequiredAffixClass(unpin, position, elementHeight);\r\n\r\n          // Did affix status changed this last check?\r\n          if (affixed === affix) return;\r\n          affixed = affix;\r\n\r\n          if (affix === 'top') {\r\n            unpin = null;\r\n            if (setWidth) {\r\n              element.css('width', '');\r\n            }\r\n            if (options.inlineStyles) {\r\n              element.css('position', (options.offsetParent) ? '' : 'relative');\r\n              element.css('top', '');\r\n            }\r\n          } else if (affix === 'bottom') {\r\n            if (options.offsetUnpin) {\r\n              unpin = -(options.offsetUnpin * 1);\r\n            } else {\r\n              // Calculate unpin threshold when affixed to bottom.\r\n              // Hopefully the browser scrolls pixel by pixel.\r\n              unpin = position.top - scrollTop;\r\n            }\r\n            if (setWidth) {\r\n              element.css('width', '');\r\n            }\r\n            if (options.inlineStyles) {\r\n              element.css('position', (options.offsetParent) ? '' : 'relative');\r\n              element.css('top', (options.offsetParent) ? '' : ((bodyEl[0].offsetHeight - offsetBottom - elementHeight - initialOffsetTop) + 'px'));\r\n            }\r\n          } else { // affix === 'middle'\r\n            unpin = null;\r\n            if (setWidth) {\r\n              element.css('width', element[0].offsetWidth + 'px');\r\n            }\r\n            if (options.inlineStyles) {\r\n              element.css('position', 'fixed');\r\n              element.css('top', initialAffixTop + 'px');\r\n            }\r\n          }\r\n\r\n          // Add proper affix class\r\n          element.removeClass(reset).addClass('affix' + ((affix !== 'middle') ? '-' + affix : ''));\r\n\r\n        };\r\n\r\n        $affix.$onResize = function () {\r\n          $affix.$parseOffsets();\r\n          $affix.checkPosition();\r\n        };\r\n        $affix.$debouncedOnResize = debounce($affix.$onResize, 50);\r\n\r\n        $affix.$parseOffsets = function () {\r\n          var initialPosition = element[0].style.position;\r\n          var initialTop = element[0].style.top;\r\n          // Reset position to calculate correct offsetTop\r\n          if (options.inlineStyles) {\r\n            element.css('position', (options.offsetParent) ? '' : 'relative');\r\n            element.css('top', '');\r\n          }\r\n\r\n          if (options.offsetTop) {\r\n            if (options.offsetTop === 'auto') {\r\n              options.offsetTop = '+0';\r\n            }\r\n            if (options.offsetTop.match(/^[-+]\\d+$/)) {\r\n              initialAffixTop = - options.offsetTop * 1;\r\n              if (options.offsetParent) {\r\n                offsetTop = dimensions.offset(parent[0]).top + (options.offsetTop * 1);\r\n              } else {\r\n                offsetTop = dimensions.offset(element[0]).top - dimensions.css(element[0], 'marginTop', true) + (options.offsetTop * 1);\r\n              }\r\n            } else {\r\n              offsetTop = options.offsetTop * 1;\r\n            }\r\n          }\r\n\r\n          if (options.offsetBottom) {\r\n            if (options.offsetParent && options.offsetBottom.match(/^[-+]\\d+$/)) {\r\n              // add 1 pixel due to rounding problems...\r\n              offsetBottom = getScrollHeight() - (dimensions.offset(parent[0]).top + dimensions.height(parent[0])) + (options.offsetBottom * 1) + 1;\r\n            } else {\r\n              offsetBottom = options.offsetBottom * 1;\r\n            }\r\n          }\r\n\r\n          // Bring back the element's position after calculations\r\n          if (options.inlineStyles) {\r\n            element.css('position', initialPosition);\r\n            element.css('top', initialTop);\r\n          }\r\n        };\r\n\r\n        // Private methods\r\n\r\n        function getRequiredAffixClass (_unpin, position, elementHeight) {\r\n          var scrollTop = getScrollTop();\r\n          var scrollHeight = getScrollHeight();\r\n\r\n          if (scrollTop <= offsetTop) {\r\n            return 'top';\r\n          } else if (_unpin !== null) {\r\n            return scrollTop + _unpin <= position.top ? 'middle' : 'bottom';\r\n          } else if (offsetBottom !== null && (position.top + elementHeight + initialAffixTop >= scrollHeight - offsetBottom)) {\r\n            return 'bottom';\r\n          }\r\n          return 'middle';\r\n        }\r\n\r\n        function getScrollTop () {\r\n          return targetEl[0] === $window ? $window.pageYOffset : targetEl[0].scrollTop;\r\n        }\r\n\r\n        function getScrollHeight () {\r\n          return targetEl[0] === $window ? $window.document.body.scrollHeight : targetEl[0].scrollHeight;\r\n        }\r\n\r\n        $affix.init();\r\n        return $affix;\r\n\r\n      }\r\n\r\n      return AffixFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsAffix', function ($affix, $window, $timeout) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      require: '^?bsAffixTarget',\r\n      link: function postLink (scope, element, attr, affixTarget) {\r\n\r\n        var options = {scope: scope, target: affixTarget ? affixTarget.$element : angular.element($window)};\r\n        angular.forEach(['offsetTop', 'offsetBottom', 'offsetParent', 'offsetUnpin', 'inlineStyles', 'setWidth'], function (key) {\r\n          if (angular.isDefined(attr[key])) {\r\n            var option = attr[key];\r\n            if (/true/i.test(option)) option = true;\r\n            if (/false/i.test(option)) option = false;\r\n            options[key] = option;\r\n          }\r\n        });\r\n\r\n        var affix;\r\n        $timeout(function () { affix = $affix(element, options); });\r\n        scope.$on('$destroy', function () {\r\n          if (affix) affix.destroy();\r\n          options = null;\r\n          affix = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsAffixTarget', function () {\r\n    return {\r\n      controller: function ($element) {\r\n        this.$element = $element;\r\n      }\r\n    };\r\n  });\r\n\r\n// Source: module.js\r\nangular.module('mgcrea.ngStrap', [\r\n  'mgcrea.ngStrap.modal',\r\n  'mgcrea.ngStrap.aside',\r\n  'mgcrea.ngStrap.alert',\r\n  'mgcrea.ngStrap.button',\r\n  'mgcrea.ngStrap.select',\r\n  'mgcrea.ngStrap.datepicker',\r\n  'mgcrea.ngStrap.timepicker',\r\n  'mgcrea.ngStrap.navbar',\r\n  'mgcrea.ngStrap.tooltip',\r\n  'mgcrea.ngStrap.popover',\r\n  'mgcrea.ngStrap.dropdown',\r\n  'mgcrea.ngStrap.typeahead',\r\n  'mgcrea.ngStrap.scrollspy',\r\n  'mgcrea.ngStrap.affix',\r\n  'mgcrea.ngStrap.tab',\r\n  'mgcrea.ngStrap.collapse'\r\n]);\r\n\r\n})(window, document);\r\n","'use strict';\r\n\r\n// NOTICE: This file was forked from the angular-material project (github.com/angular/material)\r\n// MIT Licensed - Copyright (c) 2014-2015 Google, Inc. http://angularjs.org\r\n\r\nangular.module('mgcrea.ngStrap.core', [])\r\n  .service('$bsCompiler', bsCompilerService);\r\n\r\nfunction bsCompilerService ($q, $http, $injector, $compile, $controller, $templateCache) {\r\n\r\n  /*\r\n   * @ngdoc service\r\n   * @name $bsCompiler\r\n   * @module material.core\r\n   * @description\r\n   * The $bsCompiler service is an abstraction of angular's compiler, that allows the developer\r\n   * to easily compile an element with a templateUrl, controller, and locals.\r\n   *\r\n   * @usage\r\n   * <hljs lang=\"js\">\r\n   * $bsCompiler.compile({\r\n   *   templateUrl: 'modal.html',\r\n   *   controller: 'ModalCtrl',\r\n   *   locals: {\r\n   *     modal: myModalInstance;\r\n   *   }\r\n   * }).then(function(compileData) {\r\n   *   compileData.element; // modal.html's template in an element\r\n   *   compileData.link(myScope); //attach controller & scope to element\r\n   * });\r\n   * </hljs>\r\n   */\r\n\r\n   /*\r\n    * @ngdoc method\r\n    * @name $bsCompiler#compile\r\n    * @description A helper to compile an HTML template/templateUrl with a given controller,\r\n    * locals, and scope.\r\n    * @param {object} options An options object, with the following properties:\r\n    *\r\n    *    - `controller` - `{(string=|function()=}` Controller fn that should be associated with\r\n    *      newly created scope or the name of a registered controller if passed as a string.\r\n    *    - `controllerAs` - `{string=}` A controller alias name. If present the controller will be\r\n    *      published to scope under the `controllerAs` name.\r\n    *    - `template` - `{string=}` An html template as a string.\r\n    *    - `templateUrl` - `{string=}` A path to an html template.\r\n    *    - `transformTemplate` - `{function(template)=}` A function which transforms the template after\r\n    *      it is loaded. It will be given the template string as a parameter, and should\r\n    *      return a a new string representing the transformed template.\r\n    *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should\r\n    *      be injected into the controller. If any of these dependencies are promises, the compiler\r\n    *      will wait for them all to be resolved, or if one is rejected before the controller is\r\n    *      instantiated `compile()` will fail..\r\n    *      * `key` - `{string}`: a name of a dependency to be injected into the controller.\r\n    *      * `factory` - `{string|function}`: If `string` then it is an alias for a service.\r\n    *        Otherwise if function, then it is injected and the return value is treated as the\r\n    *        dependency. If the result is a promise, it is resolved before its value is\r\n    *        injected into the controller.\r\n    *\r\n    * @returns {object=} promise A promise, which will be resolved with a `compileData` object.\r\n    * `compileData` has the following properties:\r\n    *\r\n    *   - `element` - `{element}`: an uncompiled element matching the provided template.\r\n    *   - `link` - `{function(scope)}`: A link function, which, when called, will compile\r\n    *     the element and instantiate the provided controller (if given).\r\n    *   - `locals` - `{object}`: The locals which will be passed into the controller once `link` is\r\n    *     called. If `bindToController` is true, they will be coppied to the ctrl instead\r\n    *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in.\r\n    */\r\n  this.compile = function (options) {\r\n\r\n    if (options.template && /\\.html$/.test(options.template)) {\r\n      console.warn('Deprecated use of `template` option to pass a file. Please use the `templateUrl` option instead.');\r\n      options.templateUrl = options.template;\r\n      options.template = '';\r\n    }\r\n\r\n    var templateUrl = options.templateUrl;\r\n    var template = options.template || '';\r\n    var controller = options.controller;\r\n    var controllerAs = options.controllerAs;\r\n    var resolve = options.resolve || {};\r\n    var locals = options.locals || {};\r\n    var transformTemplate = options.transformTemplate || angular.identity;\r\n    var bindToController = options.bindToController;\r\n\r\n    // Take resolve values and invoke them.\r\n    // Resolves can either be a string (value: 'MyRegisteredAngularConst'),\r\n    // or an invokable 'factory' of sorts: (value: function ValueGetter($dependency) {})\r\n    angular.forEach(resolve, function (value, key) {\r\n      if (angular.isString(value)) {\r\n        resolve[key] = $injector.get(value);\r\n      } else {\r\n        resolve[key] = $injector.invoke(value);\r\n      }\r\n    });\r\n    // Add the locals, which are just straight values to inject\r\n    // eg locals: { three: 3 }, will inject three into the controller\r\n    angular.extend(resolve, locals);\r\n\r\n    if (template) {\r\n      resolve.$template = $q.when(template);\r\n    } else if (templateUrl) {\r\n      resolve.$template = fetchTemplate(templateUrl);\r\n    } else {\r\n      throw new Error('Missing `template` / `templateUrl` option.');\r\n    }\r\n\r\n    if (options.titleTemplate) {\r\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.titleTemplate)])\r\n        .then(function (templates) {\r\n          var templateEl = angular.element(templates[0]);\r\n          findElement('[ng-bind=\"title\"]', templateEl[0])\r\n            .removeAttr('ng-bind')\r\n            .html(templates[1]);\r\n          return templateEl[0].outerHTML;\r\n        });\r\n    }\r\n\r\n    if (options.contentTemplate) {\r\n      // TODO(mgcrea): deprecate?\r\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.contentTemplate)])\r\n        .then(function (templates) {\r\n          var templateEl = angular.element(templates[0]);\r\n          var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0])\r\n            .removeAttr('ng-bind')\r\n            .html(templates[1]);\r\n          // Drop the default footer as you probably don't want it if you use a custom contentTemplate\r\n          if (!options.templateUrl) contentEl.next().remove();\r\n          return templateEl[0].outerHTML;\r\n        });\r\n    }\r\n\r\n    // Wait for all the resolves to finish if they are promises\r\n    return $q.all(resolve).then(function (locals) {\r\n\r\n      var template = transformTemplate(locals.$template);\r\n      if (options.html) {\r\n        template = template.replace(/ng-bind=\"/ig, 'ng-bind-html=\"');\r\n      }\r\n      // var element = options.element || angular.element('<div>').html(template.trim()).contents();\r\n      var element = angular.element('<div>').html(template.trim()).contents();\r\n      var linkFn = $compile(element);\r\n\r\n      // Return a linking function that can be used later when the element is ready\r\n      return {\r\n        locals: locals,\r\n        element: element,\r\n        link: function link (scope) {\r\n          locals.$scope = scope;\r\n\r\n          // Instantiate controller if it exists, because we have scope\r\n          if (controller) {\r\n            var invokeCtrl = $controller(controller, locals, true);\r\n            if (bindToController) {\r\n              angular.extend(invokeCtrl.instance, locals);\r\n            }\r\n            // Support angular@~1.2 invokeCtrl\r\n            var ctrl = angular.isObject(invokeCtrl) ? invokeCtrl : invokeCtrl();\r\n            // See angular-route source for this logic\r\n            element.data('$ngControllerController', ctrl);\r\n            element.children().data('$ngControllerController', ctrl);\r\n\r\n            if (controllerAs) {\r\n              scope[controllerAs] = ctrl;\r\n            }\r\n          }\r\n\r\n          return linkFn.apply(null, arguments);\r\n        }\r\n      };\r\n    });\r\n\r\n  };\r\n\r\n  function findElement (query, element) {\r\n    return angular.element((element || document).querySelectorAll(query));\r\n  }\r\n\r\n  var fetchPromises = {};\r\n  function fetchTemplate (template) {\r\n    if (fetchPromises[template]) return fetchPromises[template];\r\n    return (fetchPromises[template] = $http.get(template, {cache: $templateCache})\r\n      .then(function (res) {\r\n        return res.data;\r\n      }));\r\n  }\r\n\r\n}\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.dropdown', ['mgcrea.ngStrap.tooltip'])\r\n\r\n  .provider('$dropdown', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      prefixClass: 'dropdown',\r\n      prefixEvent: 'dropdown',\r\n      placement: 'bottom-left',\r\n      templateUrl: 'dropdown/dropdown.tpl.html',\r\n      trigger: 'click',\r\n      container: false,\r\n      keyboard: true,\r\n      html: false,\r\n      delay: 0\r\n    };\r\n\r\n    this.$get = function ($window, $rootScope, $tooltip, $timeout) {\r\n\r\n      var bodyEl = angular.element($window.document.body);\r\n      var matchesSelector = Element.prototype.matchesSelector || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector;\r\n\r\n      function DropdownFactory (element, config) {\r\n\r\n        var $dropdown = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n        /* var scope = */\r\n        $dropdown.$scope = options.scope && options.scope.$new() || $rootScope.$new();\r\n\r\n        $dropdown = $tooltip(element, options);\r\n        var parentEl = element.parent();\r\n\r\n        if (element && element[0] && element[0].tagName.toUpperCase() === 'BUTTON') {\r\n          element.attr('aria-haspopup', 'true');\r\n          element.attr('data-toggle', 'dropdown');\r\n          element.attr('aria-expanded', 'false');\r\n          element.attr('role', 'button');\r\n        }\r\n\r\n        // Protected methods\r\n\r\n        $dropdown.$onKeyDown = function (evt) {\r\n          if ((/(9)/.test(evt.keyCode) && !options.keyboard) || /27/.test(evt.keyCode)) {\r\n            $dropdown.hide(/27/.test(evt.keyCode));\r\n            return;\r\n          }\r\n          if (!/(38|40)/.test(evt.keyCode)) return;\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n\r\n          // Retrieve focused index\r\n          var items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider) a'));\r\n          if (!items.length) return;\r\n          var index;\r\n          angular.forEach(items, function (el, i) {\r\n            if (matchesSelector && matchesSelector.call(el, ':focus')) index = i;\r\n          });\r\n\r\n          // Navigate with keyboard\r\n          if (evt.keyCode === 38 && index > 0) index--;\r\n          else if (evt.keyCode === 40 && index < items.length - 1) index++;\r\n          else if (evt.keyCode === 40 && index === items.length - 1) index = 0;\r\n          else if (angular.isUndefined(index)) index = 0;\r\n          items.eq(index)[0].focus();\r\n\r\n        };\r\n\r\n        $dropdown.$onFocusOut = function (evt) {\r\n          // find out if the related target's parents contain the datepicker's $element\r\n          var inMenu = false;\r\n          var parent = angular.element(evt.relatedTarget);\r\n          while (parent !== undefined && parent.length && parent[0] !== $window.document.body) {\r\n            parent = parent.parent();\r\n            if (parent !== undefined && parent[0] === $dropdown.$element[0]) {\r\n              inMenu = true;\r\n              break;\r\n            } else {\r\n              inMenu = false;\r\n            }\r\n          }\r\n\r\n          if (!inMenu) {\r\n            $dropdown.hide();\r\n          } else {\r\n            evt.preventDefault();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        // Overrides\r\n\r\n        var show = $dropdown.show;\r\n        $dropdown.show = function () {\r\n          show();\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed imediately.\r\n          $timeout(function () {\r\n            // Set assistive technology properties\r\n            element.attr('aria-expanded', 'true');\r\n            if ($dropdown.$element) {\r\n              $dropdown.$element.attr('aria-hidden', 'false');\r\n              $dropdown.$element.attr('role', 'menu');\r\n              $dropdown.$element.attr('tabindex', '-1');\r\n            }\r\n            if (options.keyboard && $dropdown.$element) {\r\n              $dropdown.$element.on('keydown', $dropdown.$onKeyDown);\r\n              $dropdown.$element.on('focusout', $dropdown.$onFocusOut);\r\n            }\r\n\r\n            bodyEl.on('click', onBodyClick);\r\n\r\n            if ($dropdown.$element) {\r\n              var items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider)'));\r\n              items.attr('role', 'presentation');\r\n\r\n              angular.element($dropdown.$element[0].querySelectorAll('li.divider')).attr('role', 'seperator');\r\n\r\n              items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider) a'));\r\n              items.attr('role', 'menuitem');\r\n              if (items.length && options.keyboard) {\r\n                items[0].focus();\r\n              }\r\n            }\r\n          }, 0, false);\r\n          if (parentEl.hasClass('dropdown')) parentEl.addClass('open');\r\n        };\r\n\r\n        var hide = $dropdown.hide;\r\n        $dropdown.hide = function (returnFocus) {\r\n          if (!$dropdown.$isShown) return;\r\n\r\n          element.attr('aria-expanded', 'true');\r\n          $dropdown.$element.attr('aria-hidden', 'true');\r\n\r\n          if (options.keyboard && $dropdown.$element) {\r\n            $dropdown.$element.off('keydown', $dropdown.$onKeyDown);\r\n            $dropdown.$element.off('focusout', $dropdown.$onFocusOut);\r\n          }\r\n\r\n          bodyEl.off('click', onBodyClick);\r\n          if (parentEl.hasClass('dropdown')) parentEl.removeClass('open');\r\n          $timeout(function () {\r\n            hide();\r\n            if (returnFocus) {\r\n              $timeout(function () {\r\n                if (element && element[0]) {\r\n                  element[0].focus();\r\n                }\r\n              }, 0, false);\r\n            }\r\n          }, 200);\r\n        };\r\n\r\n        var destroy = $dropdown.destroy;\r\n        $dropdown.destroy = function () {\r\n          bodyEl.off('click', onBodyClick);\r\n          destroy();\r\n        };\r\n\r\n        // Private functions\r\n\r\n        function onBodyClick (evt) {\r\n          if (evt.target === element[0]) return undefined;\r\n          return evt.target !== element[0] && $dropdown.hide();\r\n        }\r\n\r\n        return $dropdown;\r\n\r\n      }\r\n\r\n      return DropdownFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsDropdown', function ($window, $sce, $dropdown) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      compile: function (tElement, tAttrs) {\r\n\r\n        // Support for inlined template (next sibling)\r\n        // It must be fetched before compilation\r\n        if (!tAttrs.bsDropdown) {\r\n          var nextSibling = tElement[0].nextSibling;\r\n          while (nextSibling && nextSibling.nodeType !== 1) {\r\n            nextSibling = nextSibling.nextSibling;\r\n          }\r\n          if (nextSibling && nextSibling.className.split(' ').indexOf('dropdown-menu') >= 0) {\r\n            tAttrs.template = nextSibling.outerHTML;\r\n            tAttrs.templateUrl = undefined;\r\n            nextSibling.parentNode.removeChild(nextSibling);\r\n          }\r\n        }\r\n\r\n        return function postLink (scope, element, attr) {\r\n\r\n          // Directive options\r\n          var options = {\r\n            scope: scope\r\n          };\r\n          angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'id', 'autoClose'], function (key) {\r\n            if (angular.isDefined(tAttrs[key])) options[key] = tAttrs[key];\r\n          });\r\n\r\n          // use string regex match boolean attr falsy values, leave truthy values be\r\n          var falseValueRegExp = /^(false|0|)$/i;\r\n          angular.forEach(['html', 'container'], function (key) {\r\n            if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n          });\r\n\r\n          // bind functions from the attrs to the show and hide events\r\n          angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n            var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n            if (angular.isDefined(attr[bsKey])) {\r\n              options[key] = scope.$eval(attr[bsKey]);\r\n            }\r\n          });\r\n\r\n          // Support scope as an object\r\n          if (attr.bsDropdown) {\r\n            scope.$watch(attr.bsDropdown, function (newValue, oldValue) {\r\n              scope.content = newValue;\r\n            }, true);\r\n          }\r\n\r\n          // Initialize dropdown\r\n          var dropdown = $dropdown(element, options);\r\n\r\n          // Visibility binding support\r\n          if (attr.bsShow) {\r\n            scope.$watch(attr.bsShow, function (newValue, oldValue) {\r\n              if (!dropdown || !angular.isDefined(newValue)) return;\r\n              if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(dropdown),?/i);\r\n              if (newValue === true) {\r\n                dropdown.show();\r\n              } else {\r\n                dropdown.hide();\r\n              }\r\n            });\r\n          }\r\n\r\n          // Garbage collection\r\n          scope.$on('$destroy', function () {\r\n            if (dropdown) dropdown.destroy();\r\n            options = null;\r\n            dropdown = null;\r\n          });\r\n\r\n        };\r\n      }\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.button', [])\r\n\r\n  .provider('$button', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      activeClass: 'active',\r\n      toggleEvent: 'click'\r\n    };\r\n\r\n    this.$get = function () {\r\n      return {defaults: defaults};\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsCheckboxGroup', function () {\r\n\r\n    return {\r\n      restrict: 'A',\r\n      require: 'ngModel',\r\n      compile: function postLink (element, attr) {\r\n        element.attr('data-toggle', 'buttons');\r\n        element.removeAttr('ng-model');\r\n        var children = element[0].querySelectorAll('input[type=\"checkbox\"]');\r\n        angular.forEach(children, function (child) {\r\n          var childEl = angular.element(child);\r\n          childEl.attr('bs-checkbox', '');\r\n          childEl.attr('ng-model', attr.ngModel + '.' + childEl.attr('value'));\r\n        });\r\n      }\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsCheckbox', function ($button, $$rAF) {\r\n\r\n    var defaults = $button.defaults;\r\n    var constantValueRegExp = /^(true|false|\\d+)$/;\r\n\r\n    return {\r\n      restrict: 'A',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        var options = defaults;\r\n\r\n        // Support label > input[type=\"checkbox\"]\r\n        var isInput = element[0].nodeName === 'INPUT';\r\n        var activeElement = isInput ? element.parent() : element;\r\n\r\n        var trueValue = angular.isDefined(attr.trueValue) ? attr.trueValue : true;\r\n        if (constantValueRegExp.test(attr.trueValue)) {\r\n          trueValue = scope.$eval(attr.trueValue);\r\n        }\r\n        var falseValue = angular.isDefined(attr.falseValue) ? attr.falseValue : false;\r\n        if (constantValueRegExp.test(attr.falseValue)) {\r\n          falseValue = scope.$eval(attr.falseValue);\r\n        }\r\n\r\n        // Parse exotic values\r\n        var hasExoticValues = typeof trueValue !== 'boolean' || typeof falseValue !== 'boolean';\r\n        if (hasExoticValues) {\r\n          controller.$parsers.push(function (viewValue) {\r\n            // console.warn('$parser', element.attr('ng-model'), 'viewValue', viewValue);\r\n            return viewValue ? trueValue : falseValue;\r\n          });\r\n          // modelValue -> $formatters -> viewValue\r\n          controller.$formatters.push(function (modelValue) {\r\n             // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n            return angular.equals(modelValue, trueValue);\r\n          });\r\n        }\r\n\r\n        // model -> view\r\n        controller.$render = function () {\r\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\r\n          var isActive = !!controller.$viewValue;\r\n          $$rAF(function () {\r\n            if (isInput) element[0].checked = isActive;\r\n            activeElement.toggleClass(options.activeClass, isActive);\r\n          });\r\n        };\r\n\r\n        // view -> model\r\n        element.bind(options.toggleEvent, function () {\r\n          scope.$apply(function () {\r\n            // console.warn('!click', element.attr('ng-model'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\r\n            if (!isInput) {\r\n              controller.$setViewValue(!activeElement.hasClass('active'));\r\n            }\r\n            controller.$render();\r\n          });\r\n        });\r\n\r\n      }\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsRadioGroup', function () {\r\n\r\n    return {\r\n      restrict: 'A',\r\n      require: 'ngModel',\r\n      compile: function postLink (element, attr) {\r\n        element.attr('data-toggle', 'buttons');\r\n        element.removeAttr('ng-model');\r\n        var children = element[0].querySelectorAll('input[type=\"radio\"]');\r\n        angular.forEach(children, function (child) {\r\n          angular.element(child).attr('bs-radio', '');\r\n          angular.element(child).attr('ng-model', attr.ngModel);\r\n        });\r\n      }\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsRadio', function ($button, $$rAF) {\r\n\r\n    var defaults = $button.defaults;\r\n    var constantValueRegExp = /^(true|false|\\d+)$/;\r\n\r\n    return {\r\n      restrict: 'A',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        var options = defaults;\r\n\r\n        // Support `label > input[type=\"radio\"]` markup\r\n        var isInput = element[0].nodeName === 'INPUT';\r\n        var activeElement = isInput ? element.parent() : element;\r\n\r\n        var value;\r\n        attr.$observe('value', function (v) {\r\n          if (typeof v !== 'boolean' && constantValueRegExp.test(v)) {\r\n            value = scope.$eval(v);\r\n          } else {\r\n            value = v;\r\n          }\r\n          controller.$render();\r\n        });\r\n\r\n        // model -> view\r\n        controller.$render = function () {\r\n          // console.warn('$render', element.attr('value'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\r\n          var isActive = angular.equals(controller.$viewValue, value);\r\n          $$rAF(function () {\r\n            if (isInput) element[0].checked = isActive;\r\n            activeElement.toggleClass(options.activeClass, isActive);\r\n          });\r\n        };\r\n\r\n        // view -> model\r\n        element.bind(options.toggleEvent, function () {\r\n          scope.$apply(function () {\r\n            // console.warn('!click', element.attr('value'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\r\n            controller.$setViewValue(value);\r\n            controller.$render();\r\n          });\r\n        });\r\n\r\n      }\r\n\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.typeahead', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\r\n\r\n  .provider('$typeahead', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      prefixClass: 'typeahead',\r\n      prefixEvent: '$typeahead',\r\n      placement: 'bottom-left',\r\n      templateUrl: 'typeahead/typeahead.tpl.html',\r\n      trigger: 'focus',\r\n      container: false,\r\n      keyboard: true,\r\n      html: false,\r\n      delay: 0,\r\n      minLength: 1,\r\n      filter: 'bsAsyncFilter',\r\n      limit: 6,\r\n      autoSelect: false,\r\n      comparator: '',\r\n      trimValue: true\r\n    };\r\n\r\n    var KEY_CODES = {\r\n      downArrow: 40,\r\n      enter: 13,\r\n      escape: 27,\r\n      upArrow: 38\r\n    };\r\n\r\n    this.$get = function ($window, $rootScope, $tooltip, $$rAF, $timeout) {\r\n\r\n      function TypeaheadFactory (element, controller, config) {\r\n\r\n        var $typeahead = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n\r\n        $typeahead = $tooltip(element, options);\r\n\r\n        var parentScope = config.scope;\r\n        var scope = $typeahead.$scope;\r\n        scope.id = options.id;\r\n\r\n        scope.$resetMatches = function () {\r\n          scope.$matches = [];\r\n          scope.$activeIndex = options.autoSelect ? 0 : -1; // If set to 0, the first match will be highlighted\r\n        };\r\n        scope.$resetMatches();\r\n\r\n        scope.$activate = function (index) {\r\n          scope.$$postDigest(function () {\r\n            $typeahead.activate(index);\r\n          });\r\n        };\r\n\r\n        scope.$select = function (index, evt) {\r\n          scope.$$postDigest(function () {\r\n            $typeahead.select(index);\r\n          });\r\n        };\r\n\r\n        scope.$isVisible = function () {\r\n          return $typeahead.$isVisible();\r\n        };\r\n\r\n        scope.$isActive = function isActive (index) {\r\n          return scope.$activeIndex === index ? true : undefined;\r\n        };\r\n\r\n        // Public methods\r\n\r\n        $typeahead.update = function (matches) {\r\n          scope.$matches = matches;\r\n          if (scope.$activeIndex >= matches.length) {\r\n            scope.$activeIndex = options.autoSelect ? 0 : -1;\r\n          }\r\n\r\n          // wrap in a $timeout so the results are updated\r\n          // before repositioning\r\n          safeDigest(scope);\r\n          $$rAF($typeahead.$applyPlacement);\r\n        };\r\n\r\n        $typeahead.activate = function (index) {\r\n          scope.$activeIndex = index;\r\n        };\r\n\r\n        $typeahead.select = function (index) {\r\n          if (index === -1) return;\r\n          var value = scope.$matches[index].value;\r\n          // console.log('$setViewValue', value);\r\n          controller.$setViewValue(value);\r\n          controller.$render();\r\n          scope.$resetMatches();\r\n          if (parentScope) parentScope.$digest();\r\n          // Emit event\r\n          scope.$emit(options.prefixEvent + '.select', value, index, $typeahead);\r\n          if (angular.isDefined(options.onSelect) && angular.isFunction(options.onSelect)) {\r\n            options.onSelect(value, index, $typeahead);\r\n          }\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $typeahead.$isVisible = function () {\r\n          if (!options.minLength || !controller) {\r\n            return !!scope.$matches.length;\r\n          }\r\n          // minLength support\r\n          return scope.$matches.length && angular.isString(controller.$viewValue) && controller.$viewValue.length >= options.minLength;\r\n        };\r\n\r\n        scope.$generateResultId = function (index) {\r\n          return scope.id ? scope.id + '_typeahead_result_' + index : undefined;\r\n        };\r\n\r\n        $typeahead.$getIndex = function (value) {\r\n          var index;\r\n          for (index = scope.$matches.length; index--;) {\r\n            if (angular.equals(scope.$matches[index].value, value)) break;\r\n          }\r\n          return index;\r\n        };\r\n\r\n        $typeahead.$onMouseDown = function (evt) {\r\n          // Prevent blur on mousedown\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n        };\r\n\r\n        $typeahead.$$updateScrollTop = function (container, index) {\r\n          if (index > -1 && index < container.children.length) {\r\n            var active = container.children[index];\r\n            var clientTop = active.offsetTop;\r\n            var clientBottom = active.offsetTop + active.clientHeight;\r\n            var highWatermark = container.scrollTop;\r\n            var lowWatermark = container.scrollTop + container.clientHeight;\r\n\r\n            // active entry overlaps top border\r\n            if (clientBottom >= highWatermark && clientTop < highWatermark) {\r\n              container.scrollTop = Math.max(0, container.scrollTop - container.clientHeight);\r\n            } else if (clientBottom > lowWatermark) {\r\n              // top of active element is invisible because it's below the bottom of the visible container window\r\n              container.scrollTop = clientTop;\r\n            }\r\n          }\r\n        };\r\n\r\n        $typeahead.$onKeyDown = function (evt) {\r\n          // If the key code isn't up arrow, down arrow, or enter return.\r\n          if (!/(38|40|13)/.test(evt.keyCode)) return;\r\n\r\n          // Let ngSubmit pass if the typeahead tip is hidden or no option is selected\r\n          if ($typeahead.$isVisible() && !(evt.keyCode === KEY_CODES.enter && scope.$activeIndex === -1)) {\r\n            evt.preventDefault();\r\n            evt.stopPropagation();\r\n          }\r\n\r\n          // Select with enter\r\n          if (evt.keyCode === KEY_CODES.enter && scope.$matches.length) {\r\n            $typeahead.select(scope.$activeIndex);\r\n            // Navigate with keyboard\r\n          } else if (evt.keyCode === KEY_CODES.upArrow && scope.$activeIndex > 0) {\r\n            scope.$activeIndex--;\r\n            setAriaActiveDescendant(scope.$activeIndex);\r\n            angular.element(document.getElementById(options.id + '_sr_text')).html(scope.$matches[scope.$activeIndex].label);\r\n          } else if (evt.keyCode === KEY_CODES.downArrow && scope.$activeIndex < scope.$matches.length - 1) {\r\n            scope.$activeIndex++;\r\n            setAriaActiveDescendant(scope.$activeIndex);\r\n            angular.element(document.getElementById(options.id + '_sr_text')).html(scope.$matches[scope.$activeIndex].label);\r\n          } else if (angular.isUndefined(scope.$activeIndex)) {\r\n            scope.$activeIndex = 0;\r\n            setAriaActiveDescendant();\r\n          }\r\n\r\n          // update scrollTop property on $typeahead when scope.$activeIndex is not in visible area\r\n          $typeahead.$$updateScrollTop($typeahead.$element[0], scope.$activeIndex);\r\n          scope.$digest();\r\n        };\r\n\r\n        // Overrides\r\n\r\n        var show = $typeahead.show;\r\n        $typeahead.show = function () {\r\n          show();\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed immediately.\r\n          $timeout(function () {\r\n            if ($typeahead.$element) {\r\n              if (options.id) {\r\n                // Set the id on the \"dropdown\" component of the typeahead. The input should \"control\" this element.\r\n                $typeahead.$element.attr('id', options.id + '_listbox');\r\n                element.attr('aria-controls', options.id + '_listbox');\r\n\r\n                var assertDiv = document.getElementById(options.id + '_sr_text');\r\n                if (!assertDiv) {\r\n                  $typeahead.$element.parent().append('<div id=\"' + options.id + '_sr_text\" aria-live=\"assertive\" style=\"position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); border: 0;\"></div>');\r\n                }\r\n              }\r\n\r\n              // If the input was given an aria-labelledby attribute apply it to the \"dropdown\" component.\r\n              $typeahead.$element.attr('aria-labelledby', options.ariaLabelledby);\r\n\r\n              $typeahead.$element.on('mousedown', $typeahead.$onMouseDown);\r\n              if (options.keyboard) {\r\n                if (element) element.on('keydown', $typeahead.$onKeyDown);\r\n              }\r\n            }\r\n          }, 0, false);\r\n        };\r\n\r\n        var hide = $typeahead.hide;\r\n        $typeahead.hide = function () {\r\n          if ($typeahead.$element) $typeahead.$element.off('mousedown', $typeahead.$onMouseDown);\r\n          if (options.keyboard) {\r\n            if (element) element.off('keydown', $typeahead.$onKeyDown);\r\n          }\r\n          if (!options.autoSelect) {\r\n            $typeahead.activate(-1);\r\n          }\r\n\r\n          var assertDiv = document.getElementById(options.id + '_sr_text');\r\n          angular.element(assertDiv).remove();\r\n\r\n          setAriaActiveDescendant();\r\n\r\n          hide();\r\n        };\r\n\r\n        var onKeyUp = $typeahead.$onKeyUp; // eslint-disable-line no-unused-vars\r\n        $typeahead.$onKeyUp = function (evt) {\r\n          if (evt.which === KEY_CODES.escape && $typeahead.$isShown) {\r\n            $typeahead.hide();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        var onFocusKeyUp = $typeahead.$onFocusKeyUp; // eslint-disable-line no-unused-vars\r\n        $typeahead.$onFocusKeyUp = function (evt) {\r\n          if (evt.which === KEY_CODES.escape) {\r\n            $typeahead.hide();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        // Helper functions within this closure\r\n\r\n        function setAriaActiveDescendant (index) {\r\n          if (index === undefined || !scope.id) {\r\n            element.removeAttr('aria-activedescendant');\r\n          } else {\r\n            var resultId = scope.$generateResultId(index);\r\n            if (resultId) {\r\n              element.attr('aria-activedescendant', resultId);\r\n            } else {\r\n              element.removeAttr('aria-activedescendant');\r\n            }\r\n          }\r\n        }\r\n\r\n        return $typeahead;\r\n\r\n      }\r\n\r\n      // Helper functions\r\n\r\n      function safeDigest (scope) {\r\n        /* eslint-disable no-unused-expressions */\r\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\r\n        /* eslint-enable no-unused-expressions */\r\n      }\r\n\r\n      TypeaheadFactory.defaults = defaults;\r\n      return TypeaheadFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .filter('bsAsyncFilter', function ($filter) {\r\n    return function (array, expression, comparator) {\r\n      if (array && angular.isFunction(array.then)) {\r\n        return array.then(function (results) {\r\n          return $filter('filter')(results, expression, comparator);\r\n        });\r\n      }\r\n      return $filter('filter')(array, expression, comparator);\r\n    };\r\n  })\r\n\r\n  .directive('bsTypeahead', function ($window, $parse, $q, $typeahead, $parseOptions) {\r\n\r\n    var defaults = $typeahead.defaults;\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        // Fixes firefox bug when using objects in model with typeahead\r\n        // Yes this breaks any other directive using a 'change' event on this input,\r\n        // but if it is using the 'change' event why is it used with typeahead?\r\n        element.off('change');\r\n\r\n        // Directive options\r\n        var options = {\r\n          scope: scope\r\n        };\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'filter', 'limit', 'minLength', 'watchOptions', 'selectMode', 'autoSelect', 'comparator', 'id', 'prefixEvent', 'prefixClass', 'ariaLabelledby'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container', 'trimValue', 'filter'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n        });\r\n\r\n        // bind functions from the attrs to the show, hide and select events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide', 'onSelect'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Disable browser autocompletion\r\n        if (!element.attr('autocomplete')) element.attr('autocomplete', 'off');\r\n\r\n        // Build proper bsOptions\r\n        var filter = angular.isDefined(options.filter) ? options.filter : defaults.filter;\r\n        var limit = options.limit || defaults.limit;\r\n        var comparator = options.comparator || defaults.comparator;\r\n\r\n        var bsOptions = attr.bsOptions;\r\n        if (filter) {\r\n          bsOptions += ' | ' + filter + ':$viewValue';\r\n          if (comparator) bsOptions += ':' + comparator;\r\n        }\r\n        if (limit) bsOptions += ' | limitTo:' + limit;\r\n        var parsedOptions = $parseOptions(bsOptions);\r\n\r\n        // Initialize typeahead\r\n        var typeahead = $typeahead(element, controller, options);\r\n\r\n        if (!element.attr('aria-autocomplete') && !bsOptions.templateUrl) {\r\n          // Per draft spec for a combobox element the aria-auto complete should be set to a list.\r\n          element.attr('aria-autocomplete', 'list');\r\n        }\r\n\r\n        // Watch options on demand\r\n        if (options.watchOptions) {\r\n          // Watch bsOptions values before filtering for changes, drop function calls\r\n          var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').replace(/\\(.*\\)/g, '').trim();\r\n          scope.$watchCollection(watchedOptions, function (newValue, oldValue) {\r\n            // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\r\n            parsedOptions.valuesFn(scope, controller).then(function (values) {\r\n              typeahead.update(values);\r\n              controller.$render();\r\n            });\r\n          });\r\n        }\r\n\r\n        // Watch model for changes\r\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\r\n          // console.warn('$watch', element.attr('ng-model'), newValue);\r\n          scope.$modelValue = newValue; // Publish modelValue on scope for custom templates\r\n          parsedOptions.valuesFn(scope, controller)\r\n            .then(function (values) {\r\n              // Prevent input with no future prospect if selectMode is truthy\r\n              // @TODO test selectMode\r\n              if (options.selectMode && !values.length && newValue.length > 0) {\r\n                controller.$setViewValue(controller.$viewValue.substring(0, controller.$viewValue.length - 1));\r\n                return;\r\n              }\r\n              if (values.length > limit) values = values.slice(0, limit);\r\n              typeahead.update(values);\r\n              // Queue a new rendering that will leverage collection loading\r\n              controller.$render();\r\n            });\r\n        });\r\n\r\n        // modelValue -> $formatters -> viewValue\r\n        controller.$formatters.push(function (modelValue) {\r\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n          var displayValue = parsedOptions.displayValue(modelValue);\r\n\r\n          // If we can determine the displayValue, use that\r\n          if (displayValue) {\r\n            return displayValue;\r\n          }\r\n\r\n          // If there's no display value, attempt to use the modelValue.\r\n          // If the model is an object not much we can do\r\n          if (angular.isDefined(modelValue) && typeof modelValue !== 'object') {\r\n            return modelValue;\r\n          }\r\n          return '';\r\n        });\r\n\r\n        // Model rendering in view\r\n        controller.$render = function () {\r\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\r\n          if (controller.$isEmpty(controller.$viewValue)) {\r\n            return element.val('');\r\n          }\r\n          var index = typeahead.$getIndex(controller.$modelValue);\r\n          var selected = index !== -1 ? typeahead.$scope.$matches[index].label : controller.$viewValue;\r\n          selected = angular.isObject(selected) ? parsedOptions.displayValue(selected) : selected;\r\n          var value = selected ? selected.toString().replace(/<(?:.|\\n)*?>/gm, '') : '';\r\n          var ss = element[0].selectionStart;\r\n          var sd = element[0].selectionEnd;\r\n          element.val(options.trimValue === false ? value : value.trim());\r\n          element[0].setSelectionRange(ss, sd);\r\n        };\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          element.off('keydown');\r\n          if (typeahead) typeahead.destroy();\r\n          options = null;\r\n          typeahead = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\r\n\r\n  .provider('$tooltip', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      customClass: '',\r\n      prefixClass: 'tooltip',\r\n      prefixEvent: 'tooltip',\r\n      container: false,\r\n      target: false,\r\n      placement: 'top',\r\n      templateUrl: 'tooltip/tooltip.tpl.html',\r\n      template: '',\r\n      titleTemplate: false,\r\n      trigger: 'hover focus',\r\n      keyboard: false,\r\n      html: false,\r\n      show: false,\r\n      title: '',\r\n      type: '',\r\n      delay: 0,\r\n      autoClose: false,\r\n      bsEnabled: true,\r\n      mouseDownPreventDefault: true,\r\n      mouseDownStopPropagation: true,\r\n      viewport: {\r\n        selector: 'body',\r\n        padding: 0\r\n      }\r\n    };\r\n\r\n    this.$get = function ($window, $rootScope, $bsCompiler, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\r\n\r\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n      var isTouch = ('createTouch' in $window.document) && isNative;\r\n      var $body = angular.element($window.document);\r\n\r\n      function TooltipFactory (element, config) {\r\n\r\n        var $tooltip = {};\r\n\r\n        // Common vars\r\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\r\n        var promise = $tooltip.$promise = $bsCompiler.compile(options);\r\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\r\n\r\n        // var nodeName = element[0].nodeName.toLowerCase();\r\n        if (options.delay && angular.isString(options.delay)) {\r\n          var split = options.delay.split(',').map(parseFloat);\r\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\r\n        }\r\n\r\n        // Store $id to identify the triggering element in events\r\n        // give priority to options.id, otherwise, try to use\r\n        // element id if defined\r\n        $tooltip.$id = options.id || element.attr('id') || '';\r\n\r\n        // Support scope as string options\r\n        if (options.title) {\r\n          scope.title = $sce.trustAsHtml(options.title);\r\n        }\r\n\r\n        // Provide scope helpers\r\n        scope.$setEnabled = function (isEnabled) {\r\n          scope.$$postDigest(function () {\r\n            $tooltip.setEnabled(isEnabled);\r\n          });\r\n        };\r\n        scope.$hide = function () {\r\n          scope.$$postDigest(function () {\r\n            $tooltip.hide();\r\n          });\r\n        };\r\n        scope.$show = function () {\r\n          scope.$$postDigest(function () {\r\n            $tooltip.show();\r\n          });\r\n        };\r\n        scope.$toggle = function () {\r\n          scope.$$postDigest(function () {\r\n            $tooltip.toggle();\r\n          });\r\n        };\r\n        // Publish isShown as a protected var on scope\r\n        $tooltip.$isShown = scope.$isShown = false;\r\n\r\n        // Private vars\r\n        var timeout;\r\n        var hoverState;\r\n\r\n        // Fetch, compile then initialize tooltip\r\n        var compileData;\r\n        var tipElement;\r\n        var tipContainer;\r\n        var tipScope;\r\n        promise.then(function (data) {\r\n          compileData = data;\r\n          $tooltip.init();\r\n        });\r\n\r\n        $tooltip.init = function () {\r\n\r\n          // Options: delay\r\n          if (options.delay && angular.isNumber(options.delay)) {\r\n            options.delay = {\r\n              show: options.delay,\r\n              hide: options.delay\r\n            };\r\n          }\r\n\r\n          // Replace trigger on touch devices ?\r\n          // if(isTouch && options.trigger === defaults.trigger) {\r\n          //   options.trigger.replace(/hover/g, 'click');\r\n          // }\r\n\r\n          // Options : container\r\n          if (options.container === 'self') {\r\n            tipContainer = element;\r\n          } else if (angular.isElement(options.container)) {\r\n            tipContainer = options.container;\r\n          } else if (options.container) {\r\n            tipContainer = findElement(options.container);\r\n          }\r\n\r\n          // Options: trigger\r\n          bindTriggerEvents();\r\n\r\n          // Options: target\r\n          if (options.target) {\r\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\r\n          }\r\n\r\n          // Options: show\r\n          if (options.show) {\r\n            scope.$$postDigest(function () {\r\n              if (options.trigger === 'focus') {\r\n                element[0].focus();\r\n              } else {\r\n                $tooltip.show();\r\n              }\r\n            });\r\n          }\r\n\r\n        };\r\n\r\n        $tooltip.destroy = function () {\r\n\r\n          // Unbind events\r\n          unbindTriggerEvents();\r\n\r\n          // Remove element\r\n          destroyTipElement();\r\n\r\n          // Destroy scope\r\n          scope.$destroy();\r\n\r\n        };\r\n\r\n        $tooltip.enter = function () {\r\n\r\n          clearTimeout(timeout);\r\n          hoverState = 'in';\r\n          if (!options.delay || !options.delay.show) {\r\n            return $tooltip.show();\r\n          }\r\n\r\n          timeout = setTimeout(function () {\r\n            if (hoverState === 'in') $tooltip.show();\r\n          }, options.delay.show);\r\n\r\n        };\r\n\r\n        $tooltip.show = function () {\r\n          if (!options.bsEnabled || $tooltip.$isShown) return;\r\n\r\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\r\n          if (angular.isDefined(options.onBeforeShow) && angular.isFunction(options.onBeforeShow)) {\r\n            options.onBeforeShow($tooltip);\r\n          }\r\n          var parent;\r\n          var after;\r\n          if (options.container) {\r\n            parent = tipContainer;\r\n            if (tipContainer[0].lastChild) {\r\n              after = angular.element(tipContainer[0].lastChild);\r\n            } else {\r\n              after = null;\r\n            }\r\n          } else {\r\n            parent = null;\r\n            after = element;\r\n          }\r\n\r\n\r\n          // Hide any existing tipElement\r\n          if (tipElement) destroyTipElement();\r\n          // Fetch a cloned element linked from template\r\n          tipScope = $tooltip.$scope.$new();\r\n          tipElement = $tooltip.$element = compileData.link(tipScope, function (clonedElement, scope) {});\r\n\r\n          // Set the initial positioning.  Make the tooltip invisible\r\n          // so IE doesn't try to focus on it off screen.\r\n          tipElement.css({top: '-9999px', left: '-9999px', right: 'auto', display: 'block', visibility: 'hidden'});\r\n\r\n          // Options: animation\r\n          if (options.animation) tipElement.addClass(options.animation);\r\n          // Options: type\r\n          if (options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\r\n          // Options: custom classes\r\n          if (options.customClass) tipElement.addClass(options.customClass);\r\n\r\n          // Append the element, without any animations.  If we append\r\n          // using $animate.enter, some of the animations cause the placement\r\n          // to be off due to the transforms.\r\n          if (after) {\r\n            after.after(tipElement);\r\n          } else {\r\n            parent.prepend(tipElement);\r\n          }\r\n\r\n          $tooltip.$isShown = scope.$isShown = true;\r\n          safeDigest(scope);\r\n\r\n          // Now, apply placement\r\n          $tooltip.$applyPlacement();\r\n\r\n          // Once placed, animate it.\r\n          // Support v1.2+ $animate\r\n          // https://github.com/angular/angular.js/issues/11713\r\n          if (angular.version.minor <= 2) {\r\n            $animate.enter(tipElement, parent, after, enterAnimateCallback);\r\n          } else {\r\n            $animate.enter(tipElement, parent, after).then(enterAnimateCallback);\r\n          }\r\n          safeDigest(scope);\r\n\r\n          $$rAF(function () {\r\n            // Once the tooltip is placed and the animation starts, make the tooltip visible\r\n            if (tipElement) tipElement.css({visibility: 'visible'});\r\n\r\n            // Bind events\r\n            if (options.keyboard) {\r\n              if (options.trigger !== 'focus') {\r\n                $tooltip.focus();\r\n              }\r\n              bindKeyboardEvents();\r\n            }\r\n          });\r\n\r\n          if (options.autoClose) {\r\n            bindAutoCloseEvents();\r\n          }\r\n\r\n        };\r\n\r\n        function enterAnimateCallback () {\r\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\r\n          if (angular.isDefined(options.onShow) && angular.isFunction(options.onShow)) {\r\n            options.onShow($tooltip);\r\n          }\r\n        }\r\n\r\n        $tooltip.leave = function () {\r\n\r\n          clearTimeout(timeout);\r\n          hoverState = 'out';\r\n          if (!options.delay || !options.delay.hide) {\r\n            return $tooltip.hide();\r\n          }\r\n          timeout = setTimeout(function () {\r\n            if (hoverState === 'out') {\r\n              $tooltip.hide();\r\n            }\r\n          }, options.delay.hide);\r\n\r\n        };\r\n\r\n        var _blur;\r\n        var _tipToHide;\r\n        $tooltip.hide = function (blur) {\r\n\r\n          if (!$tooltip.$isShown) return;\r\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\r\n          if (angular.isDefined(options.onBeforeHide) && angular.isFunction(options.onBeforeHide)) {\r\n            options.onBeforeHide($tooltip);\r\n          }\r\n\r\n          // store blur value for leaveAnimateCallback to use\r\n          _blur = blur;\r\n\r\n          // store current tipElement reference to use\r\n          // in leaveAnimateCallback\r\n          _tipToHide = tipElement;\r\n\r\n          if (tipElement !== null) {\r\n            // Support v1.2+ $animate\r\n            // https://github.com/angular/angular.js/issues/11713\r\n            if (angular.version.minor <= 2) {\r\n              $animate.leave(tipElement, leaveAnimateCallback);\r\n            } else {\r\n              $animate.leave(tipElement).then(leaveAnimateCallback);\r\n            }\r\n          }\r\n\r\n          $tooltip.$isShown = scope.$isShown = false;\r\n          safeDigest(scope);\r\n\r\n          // Unbind events\r\n          if (options.keyboard && tipElement !== null) {\r\n            unbindKeyboardEvents();\r\n          }\r\n\r\n          if (options.autoClose && tipElement !== null) {\r\n            unbindAutoCloseEvents();\r\n          }\r\n        };\r\n\r\n        function leaveAnimateCallback () {\r\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\r\n          if (angular.isDefined(options.onHide) && angular.isFunction(options.onHide)) {\r\n            options.onHide($tooltip);\r\n          }\r\n\r\n          // check if current tipElement still references\r\n          // the same element when hide was called\r\n          if (tipElement === _tipToHide) {\r\n            // Allow to blur the input when hidden, like when pressing enter key\r\n            if (_blur && options.trigger === 'focus') {\r\n              return element[0].blur();\r\n            }\r\n\r\n            // clean up child scopes\r\n            destroyTipElement();\r\n          }\r\n        }\r\n\r\n        $tooltip.toggle = function (evt) {\r\n          if (evt) { evt.preventDefault(); }\r\n          if ($tooltip.$isShown) {\r\n            $tooltip.leave();\r\n          } else {\r\n            $tooltip.enter();\r\n          }\r\n        };\r\n\r\n        $tooltip.focus = function () {\r\n          tipElement[0].focus();\r\n        };\r\n\r\n        $tooltip.setEnabled = function (isEnabled) {\r\n          options.bsEnabled = isEnabled;\r\n        };\r\n\r\n        $tooltip.setViewport = function (viewport) {\r\n          options.viewport = viewport;\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $tooltip.$applyPlacement = function () {\r\n          if (!tipElement) return;\r\n\r\n          // Determine if we're doing an auto or normal placement\r\n          var placement = options.placement;\r\n          var autoToken = /\\s?auto?\\s?/i;\r\n          var autoPlace = autoToken.test(placement);\r\n\r\n          if (autoPlace) {\r\n            placement = placement.replace(autoToken, '') || defaults.placement;\r\n          }\r\n\r\n          // Need to add the position class before we get\r\n          // the offsets\r\n          tipElement.addClass(options.placement);\r\n\r\n          // Get the position of the target element\r\n          // and the height and width of the tooltip so we can center it.\r\n          var elementPosition = getPosition();\r\n          var tipWidth = tipElement.prop('offsetWidth');\r\n          var tipHeight = tipElement.prop('offsetHeight');\r\n\r\n          // Refresh viewport position\r\n          $tooltip.$viewport = options.viewport && findElement(options.viewport.selector || options.viewport);\r\n\r\n          // If we're auto placing, we need to check the positioning\r\n          if (autoPlace) {\r\n            var originalPlacement = placement;\r\n            var viewportPosition = getPosition($tooltip.$viewport);\r\n\r\n            if (/bottom/.test(originalPlacement) && elementPosition.bottom + tipHeight > viewportPosition.bottom) {\r\n              placement = originalPlacement.replace('bottom', 'top');\r\n            } else if (/top/.test(originalPlacement) && elementPosition.top - tipHeight < viewportPosition.top) {\r\n              placement = originalPlacement.replace('top', 'bottom');\r\n            }\r\n\r\n            if (/left/.test(originalPlacement) && elementPosition.left - tipWidth < viewportPosition.left) {\r\n              placement = placement.replace('left', 'right');\r\n            } else if (/right/.test(originalPlacement) && elementPosition.right + tipWidth > viewportPosition.width) {\r\n              placement = placement.replace('right', 'left');\r\n            }\r\n\r\n            tipElement.removeClass(originalPlacement).addClass(placement);\r\n          }\r\n\r\n          // Get the tooltip's top and left coordinates to center it with this directive.\r\n          var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\r\n          applyPlacement(tipPosition, placement);\r\n        };\r\n\r\n        $tooltip.$onKeyUp = function (evt) {\r\n          if (evt.which === 27 && $tooltip.$isShown) {\r\n            $tooltip.hide();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        $tooltip.$onFocusKeyUp = function (evt) {\r\n          if (evt.which === 27) {\r\n            element[0].blur();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        $tooltip.$onFocusElementMouseDown = function (evt) {\r\n          if (options.mouseDownPreventDefault) { evt.preventDefault(); }\r\n          if (options.mouseDownStopPropagation) { evt.stopPropagation(); }\r\n          // Some browsers do not auto-focus buttons (eg. Safari)\r\n          if ($tooltip.$isShown) {\r\n            element[0].blur();\r\n          } else {\r\n            element[0].focus();\r\n          }\r\n        };\r\n\r\n        // bind/unbind events\r\n        function bindTriggerEvents () {\r\n\r\n          var triggers = options.trigger.split(' ');\r\n          angular.forEach(triggers, function (trigger) {\r\n            if (trigger === 'click' || trigger === 'contextmenu') {\r\n              element.on(trigger, $tooltip.toggle);\r\n              // element.on('blur', $tooltip.leave);\r\n            } else if (trigger !== 'manual') {\r\n              // Only bind up hover events if we are on a desktop\r\n              if (!isTouch) {\r\n                element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\r\n                element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\r\n              }\r\n\t\t\t  //but do bind focus events for touch\r\n              else if (trigger === 'focus') {\r\n                element.on('focus', $tooltip.enter);\r\n                element.on('blur', $tooltip.leave);\r\n\t\t\t  }\r\n\t\t  \r\n              // if (nodeName === 'button' && trigger !== 'hover') {\r\n              //   element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\r\n              // }\r\n            }\r\n          });\r\n        }\r\n\r\n        function unbindTriggerEvents () {\r\n          var triggers = options.trigger.split(' ');\r\n          for (var i = triggers.length; i--;) {\r\n            var trigger = triggers[i];\r\n            if (trigger === 'click' || trigger === 'contextmenu') {\r\n              element.off(trigger, $tooltip.toggle);\r\n            } else if (trigger !== 'manual') {\r\n              // Remove previously defined hover events if we are on a desktop\r\n              if (!isTouch) {\r\n                element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\r\n                element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\r\n              }\r\n\t\t\t  // Remove previously defined focus events\r\n              else if (trigger === 'focus') {\r\n                element.off('focus', $tooltip.enter);\r\n                element.off('blur', $tooltip.leave);\r\n\t\t\t  }\r\n\t\t\t  \r\n              // if (nodeName === 'button' && trigger !== 'hover') {\r\n              //   element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\r\n              // }\r\n            }\r\n          }\r\n        }\r\n\r\n        function bindKeyboardEvents () {\r\n          if (options.trigger !== 'focus') {\r\n            tipElement.on('keyup', $tooltip.$onKeyUp);\r\n          } else {\r\n            element.on('keyup', $tooltip.$onFocusKeyUp);\r\n          }\r\n        }\r\n\r\n        function unbindKeyboardEvents () {\r\n          if (options.trigger !== 'focus') {\r\n            tipElement.off('keyup', $tooltip.$onKeyUp);\r\n          } else {\r\n            element.off('keyup', $tooltip.$onFocusKeyUp);\r\n          }\r\n        }\r\n\r\n        var _autoCloseEventsBinded = false;\r\n        function bindAutoCloseEvents () {\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed imediately.\r\n          $timeout(function () {\r\n            // Stop propagation when clicking inside tooltip\r\n            tipElement.on('click', stopEventPropagation);\r\n\r\n            // Hide when clicking outside tooltip\r\n            $body.on('click', $tooltip.hide);\r\n\r\n            _autoCloseEventsBinded = true;\r\n          }, 0, false);\r\n        }\r\n\r\n        function unbindAutoCloseEvents () {\r\n          if (_autoCloseEventsBinded) {\r\n            tipElement.off('click', stopEventPropagation);\r\n            $body.off('click', $tooltip.hide);\r\n            _autoCloseEventsBinded = false;\r\n          }\r\n        }\r\n\r\n        function stopEventPropagation (event) {\r\n          event.stopPropagation();\r\n        }\r\n\r\n        // Private methods\r\n\r\n        function getPosition ($element) {\r\n          $element = $element || (options.target || element);\r\n\r\n          var el = $element[0];\r\n          var isBody = el.tagName === 'BODY';\r\n\r\n          var elRect = el.getBoundingClientRect();\r\n          var rect = {};\r\n\r\n          // IE8 has issues with angular.extend and using elRect directly.\r\n          // By coping the values of elRect into a new object, we can continue to use extend\r\n          /* eslint-disable guard-for-in */\r\n          for (var p in elRect) { // eslint-disable-line\r\n            // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.\r\n            rect[p] = elRect[p];\r\n          }\r\n          /* eslint-enable guard-for-in */\r\n\r\n          if (rect.width === null) {\r\n            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\r\n            rect = angular.extend({}, rect, {width: elRect.right - elRect.left, height: elRect.bottom - elRect.top});\r\n          }\r\n          var elOffset = isBody ? {top: 0, left: 0} : dimensions.offset(el);\r\n          var scroll = {scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0};\r\n          var outerDims = isBody ? {width: document.documentElement.clientWidth, height: $window.innerHeight} : null;\r\n\r\n          return angular.extend({}, rect, scroll, outerDims, elOffset);\r\n        }\r\n\r\n        function getCalculatedOffset (placement, position, actualWidth, actualHeight) {\r\n          var offset;\r\n          var split = placement.split('-');\r\n\r\n          switch (split[0]) {\r\n            case 'right':\r\n              offset = {\r\n                top: position.top + position.height / 2 - actualHeight / 2,\r\n                left: position.left + position.width\r\n              };\r\n              break;\r\n            case 'bottom':\r\n              offset = {\r\n                top: position.top + position.height,\r\n                left: position.left + position.width / 2 - actualWidth / 2\r\n              };\r\n              break;\r\n            case 'left':\r\n              offset = {\r\n                top: position.top + position.height / 2 - actualHeight / 2,\r\n                left: position.left - actualWidth\r\n              };\r\n              break;\r\n            default:\r\n              offset = {\r\n                top: position.top - actualHeight,\r\n                left: position.left + position.width / 2 - actualWidth / 2\r\n              };\r\n              break;\r\n          }\r\n\r\n          if (!split[1]) {\r\n            return offset;\r\n          }\r\n\r\n          // Add support for corners @todo css\r\n          if (split[0] === 'top' || split[0] === 'bottom') {\r\n            switch (split[1]) {\r\n              case 'left':\r\n                offset.left = position.left;\r\n                break;\r\n              case 'right':\r\n                offset.left = position.left + position.width - actualWidth;\r\n                break;\r\n              default:\r\n                break;\r\n            }\r\n          } else if (split[0] === 'left' || split[0] === 'right') {\r\n            switch (split[1]) {\r\n              case 'top':\r\n                offset.top = position.top - actualHeight + position.height;\r\n                break;\r\n              case 'bottom':\r\n                offset.top = position.top;\r\n                break;\r\n              default:\r\n                break;\r\n            }\r\n          }\r\n\r\n          return offset;\r\n        }\r\n\r\n        function applyPlacement (offset, placement) {\r\n          var tip = tipElement[0];\r\n          var width = tip.offsetWidth;\r\n          var height = tip.offsetHeight;\r\n\r\n          // manually read margins because getBoundingClientRect includes difference\r\n          var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10);\r\n          var marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);\r\n\r\n          // we must check for NaN for ie 8/9\r\n          if (isNaN(marginTop)) marginTop = 0;\r\n          if (isNaN(marginLeft)) marginLeft = 0;\r\n\r\n          offset.top = offset.top + marginTop;\r\n          offset.left = offset.left + marginLeft;\r\n\r\n          // dimensions setOffset doesn't round pixel values\r\n          // so we use setOffset directly with our own function\r\n          dimensions.setOffset(tip, angular.extend({\r\n            using: function (props) {\r\n              tipElement.css({\r\n                top: Math.round(props.top) + 'px',\r\n                left: Math.round(props.left) + 'px',\r\n                right: ''\r\n              });\r\n            }\r\n          }, offset), 0);\r\n\r\n          // check to see if placing tip in new offset caused the tip to resize itself\r\n          var actualWidth = tip.offsetWidth;\r\n          var actualHeight = tip.offsetHeight;\r\n\r\n          if (placement === 'top' && actualHeight !== height) {\r\n            offset.top = offset.top + height - actualHeight;\r\n          }\r\n\r\n          // If it's an exotic placement, exit now instead of\r\n          // applying a delta and changing the arrow\r\n          if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;\r\n\r\n          var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\r\n\r\n          if (delta.left) {\r\n            offset.left += delta.left;\r\n          } else {\r\n            offset.top += delta.top;\r\n          }\r\n\r\n          dimensions.setOffset(tip, offset);\r\n\r\n          if (/top|right|bottom|left/.test(placement)) {\r\n            var isVertical = /top|bottom/.test(placement);\r\n            var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;\r\n            var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';\r\n\r\n            replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);\r\n          }\r\n        }\r\n\r\n        // @source https://github.com/twbs/bootstrap/blob/v3.3.5/js/tooltip.js#L380\r\n        function getViewportAdjustedDelta (placement, position, actualWidth, actualHeight) {\r\n          var delta = {top: 0, left: 0};\r\n          if (!$tooltip.$viewport) return delta;\r\n\r\n          var viewportPadding = options.viewport && options.viewport.padding || 0;\r\n          var viewportDimensions = getPosition($tooltip.$viewport);\r\n\r\n          if (/right|left/.test(placement)) {\r\n            var topEdgeOffset = position.top - viewportPadding - viewportDimensions.scroll;\r\n            var bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;\r\n            if (topEdgeOffset < viewportDimensions.top) { // top overflow\r\n              delta.top = viewportDimensions.top - topEdgeOffset;\r\n            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\r\n              delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\r\n            }\r\n          } else {\r\n            var leftEdgeOffset = position.left - viewportPadding;\r\n            var rightEdgeOffset = position.left + viewportPadding + actualWidth;\r\n            if (leftEdgeOffset < viewportDimensions.left) { // left overflow\r\n              delta.left = viewportDimensions.left - leftEdgeOffset;\r\n            } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow\r\n              delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\r\n            }\r\n          }\r\n\r\n          return delta;\r\n        }\r\n\r\n        function replaceArrow (delta, dimension, isHorizontal) {\r\n          var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);\r\n\r\n          $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\r\n                .css(isHorizontal ? 'top' : 'left', '');\r\n        }\r\n\r\n        function destroyTipElement () {\r\n          // Cancel pending callbacks\r\n          clearTimeout(timeout);\r\n\r\n          if ($tooltip.$isShown && tipElement !== null) {\r\n            if (options.autoClose) {\r\n              unbindAutoCloseEvents();\r\n            }\r\n\r\n            if (options.keyboard) {\r\n              unbindKeyboardEvents();\r\n            }\r\n          }\r\n\r\n          if (tipScope) {\r\n            tipScope.$destroy();\r\n            tipScope = null;\r\n          }\r\n\r\n          if (tipElement) {\r\n            tipElement.remove();\r\n            tipElement = $tooltip.$element = null;\r\n          }\r\n        }\r\n\r\n        return $tooltip;\r\n\r\n      }\r\n\r\n      // Helper functions\r\n\r\n      function safeDigest (scope) {\r\n        /* eslint-disable no-unused-expressions */\r\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\r\n        /* eslint-enable no-unused-expressions */\r\n      }\r\n\r\n      function findElement (query, element) {\r\n        return angular.element((element || document).querySelectorAll(query));\r\n      }\r\n\r\n      return TooltipFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsTooltip', function ($window, $location, $sce, $parse, $tooltip, $$rAF) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink (scope, element, attr, transclusion) {\r\n\r\n        var tooltip;\r\n        // Directive options\r\n        var options = {scope: scope};\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'titleTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\r\n            options[key] = false;\r\n          }\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // should not parse target attribute (anchor tag), only data-target #1454\r\n        var dataTarget = element.attr('data-target');\r\n        if (angular.isDefined(dataTarget)) {\r\n          if (falseValueRegExp.test(dataTarget)) {\r\n            options.target = false;\r\n          } else {\r\n            options.target = dataTarget;\r\n          }\r\n        }\r\n\r\n        // overwrite inherited title value when no value specified\r\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\r\n        if (!scope.hasOwnProperty('title')) {\r\n          scope.title = '';\r\n        }\r\n\r\n        // Observe scope attributes for change\r\n        attr.$observe('title', function (newValue) {\r\n          if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {\r\n            var oldValue = scope.title;\r\n            scope.title = $sce.trustAsHtml(newValue);\r\n            if (angular.isDefined(oldValue)) {\r\n              $$rAF(function () {\r\n                if (tooltip) tooltip.$applyPlacement();\r\n              });\r\n            }\r\n          }\r\n        });\r\n\r\n        attr.$observe('disabled', function (newValue) {\r\n          if (newValue && tooltip.$isShown) {\r\n            tooltip.hide();\r\n          }\r\n        });\r\n\r\n        // Support scope as an object\r\n        if (attr.bsTooltip) {\r\n          scope.$watch(attr.bsTooltip, function (newValue, oldValue) {\r\n            if (angular.isObject(newValue)) {\r\n              angular.extend(scope, newValue);\r\n            } else {\r\n              scope.title = newValue;\r\n            }\r\n            if (angular.isDefined(oldValue)) {\r\n              $$rAF(function () {\r\n                if (tooltip) tooltip.$applyPlacement();\r\n              });\r\n            }\r\n          }, true);\r\n        }\r\n\r\n        // Visibility binding support\r\n        if (attr.bsShow) {\r\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\r\n            if (!tooltip || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\r\n            if (newValue === true) {\r\n              tooltip.show();\r\n            } else {\r\n              tooltip.hide();\r\n            }\r\n          });\r\n        }\r\n\r\n        // Enabled binding support\r\n        if (attr.bsEnabled) {\r\n          scope.$watch(attr.bsEnabled, function (newValue, oldValue) {\r\n            // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\r\n            if (!tooltip || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\r\n            if (newValue === false) {\r\n              tooltip.setEnabled(false);\r\n            } else {\r\n              tooltip.setEnabled(true);\r\n            }\r\n          });\r\n        }\r\n\r\n        // Viewport support\r\n        if (attr.viewport) {\r\n          scope.$watch(attr.viewport, function (newValue) {\r\n            if (!tooltip || !angular.isDefined(newValue)) return;\r\n            tooltip.setViewport(newValue);\r\n          });\r\n        }\r\n\r\n        // Initialize popover\r\n        tooltip = $tooltip(element, options);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (tooltip) tooltip.destroy();\r\n          options = null;\r\n          tooltip = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.timepicker', ['mgcrea.ngStrap.helpers.dateParser', 'mgcrea.ngStrap.helpers.dateFormatter', 'mgcrea.ngStrap.tooltip'])\r\n\r\n  .provider('$timepicker', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      defaultDate: 'auto',\r\n      // uncommenting the following line will break backwards compatability\r\n      // prefixEvent: 'timepicker',\r\n      prefixClass: 'timepicker',\r\n      placement: 'bottom-left',\r\n      templateUrl: 'timepicker/timepicker.tpl.html',\r\n      trigger: 'focus',\r\n      container: false,\r\n      keyboard: true,\r\n      html: false,\r\n      delay: 0,\r\n      // lang: $locale.id,\r\n      useNative: true,\r\n      timeType: 'date',\r\n      timeFormat: 'shortTime',\r\n      timezone: null,\r\n      modelTimeFormat: null,\r\n      autoclose: false,\r\n      minTime: -Infinity,\r\n      maxTime: +Infinity,\r\n      length: 5,\r\n      hourStep: 1,\r\n      minuteStep: 5,\r\n      secondStep: 5,\r\n      roundDisplay: false,\r\n      iconUp: 'glyphicon glyphicon-chevron-up',\r\n      iconDown: 'glyphicon glyphicon-chevron-down',\r\n      arrowBehavior: 'pager'\r\n    };\r\n\r\n    this.$get = function ($window, $document, $rootScope, $sce, $dateFormatter, $tooltip, $timeout) {\r\n\r\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n      var isTouch = ('createTouch' in $window.document) && isNative;\r\n      if (!defaults.lang) {\r\n        defaults.lang = $dateFormatter.getDefaultLocale();\r\n      }\r\n\r\n      function timepickerFactory (element, controller, config) {\r\n\r\n        var $timepicker = $tooltip(element, angular.extend({}, defaults, config));\r\n        var parentScope = config.scope;\r\n        var options = $timepicker.$options;\r\n        var scope = $timepicker.$scope;\r\n\r\n        var lang = options.lang;\r\n        var formatDate = function (date, format, timezone) {\r\n          return $dateFormatter.formatDate(date, format, lang, timezone);\r\n        };\r\n\r\n        function floorMinutes (time) {\r\n          // coeff used to floor current time to nearest minuteStep interval\r\n          var coeff = 1000 * 60 * options.minuteStep;\r\n          return new Date(Math.floor(time.getTime() / coeff) * coeff);\r\n        }\r\n\r\n        // View vars\r\n\r\n        var selectedIndex = 0;\r\n        var defaultDate = options.roundDisplay ? floorMinutes(new Date()) : new Date();\r\n        var startDate = controller.$dateValue || defaultDate;\r\n        var viewDate = {\r\n          hour: startDate.getHours(),\r\n          meridian: startDate.getHours() < 12,\r\n          minute: startDate.getMinutes(),\r\n          second: startDate.getSeconds(),\r\n          millisecond: startDate.getMilliseconds()\r\n        };\r\n\r\n        var format = $dateFormatter.getDatetimeFormat(options.timeFormat, lang);\r\n\r\n        var hoursFormat = $dateFormatter.hoursFormat(format);\r\n        var timeSeparator = $dateFormatter.timeSeparator(format);\r\n        var minutesFormat = $dateFormatter.minutesFormat(format);\r\n        var secondsFormat = $dateFormatter.secondsFormat(format);\r\n        var showSeconds = $dateFormatter.showSeconds(format);\r\n        var showAM = $dateFormatter.showAM(format);\r\n\r\n        scope.$iconUp = options.iconUp;\r\n        scope.$iconDown = options.iconDown;\r\n\r\n        // Scope methods\r\n\r\n        scope.$select = function (date, index) {\r\n          $timepicker.select(date, index);\r\n        };\r\n        scope.$moveIndex = function (value, index) {\r\n          $timepicker.$moveIndex(value, index);\r\n        };\r\n        scope.$switchMeridian = function (date) {\r\n          $timepicker.switchMeridian(date);\r\n        };\r\n\r\n        // Public methods\r\n\r\n        $timepicker.update = function (date) {\r\n          // console.warn('$timepicker.update() newValue=%o', date);\r\n          if (angular.isDate(date) && !isNaN(date.getTime())) {\r\n            $timepicker.$date = date;\r\n            angular.extend(viewDate, {\r\n              hour: date.getHours(),\r\n              minute: date.getMinutes(),\r\n              second: date.getSeconds(),\r\n              millisecond: date.getMilliseconds()\r\n            });\r\n            $timepicker.$build();\r\n          } else if (!$timepicker.$isBuilt) {\r\n            $timepicker.$build();\r\n          }\r\n        };\r\n\r\n        $timepicker.select = function (date, index, keep) {\r\n          // console.warn('$timepicker.select', date, scope.$mode);\r\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\r\n            controller.$dateValue = options.defaultDate === 'today' ? new Date() : new Date(1970, 0, 1);\r\n          }\r\n\r\n          if (!angular.isDate(date)) date = new Date(date);\r\n          if (index === 0) controller.$dateValue.setHours(date.getHours());\r\n          else if (index === 1) controller.$dateValue.setMinutes(date.getMinutes());\r\n          else if (index === 2) controller.$dateValue.setSeconds(date.getSeconds());\r\n          controller.$setViewValue(angular.copy(controller.$dateValue));\r\n          controller.$render();\r\n          if (options.autoclose && !keep) {\r\n            $timeout(function () {\r\n              $timepicker.hide(true);\r\n            });\r\n          }\r\n        };\r\n\r\n        $timepicker.switchMeridian = function (date) {\r\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\r\n            return;\r\n          }\r\n          var hours = (date || controller.$dateValue).getHours();\r\n          controller.$dateValue.setHours(hours < 12 ? hours + 12 : hours - 12);\r\n          controller.$setViewValue(angular.copy(controller.$dateValue));\r\n          controller.$render();\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $timepicker.$build = function () {\r\n          // console.warn('$timepicker.$build() viewDate=%o', viewDate);\r\n          var i;\r\n          var midIndex = scope.midIndex = parseInt(options.length / 2, 10);\r\n          var hours = [];\r\n          var hour;\r\n          for (i = 0; i < options.length; i++) {\r\n            hour = new Date(1970, 0, 1, viewDate.hour - (midIndex - i) * options.hourStep);\r\n            hours.push({\r\n              date: hour,\r\n              label: formatDate(hour, hoursFormat),\r\n              selected: $timepicker.$date && $timepicker.$isSelected(hour, 0),\r\n              disabled: $timepicker.$isDisabled(hour, 0)\r\n            });\r\n          }\r\n          var minutes = [];\r\n          var minute;\r\n          for (i = 0; i < options.length; i++) {\r\n            minute = new Date(1970, 0, 1, 0, viewDate.minute - (midIndex - i) * options.minuteStep);\r\n            minutes.push({\r\n              date: minute,\r\n              label: formatDate(minute, minutesFormat),\r\n              selected: $timepicker.$date && $timepicker.$isSelected(minute, 1),\r\n              disabled: $timepicker.$isDisabled(minute, 1)\r\n            });\r\n          }\r\n          var seconds = [];\r\n          var second;\r\n          for (i = 0; i < options.length; i++) {\r\n            second = new Date(1970, 0, 1, 0, 0, viewDate.second - (midIndex - i) * options.secondStep);\r\n            seconds.push({\r\n              date: second,\r\n              label: formatDate(second, secondsFormat),\r\n              selected: $timepicker.$date && $timepicker.$isSelected(second, 2),\r\n              disabled: $timepicker.$isDisabled(second, 2)\r\n            });\r\n          }\r\n\r\n          var rows = [];\r\n          for (i = 0; i < options.length; i++) {\r\n            if (showSeconds) {\r\n              rows.push([hours[i], minutes[i], seconds[i]]);\r\n            } else {\r\n              rows.push([hours[i], minutes[i]]);\r\n            }\r\n          }\r\n          scope.rows = rows;\r\n          scope.showSeconds = showSeconds;\r\n          scope.showAM = showAM;\r\n          scope.isAM = ($timepicker.$date || hours[midIndex].date).getHours() < 12;\r\n          scope.timeSeparator = timeSeparator;\r\n          $timepicker.$isBuilt = true;\r\n        };\r\n\r\n        $timepicker.$isSelected = function (date, index) {\r\n          if (!$timepicker.$date) return false;\r\n          else if (index === 0) {\r\n            return date.getHours() === $timepicker.$date.getHours();\r\n          } else if (index === 1) {\r\n            return date.getMinutes() === $timepicker.$date.getMinutes();\r\n          } else if (index === 2) {\r\n            return date.getSeconds() === $timepicker.$date.getSeconds();\r\n          }\r\n        };\r\n\r\n        $timepicker.$isDisabled = function (date, index) {\r\n          var selectedTime;\r\n          if (index === 0) {\r\n            selectedTime = date.getTime() + viewDate.minute * 6e4 + viewDate.second * 1e3;\r\n          } else if (index === 1) {\r\n            selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.second * 1e3;\r\n          } else if (index === 2) {\r\n            selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.minute * 6e4;\r\n          }\r\n          return selectedTime < options.minTime * 1 || selectedTime > options.maxTime * 1;\r\n        };\r\n\r\n        scope.$arrowAction = function (value, index) {\r\n          if (options.arrowBehavior === 'picker') {\r\n            $timepicker.$setTimeByStep(value, index);\r\n          } else {\r\n            $timepicker.$moveIndex(value, index);\r\n          }\r\n        };\r\n\r\n        $timepicker.$setTimeByStep = function (value, index) {\r\n          var newDate = new Date($timepicker.$date || startDate);\r\n          var hours = newDate.getHours();\r\n          var minutes = newDate.getMinutes();\r\n          var seconds = newDate.getSeconds();\r\n          if (index === 0) {\r\n            newDate.setHours(hours - (parseInt(options.hourStep, 10) * value));\r\n          } else if (index === 1) {\r\n            newDate.setMinutes(minutes - (parseInt(options.minuteStep, 10) * value));\r\n          } else if (index === 2) {\r\n            newDate.setSeconds(seconds - (parseInt(options.secondStep, 10) * value));\r\n          }\r\n          $timepicker.select(newDate, index, true);\r\n        };\r\n\r\n        $timepicker.$moveIndex = function (value, index) {\r\n          var targetDate;\r\n          if (index === 0) {\r\n            targetDate = new Date(1970, 0, 1, viewDate.hour + (value * options.length), viewDate.minute, viewDate.second);\r\n            angular.extend(viewDate, {\r\n              hour: targetDate.getHours()\r\n            });\r\n          } else if (index === 1) {\r\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute + (value * options.length * options.minuteStep), viewDate.second);\r\n            angular.extend(viewDate, {\r\n              minute: targetDate.getMinutes()\r\n            });\r\n          } else if (index === 2) {\r\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute, viewDate.second + (value * options.length * options.secondStep));\r\n            angular.extend(viewDate, {\r\n              second: targetDate.getSeconds()\r\n            });\r\n          }\r\n          $timepicker.$build();\r\n        };\r\n\r\n        $timepicker.$onMouseDown = function (evt) {\r\n          // Prevent blur on mousedown on .dropdown-menu\r\n          if (evt.target.nodeName.toLowerCase() !== 'input') evt.preventDefault();\r\n          evt.stopPropagation();\r\n          // Emulate click for mobile devices\r\n          if (isTouch) {\r\n            var targetEl = angular.element(evt.target);\r\n            if (targetEl[0].nodeName.toLowerCase() !== 'button') {\r\n              targetEl = targetEl.parent();\r\n            }\r\n            targetEl.triggerHandler('click');\r\n          }\r\n        };\r\n\r\n        $timepicker.$onKeyDown = function (evt) {\r\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n\r\n          // Close on enter\r\n          if (evt.keyCode === 13) {\r\n            $timepicker.hide(true);\r\n            return;\r\n          }\r\n\r\n          // Navigate with keyboard\r\n          var newDate = new Date($timepicker.$date);\r\n          var hours = newDate.getHours();\r\n          var hoursLength = formatDate(newDate, hoursFormat).length;\r\n          var minutes = newDate.getMinutes();\r\n          var minutesLength = formatDate(newDate, minutesFormat).length;\r\n          var seconds = newDate.getSeconds();\r\n          var secondsLength = formatDate(newDate, secondsFormat).length;\r\n          var sepLength = 1;\r\n          var lateralMove = /(37|39)/.test(evt.keyCode);\r\n          var count = 2 + showSeconds * 1 + showAM * 1;\r\n\r\n          // Navigate indexes (left, right)\r\n          if (lateralMove) {\r\n            if (evt.keyCode === 37) selectedIndex = selectedIndex < 1 ? count - 1 : selectedIndex - 1;\r\n            else if (evt.keyCode === 39) selectedIndex = selectedIndex < count - 1 ? selectedIndex + 1 : 0;\r\n          }\r\n\r\n          // Update values (up, down)\r\n          var selectRange = [0, hoursLength];\r\n          var incr = 0;\r\n          if (evt.keyCode === 38) incr = -1;\r\n          if (evt.keyCode === 40) incr = +1;\r\n          var isSeconds = selectedIndex === 2 && showSeconds;\r\n          var isMeridian = selectedIndex === 2 && !showSeconds || selectedIndex === 3 && showSeconds;\r\n          if (selectedIndex === 0) {\r\n            newDate.setHours(hours + incr * parseInt(options.hourStep, 10));\r\n            // re-calculate hours length because we have changed hours value\r\n            hoursLength = formatDate(newDate, hoursFormat).length;\r\n            selectRange = [0, hoursLength];\r\n          } else if (selectedIndex === 1) {\r\n            newDate.setMinutes(minutes + incr * parseInt(options.minuteStep, 10));\r\n            // re-calculate minutes length because we have changes minutes value\r\n            minutesLength = formatDate(newDate, minutesFormat).length;\r\n            selectRange = [hoursLength + sepLength, minutesLength];\r\n          } else if (isSeconds) {\r\n            newDate.setSeconds(seconds + incr * parseInt(options.secondStep, 10));\r\n            // re-calculate seconds length because we have changes seconds value\r\n            secondsLength = formatDate(newDate, secondsFormat).length;\r\n            selectRange = [hoursLength + sepLength + minutesLength + sepLength, secondsLength];\r\n          } else if (isMeridian) {\r\n            if (!lateralMove) $timepicker.switchMeridian();\r\n            selectRange = [hoursLength + sepLength + minutesLength + sepLength + (secondsLength + sepLength) * showSeconds, 2];\r\n          }\r\n          $timepicker.select(newDate, selectedIndex, true);\r\n          createSelection(selectRange[0], selectRange[1]);\r\n          parentScope.$digest();\r\n        };\r\n\r\n        // Private\r\n\r\n        function createSelection (start, length) {\r\n          var end = start + length;\r\n          if (element[0].createTextRange) {\r\n            var selRange = element[0].createTextRange();\r\n            selRange.collapse(true);\r\n            selRange.moveStart('character', start);\r\n            selRange.moveEnd('character', end);\r\n            selRange.select();\r\n          } else if (element[0].setSelectionRange) {\r\n            element[0].setSelectionRange(start, end);\r\n          } else if (angular.isUndefined(element[0].selectionStart)) {\r\n            element[0].selectionStart = start;\r\n            element[0].selectionEnd = end;\r\n          }\r\n        }\r\n\r\n        function focusElement () {\r\n          element[0].focus();\r\n        }\r\n\r\n        // Overrides\r\n\r\n        var _init = $timepicker.init;\r\n        $timepicker.init = function () {\r\n          if (isNative && options.useNative) {\r\n            element.prop('type', 'time');\r\n            element.css('-webkit-appearance', 'textfield');\r\n            return;\r\n          } else if (isTouch) {\r\n            element.prop('type', 'text');\r\n            element.attr('readonly', 'true');\r\n            element.on('click', focusElement);\r\n          }\r\n          _init();\r\n        };\r\n\r\n        var _destroy = $timepicker.destroy;\r\n        $timepicker.destroy = function () {\r\n          if (isNative && options.useNative) {\r\n            element.off('click', focusElement);\r\n          }\r\n          _destroy();\r\n        };\r\n\r\n        var _show = $timepicker.show;\r\n        $timepicker.show = function () {\r\n          if ((!isTouch && element.attr('readonly')) || element.attr('disabled')) return;\r\n          _show();\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed imediately.\r\n          $timeout(function () {\r\n            if ($timepicker.$element) $timepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\r\n            if (options.keyboard) {\r\n              if (element) element.on('keydown', $timepicker.$onKeyDown);\r\n            }\r\n          }, 0, false);\r\n        };\r\n\r\n        var _hide = $timepicker.hide;\r\n        $timepicker.hide = function (blur) {\r\n          if (!$timepicker.$isShown) return;\r\n          if ($timepicker.$element) $timepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\r\n          if (options.keyboard) {\r\n            if (element) element.off('keydown', $timepicker.$onKeyDown);\r\n          }\r\n          _hide(blur);\r\n        };\r\n\r\n        return $timepicker;\r\n\r\n      }\r\n\r\n      timepickerFactory.defaults = defaults;\r\n      return timepickerFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n\r\n  .directive('bsTimepicker', function ($window, $parse, $q, $dateFormatter, $dateParser, $timepicker) {\r\n\r\n    var defaults = $timepicker.defaults;\r\n    var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        // Directive options\r\n        var options = {\r\n          scope: scope\r\n        };\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'autoclose', 'timeType', 'timeFormat', 'timezone', 'modelTimeFormat', 'useNative', 'hourStep', 'minuteStep', 'secondStep', 'length', 'arrowBehavior', 'iconUp', 'iconDown', 'roundDisplay', 'id', 'prefixClass', 'prefixEvent', 'defaultDate'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container', 'autoclose', 'useNative', 'roundDisplay'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\r\n            options[key] = false;\r\n          }\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Initialize timepicker\r\n        if (isNative && (options.useNative || defaults.useNative)) options.timeFormat = 'HH:mm';\r\n        var timepicker = $timepicker(element, controller, options);\r\n        options = timepicker.$options;\r\n\r\n        var lang = options.lang;\r\n        var formatDate = function (date, format, timezone) {\r\n          return $dateFormatter.formatDate(date, format, lang, timezone);\r\n        };\r\n\r\n        // Visibility binding support\r\n        if (attr.bsShow) {\r\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\r\n            if (!timepicker || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(timepicker),?/i);\r\n            if (newValue === true) {\r\n              timepicker.show();\r\n            } else {\r\n              timepicker.hide();\r\n            }\r\n          });\r\n        }\r\n\r\n        // Initialize parser\r\n        var dateParser = $dateParser({\r\n          format: options.timeFormat,\r\n          lang: lang\r\n        });\r\n\r\n        // Observe attributes for changes\r\n        angular.forEach(['minTime', 'maxTime'], function (key) {\r\n          // console.warn('attr.$observe(%s)', key, attr[key]);\r\n          if (angular.isDefined(attr[key])) {\r\n            attr.$observe(key, function (newValue) {\r\n              timepicker.$options[key] = dateParser.getTimeForAttribute(key, newValue);\r\n              if (!isNaN(timepicker.$options[key])) timepicker.$build();\r\n              validateAgainstMinMaxTime(controller.$dateValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Watch model for changes\r\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\r\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue, controller.$dateValue);\r\n          timepicker.update(controller.$dateValue);\r\n        }, true);\r\n\r\n        function validateAgainstMinMaxTime (parsedTime) {\r\n          if (!angular.isDate(parsedTime)) return;\r\n          var isMinValid = isNaN(options.minTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) >= options.minTime;\r\n          var isMaxValid = isNaN(options.maxTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) <= options.maxTime;\r\n          var isValid = isMinValid && isMaxValid;\r\n          controller.$setValidity('date', isValid);\r\n          controller.$setValidity('min', isMinValid);\r\n          controller.$setValidity('max', isMaxValid);\r\n          // Only update the model when we have a valid date\r\n          if (!isValid) {\r\n            return;\r\n          }\r\n          controller.$dateValue = parsedTime;\r\n        }\r\n\r\n        // viewValue -> $parsers -> modelValue\r\n        controller.$parsers.unshift(function (viewValue) {\r\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\r\n          var date;\r\n          // Null values should correctly reset the model value & validity\r\n          if (!viewValue) {\r\n            // BREAKING CHANGE:\r\n            // return null (not undefined) when input value is empty, so angularjs 1.3\r\n            // ngModelController can go ahead and run validators, like ngRequired\r\n            controller.$setValidity('date', true);\r\n            return null;\r\n          }\r\n          var parsedTime = angular.isDate(viewValue) ? viewValue : dateParser.parse(viewValue, controller.$dateValue);\r\n          if (!parsedTime || isNaN(parsedTime.getTime())) {\r\n            controller.$setValidity('date', false);\r\n            // Return undefined, causes ngModelController to\r\n            // invalidate model value\r\n            return undefined;\r\n          }\r\n          validateAgainstMinMaxTime(parsedTime);\r\n\r\n          if (options.timeType === 'string') {\r\n            date = dateParser.timezoneOffsetAdjust(parsedTime, options.timezone, true);\r\n            return formatDate(date, options.modelTimeFormat || options.timeFormat);\r\n          }\r\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\r\n          if (options.timeType === 'number') {\r\n            return date.getTime();\r\n          } else if (options.timeType === 'unix') {\r\n            return date.getTime() / 1000;\r\n          } else if (options.timeType === 'iso') {\r\n            return date.toISOString();\r\n          }\r\n          return new Date(date);\r\n        });\r\n\r\n        // modelValue -> $formatters -> viewValue\r\n        controller.$formatters.push(function (modelValue) {\r\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n          var date;\r\n          if (angular.isUndefined(modelValue) || modelValue === null) {\r\n            date = NaN;\r\n          } else if (angular.isDate(modelValue)) {\r\n            date = modelValue;\r\n          } else if (options.timeType === 'string') {\r\n            date = dateParser.parse(modelValue, null, options.modelTimeFormat);\r\n          } else if (options.timeType === 'unix') {\r\n            date = new Date(modelValue * 1000);\r\n          } else {\r\n            date = new Date(modelValue);\r\n          }\r\n          // Setup default value?\r\n          // if(isNaN(date.getTime())) date = new Date(new Date().setMinutes(0) + 36e5);\r\n          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\r\n          return getTimeFormattedString();\r\n        });\r\n\r\n        // viewValue -> element\r\n        controller.$render = function () {\r\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\r\n          element.val(getTimeFormattedString());\r\n        };\r\n\r\n        function getTimeFormattedString () {\r\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.timeFormat);\r\n        }\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (timepicker) timepicker.destroy();\r\n          options = null;\r\n          timepicker = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.tab', [])\r\n\r\n  .provider('$tab', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      template: 'tab/tab.tpl.html',\r\n      navClass: 'nav-tabs',\r\n      activeClass: 'active',\r\n      isVertical: false\r\n    };\r\n    var _tabsHash = {};\r\n\r\n    var _addTabControl = function (key, control) {\r\n      if (!_tabsHash[key]) _tabsHash[key] = control;\r\n    };\r\n\r\n    var controller = this.controller = function ($scope, $element, $attrs, $timeout) {\r\n      var self = this;\r\n\r\n      // Attributes options\r\n      self.$options = angular.copy(defaults);\r\n      angular.forEach(['animation', 'navClass', 'activeClass', 'id', 'isVertical'], function (key) {\r\n        if (angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\r\n      });\r\n\r\n      // use string regex match boolean attr falsy values, leave truthy values be\r\n      var falseValueRegExp = /^(false|0|)$/i;\r\n      angular.forEach(['isVertical'], function (key) {\r\n        if (angular.isDefined($attrs[key]) && falseValueRegExp.test($attrs[key])) self.$options[key] = false;\r\n      });\r\n\r\n      // Publish options on scope\r\n      $scope.$navClass = self.$options.navClass;\r\n      $scope.$activeClass = self.$options.activeClass;\r\n\r\n      $scope.$onClick = function $onClick (evt, pane, index) {\r\n        if (!pane.disabled) {\r\n          self.$setActive(pane.name || index);\r\n          focusCurrentTab();\r\n        }\r\n\r\n        evt.preventDefault();\r\n        evt.stopPropagation();\r\n      };\r\n\r\n      function navigatePane (index, toLeft) {\r\n        var newIndex = 0;\r\n\r\n        if (toLeft) {\r\n          // Moving to the left\r\n          newIndex = index - 1 < 0 ? (self.$panes.length - 1) : (index - 1);\r\n        } else {\r\n          // Moving to the right\r\n          newIndex = (index + 1) >= self.$panes.length ? 0 : (index + 1);\r\n        }\r\n\r\n        if (self.$panes[newIndex].disabled) {\r\n          navigatePane(newIndex, toLeft);\r\n        } else {\r\n          self.$setActive(self.$panes[newIndex].name || newIndex);\r\n          focusCurrentTab();\r\n        }\r\n      }\r\n\r\n      function focusCurrentTab () {\r\n        $timeout(function () {\r\n          var activeAs = angular.element($element[0].querySelectorAll('li.' + self.$options.activeClass));\r\n\r\n          if (activeAs.length > 0 && activeAs[0]) {\r\n            activeAs[0].focus();\r\n          }\r\n        }, 100);\r\n      }\r\n\r\n      self.$panes = $scope.$panes = [];\r\n\r\n      // Please use $activePaneChangeListeners if you use `bsActivePane`\r\n      // Because we removed `ngModel` as default, we rename viewChangeListeners to\r\n      // activePaneChangeListeners to make more sense.\r\n      self.$activePaneChangeListeners = self.$viewChangeListeners = [];\r\n\r\n      self.$push = function (pane) {\r\n        if (angular.isUndefined(self.$panes.$active)) {\r\n          $scope.$setActive(pane.name || 0);\r\n        }\r\n\r\n        self.$panes.push(pane);\r\n\r\n        self.$panes.forEach(function (tabPane, index) {\r\n          // Set an id value for the pane so that it can be used in the template\r\n          tabPane.$describedBy = self.$options.id === undefined ? undefined : self.$options.id + '_$tab_' + index;\r\n          tabPane.$labeledBy = self.$options.id === undefined ? undefined : self.$options.id + '_$tab_' + index + '_a';\r\n        });\r\n      };\r\n\r\n      self.$remove = function (pane) {\r\n        var index = self.$panes.indexOf(pane);\r\n        var active = self.$panes.$active;\r\n        var activeIndex;\r\n        if (angular.isString(active)) {\r\n          activeIndex = self.$panes.map(function (pane) {\r\n            return pane.name;\r\n          }).indexOf(active);\r\n        } else {\r\n          activeIndex = self.$panes.$active;\r\n        }\r\n\r\n        // remove pane from $panes array\r\n        self.$panes.splice(index, 1);\r\n\r\n        if (index < activeIndex) {\r\n          // we removed a pane before the active pane, so we need to\r\n          // decrement the active pane index\r\n          activeIndex--;\r\n        } else if (index === activeIndex && activeIndex === self.$panes.length) {\r\n          // we remove the active pane and it was the one at the end,\r\n          // so select the previous one\r\n          activeIndex--;\r\n        }\r\n        if (activeIndex >= 0 && activeIndex < self.$panes.length) {\r\n          self.$setActive(self.$panes[activeIndex].name || activeIndex);\r\n        } else {\r\n          self.$setActive();\r\n        }\r\n      };\r\n\r\n      self.$setActive = $scope.$setActive = function (value) {\r\n        self.$panes.$active = value;\r\n        self.$activePaneChangeListeners.forEach(function (fn) {\r\n          fn();\r\n        });\r\n      };\r\n\r\n      self.$isActive = $scope.$isActive = function ($pane, $index) {\r\n        return self.$panes.$active === $pane.name || self.$panes.$active === $index;\r\n      };\r\n\r\n      self.$onKeyPress = $scope.$onKeyPress = function (e, name, index) {\r\n        if (e.keyCode === 32 || e.charCode === 32 || e.keyCode === 13 || e.charCode === 13) {\r\n          // If space or enter was pressed\r\n          self.$setActive(name);\r\n\r\n          e.preventDefault();\r\n          e.stopPropagation();\r\n\r\n        } else if (!self.$options.isVertical && (e.keyCode === 37 || e.charCode === 37 || e.keyCode === 39 || e.charCode === 39)) {\r\n          // If the left of right arrow key was pressed.\r\n          navigatePane(index, (e.keyCode === 37 || e.charCode === 37));\r\n        } else if (self.$options.isVertical && (e.keyCode === 38 || e.charCode === 38 || e.keyCode === 40 || e.charCode === 40)) {\r\n          // If the left of right arrow key was pressed.\r\n          navigatePane(index, (e.keyCode === 38 || e.charCode === 38));\r\n        }\r\n      };\r\n    };\r\n\r\n    this.$get = function () {\r\n      var $tab = {};\r\n      $tab.defaults = defaults;\r\n      $tab.controller = controller;\r\n      $tab.addTabControl = _addTabControl;\r\n      $tab.tabsHash = _tabsHash;\r\n      return $tab;\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsTabs', function ($window, $animate, $tab, $parse, $timeout) {\r\n\r\n    var defaults = $tab.defaults;\r\n\r\n    return {\r\n      require: ['?ngModel', 'bsTabs'],\r\n      transclude: true,\r\n      scope: true,\r\n      controller: ['$scope', '$element', '$attrs', '$timeout', $tab.controller],\r\n      templateUrl: function (element, attr) {\r\n        return attr.template || defaults.template;\r\n      },\r\n      link: function postLink (scope, element, attrs, controllers) {\r\n\r\n        var ngModelCtrl = controllers[0];\r\n        var bsTabsCtrl = controllers[1];\r\n\r\n        // Add a way for developers to access tab scope if needed.  This allows for more fine grained control over what\r\n        // tabs are available in the tab component\r\n        if (attrs.tabKey !== '' && attrs.tabKey !== undefined) {\r\n          $tab.addTabControl(attrs.tabKey, bsTabsCtrl);\r\n        }\r\n\r\n        // 'ngModel' does interfere with form validation\r\n        // and status, use `bsActivePane` instead to avoid it\r\n        if (ngModelCtrl) {\r\n\r\n          // Update the modelValue following\r\n          bsTabsCtrl.$activePaneChangeListeners.push(function () {\r\n            ngModelCtrl.$setViewValue(bsTabsCtrl.$panes.$active);\r\n          });\r\n\r\n          // modelValue -> $formatters -> viewValue\r\n          ngModelCtrl.$formatters.push(function (modelValue) {\r\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n            bsTabsCtrl.$setActive(modelValue);\r\n            return modelValue;\r\n          });\r\n        }\r\n\r\n        bsTabsCtrl.$activePaneChangeListeners.push(function () {\r\n          $timeout(function () {\r\n            // get li elements\r\n            var liElements = element.find('li');\r\n            for (var i = 0; i < liElements.length; i++) {\r\n              var iElement = angular.element(liElements[i]);\r\n              if (iElement.hasClass(bsTabsCtrl.$options.activeClass)) {\r\n                // if li is active, set focus to it.\r\n                iElement.find('a')[0].focus();\r\n              }\r\n            }\r\n            // delay, for the class (.active) change to reflect in DOM.\r\n          }, 100);\r\n        });\r\n\r\n        if (attrs.bsActivePane) {\r\n          // adapted from angularjs ngModelController bindings\r\n          // https://github.com/angular/angular.js/blob/v1.3.1/src%2Fng%2Fdirective%2Finput.js#L1730\r\n          var parsedBsActivePane = $parse(attrs.bsActivePane);\r\n\r\n          // Update bsActivePane value with change\r\n          bsTabsCtrl.$activePaneChangeListeners.push(function () {\r\n            parsedBsActivePane.assign(scope, bsTabsCtrl.$panes.$active);\r\n          });\r\n\r\n          // watch bsActivePane for value changes\r\n          scope.$watch(attrs.bsActivePane, function (newValue, oldValue) {\r\n            bsTabsCtrl.$setActive(newValue);\r\n          }, true);\r\n        }\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsPane', function ($window, $animate, $sce) {\r\n\r\n    return {\r\n      require: ['^?ngModel', '^bsTabs'],\r\n      scope: true,\r\n      link: function postLink (scope, element, attrs, controllers) {\r\n\r\n        // var ngModelCtrl = controllers[0];\r\n        var bsTabsCtrl = controllers[1];\r\n\r\n        // Add base class\r\n        element.addClass('tab-pane');\r\n\r\n        // Set up the assistive attributes\r\n        element.attr('role', 'tabpanel');\r\n\r\n        // Observe title attribute for change\r\n        attrs.$observe('title', function (newValue, oldValue) {\r\n          scope.title = $sce.trustAsHtml(newValue);\r\n        });\r\n\r\n        // Save tab name into scope\r\n        scope.name = attrs.name;\r\n        // Save tab id into scope\r\n        scope.id = attrs.id;\r\n\r\n        scope.name = scope.name || scope.id;\r\n\r\n        // Add animation class\r\n        if (bsTabsCtrl.$options.animation) {\r\n          element.addClass(bsTabsCtrl.$options.animation);\r\n        }\r\n\r\n        attrs.$observe('disabled', function (newValue, oldValue) {\r\n          scope.disabled = scope.$eval(newValue);\r\n        });\r\n\r\n        // Push pane to parent bsTabs controller\r\n        bsTabsCtrl.$push(scope);\r\n\r\n        // Once the push has occured when can then update the element with some properties.\r\n        // Update the aria-describedby attribute\r\n        if (scope.$describedBy !== undefined) {\r\n          element.attr('aria-describedby', scope.$describedBy);\r\n        }\r\n\r\n        // remove pane from tab controller when pane is destroyed\r\n        scope.$on('$destroy', function () {\r\n          bsTabsCtrl.$remove(scope);\r\n        });\r\n\r\n        function render () {\r\n          var index = bsTabsCtrl.$panes.indexOf(scope);\r\n\r\n          $animate[bsTabsCtrl.$isActive(scope, index) ? 'addClass' : 'removeClass'](element, bsTabsCtrl.$options.activeClass);\r\n        }\r\n\r\n        bsTabsCtrl.$activePaneChangeListeners.push(function () {\r\n          render();\r\n        });\r\n        render();\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.select', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\r\n\r\n  .provider('$select', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      prefixClass: 'select',\r\n      prefixEvent: '$select',\r\n      placement: 'bottom-left',\r\n      templateUrl: 'select/select.tpl.html',\r\n      trigger: 'focus',\r\n      container: false,\r\n      keyboard: true,\r\n      html: false,\r\n      delay: 0,\r\n      multiple: false,\r\n      allNoneButtons: false,\r\n      sort: true,\r\n      caretHtml: '&nbsp;<span class=\"caret\"></span>',\r\n      placeholder: 'Choose among the following...',\r\n      allText: 'All',\r\n      noneText: 'None',\r\n      maxLength: 3,\r\n      maxLengthHtml: 'selected',\r\n      iconCheckmark: 'glyphicon glyphicon-ok',\r\n      toggle: false\r\n    };\r\n\r\n    this.$get = function ($window, $document, $rootScope, $tooltip, $timeout) {\r\n\r\n      // var bodyEl = angular.element($window.document.body);\r\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n      var isTouch = ('createTouch' in $window.document) && isNative;\r\n\r\n      function SelectFactory (element, controller, config) {\r\n\r\n        var $select = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n\r\n        $select = $tooltip(element, options);\r\n        var scope = $select.$scope;\r\n\r\n        scope.$matches = [];\r\n        if (options.multiple) {\r\n          scope.$activeIndex = [];\r\n        } else {\r\n          scope.$activeIndex = -1;\r\n        }\r\n        scope.$isMultiple = options.multiple;\r\n        scope.$showAllNoneButtons = options.allNoneButtons && options.multiple;\r\n        scope.$iconCheckmark = options.iconCheckmark;\r\n        scope.$allText = options.allText;\r\n        scope.$noneText = options.noneText;\r\n\r\n        scope.$activate = function (index) {\r\n          scope.$$postDigest(function () {\r\n            $select.activate(index);\r\n          });\r\n        };\r\n\r\n        scope.$select = function (index, evt) {\r\n          scope.$$postDigest(function () {\r\n            $select.select(index);\r\n          });\r\n        };\r\n\r\n        scope.$isVisible = function () {\r\n          return $select.$isVisible();\r\n        };\r\n\r\n        scope.$isActive = function (index) {\r\n          return $select.$isActive(index);\r\n        };\r\n\r\n        scope.$selectAll = function () {\r\n          for (var i = 0; i < scope.$matches.length; i++) {\r\n            if (!scope.$isActive(i)) {\r\n              scope.$select(i);\r\n            }\r\n          }\r\n        };\r\n\r\n        scope.$selectNone = function () {\r\n          for (var i = 0; i < scope.$matches.length; i++) {\r\n            if (scope.$isActive(i)) {\r\n              scope.$select(i);\r\n            }\r\n          }\r\n        };\r\n\r\n        // Public methods\r\n\r\n        $select.update = function (matches) {\r\n          scope.$matches = matches;\r\n          $select.$updateActiveIndex();\r\n        };\r\n\r\n        $select.activate = function (index) {\r\n          if (options.multiple) {\r\n            if ($select.$isActive(index)) {\r\n              scope.$activeIndex.splice(scope.$activeIndex.indexOf(index), 1);\r\n            } else {\r\n              scope.$activeIndex.push(index);\r\n            }\r\n            if (options.sort) scope.$activeIndex.sort(function (a, b) { return a - b; }); // use numeric sort instead of default sort\r\n          } else {\r\n            scope.$activeIndex = index;\r\n          }\r\n          return scope.$activeIndex;\r\n        };\r\n\r\n        $select.select = function (index) {\r\n          if (angular.isUndefined(index) || index < 0 || index >= scope.$matches.length) { return; }\r\n          var value = scope.$matches[index].value;\r\n          scope.$apply(function () {\r\n            $select.activate(index);\r\n            if (options.multiple) {\r\n              controller.$setViewValue(scope.$activeIndex.map(function (index) {\r\n                if (angular.isUndefined(scope.$matches[index])) {\r\n                  return null;\r\n                }\r\n                return scope.$matches[index].value;\r\n              }));\r\n            } else {\r\n              if (options.toggle) {\r\n                controller.$setViewValue((value === controller.$modelValue) ? undefined : value);\r\n              } else {\r\n                controller.$setViewValue(value);\r\n              }\r\n              // Hide if single select\r\n              $select.hide();\r\n            }\r\n          });\r\n          // Emit event\r\n          scope.$emit(options.prefixEvent + '.select', value, index, $select);\r\n          if (angular.isDefined(options.onSelect) && angular.isFunction(options.onSelect)) {\r\n            options.onSelect(value, index, $select);\r\n          }\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $select.$updateActiveIndex = function () {\r\n          if (options.multiple) {\r\n            if (angular.isArray(controller.$modelValue)) {\r\n              scope.$activeIndex = controller.$modelValue.map(function (value) {\r\n                return $select.$getIndex(value);\r\n              });\r\n            } else {\r\n              scope.$activeIndex = [];\r\n            }\r\n          } else {\r\n            if (angular.isDefined(controller.$modelValue) && scope.$matches.length) {\r\n              scope.$activeIndex = $select.$getIndex(controller.$modelValue);\r\n            } else {\r\n              scope.$activeIndex = -1;\r\n            }\r\n          }\r\n        };\r\n\r\n        $select.$isVisible = function () {\r\n          if (!options.minLength || !controller) {\r\n            return scope.$matches.length;\r\n          }\r\n          // minLength support\r\n          return scope.$matches.length && controller.$viewValue.length >= options.minLength;\r\n        };\r\n\r\n        $select.$isActive = function (index) {\r\n          if (options.multiple) {\r\n            return scope.$activeIndex.indexOf(index) !== -1;\r\n          }\r\n          return scope.$activeIndex === index;\r\n        };\r\n\r\n        $select.$getIndex = function (value) {\r\n          var index;\r\n          for (index = scope.$matches.length; index--;) {\r\n            if (angular.equals(scope.$matches[index].value, value)) break;\r\n          }\r\n          return index;\r\n        };\r\n\r\n        $select.$onMouseDown = function (evt) {\r\n          // Prevent blur on mousedown on .dropdown-menu\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n          // Emulate click for mobile devices\r\n          if (isTouch) {\r\n            var targetEl = angular.element(evt.target);\r\n            var anchor;\r\n\r\n            if (evt.target.nodeName !== 'A') {\r\n              var anchorCandidate = targetEl.parent();\r\n              while (!anchor && anchorCandidate.length > 0) {\r\n                if (anchorCandidate[0].nodeName === 'A') {\r\n                  anchor = anchorCandidate;\r\n                }\r\n                anchorCandidate = anchorCandidate.parent();\r\n              }\r\n            }\r\n\r\n            if (anchor) {\r\n              angular.element(anchor).triggerHandler('click');\r\n            } else {\r\n              targetEl.triggerHandler('click');\r\n            }\r\n          }\r\n        };\r\n\r\n        $select.$onKeyDown = function (evt) {\r\n          if (!/(9|13|38|40)/.test(evt.keyCode)) return;\r\n          // Let tab propagate\r\n          if (evt.keyCode !== 9) {\r\n            evt.preventDefault();\r\n            evt.stopPropagation();\r\n          }\r\n\r\n          // release focus on tab\r\n          if (options.multiple && evt.keyCode === 9) {\r\n            return $select.hide();\r\n          }\r\n\r\n          // Select with enter\r\n          if (!options.multiple && (evt.keyCode === 13 || evt.keyCode === 9)) {\r\n            return $select.select(scope.$activeIndex);\r\n          }\r\n\r\n          if (!options.multiple) {\r\n            // Navigate with keyboard\r\n            if (evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;\r\n            else if (evt.keyCode === 38 && scope.$activeIndex < 0) scope.$activeIndex = scope.$matches.length - 1;\r\n            else if (evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;\r\n            else if (angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;\r\n            scope.$digest();\r\n          }\r\n        };\r\n\r\n        $select.$isIE = function () {\r\n          var ua = $window.navigator.userAgent;\r\n          return ua.indexOf('MSIE ') > 0 || ua.indexOf('Trident/') > 0 || ua.indexOf('Edge/') > 0;\r\n        };\r\n\r\n        $select.$selectScrollFix = function (e) {\r\n          if ($document[0].activeElement.tagName === 'UL') {\r\n            e.preventDefault();\r\n            e.stopImmediatePropagation();\r\n            e.target.focus();\r\n          }\r\n        };\r\n\r\n        // Overrides\r\n\r\n        var _show = $select.show;\r\n        $select.show = function () {\r\n          _show();\r\n          if (options.multiple) {\r\n            $select.$element.addClass('select-multiple');\r\n          }\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed imediately.\r\n          $timeout(function () {\r\n            $select.$element.on(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\r\n            if (options.keyboard) {\r\n              element.on('keydown', $select.$onKeyDown);\r\n            }\r\n          }, 0, false);\r\n        };\r\n\r\n        var _hide = $select.hide;\r\n        $select.hide = function () {\r\n          if (!options.multiple && angular.isUndefined(controller.$modelValue)) {\r\n            scope.$activeIndex = -1;\r\n          }\r\n          $select.$element.off(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\r\n          if (options.keyboard) {\r\n            element.off('keydown', $select.$onKeyDown);\r\n          }\r\n          _hide(true);\r\n        };\r\n\r\n        return $select;\r\n\r\n      }\r\n\r\n      SelectFactory.defaults = defaults;\r\n      return SelectFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsSelect', function ($window, $parse, $q, $select, $parseOptions) {\r\n\r\n    var defaults = $select.defaults;\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        // Directive options\r\n        var options = {scope: scope, placeholder: defaults.placeholder};\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'placeholder', 'allNoneButtons', 'maxLength', 'maxLengthHtml', 'allText', 'noneText', 'iconCheckmark', 'autoClose', 'id', 'sort', 'caretHtml', 'prefixClass', 'prefixEvent', 'toggle'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container', 'allNoneButtons', 'sort'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\r\n            options[key] = false;\r\n          }\r\n        });\r\n\r\n        // bind functions from the attrs to the show, hide and select events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide', 'onSelect'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Only parse data-multiple. Angular sets existence attributes to true (multiple/required/etc), they apply this\r\n        // to data-multiple as well for some reason, so we'll parse this ourselves and disregard multiple\r\n        var dataMultiple = element.attr('data-multiple');\r\n        if (angular.isDefined(dataMultiple)) {\r\n          if (falseValueRegExp.test(dataMultiple)) {\r\n            options.multiple = false;\r\n          } else {\r\n            options.multiple = dataMultiple;\r\n          }\r\n        }\r\n\r\n        // Add support for select markup\r\n        if (element[0].nodeName.toLowerCase() === 'select') {\r\n          var inputEl = element;\r\n          inputEl.css('display', 'none');\r\n          element = angular.element('<button type=\"button\" class=\"btn btn-default\" aria-haspopup=\"true\"></button>');\r\n          inputEl.after(element);\r\n        }\r\n\r\n        // Build proper bsOptions\r\n        var parsedOptions = $parseOptions(attr.bsOptions);\r\n\r\n        // Initialize select\r\n        var select = $select(element, controller, options);\r\n\r\n        if (select.$isIE()) {\r\n          element[0].addEventListener('blur', select.$selectScrollFix);\r\n        }\r\n\r\n        // Watch bsOptions values before filtering for changes\r\n        var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').trim();\r\n        scope.$watch(watchedOptions, function (newValue, oldValue) {\r\n          // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\r\n          parsedOptions.valuesFn(scope, controller)\r\n          .then(function (values) {\r\n            select.update(values);\r\n            controller.$render();\r\n          });\r\n        }, true);\r\n\r\n        // Watch model for changes\r\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\r\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue);\r\n          select.$updateActiveIndex();\r\n          controller.$render();\r\n        }, true);\r\n\r\n        // Model rendering in view\r\n        controller.$render = function () {\r\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\r\n          var selected;\r\n          var index;\r\n          if (options.multiple && angular.isArray(controller.$modelValue)) {\r\n            selected = controller.$modelValue.map(function (value) {\r\n              index = select.$getIndex(value);\r\n              return index !== -1 ? select.$scope.$matches[index].label : false;\r\n            }).filter(angular.isDefined);\r\n            if (selected.length > (options.maxLength || defaults.maxLength)) {\r\n              selected = selected.length + ' ' + (options.maxLengthHtml || defaults.maxLengthHtml);\r\n            } else {\r\n              selected = selected.join(', ');\r\n            }\r\n          } else {\r\n            index = select.$getIndex(controller.$modelValue);\r\n            selected = index !== -1 ? select.$scope.$matches[index].label : false;\r\n          }\r\n          element.html((selected || options.placeholder) + (options.caretHtml || defaults.caretHtml));\r\n        };\r\n\r\n        if (options.multiple) {\r\n          controller.$isEmpty = function (value) {\r\n            return !value || value.length === 0;\r\n          };\r\n        }\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (select) select.destroy();\r\n          options = null;\r\n          select = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.scrollspy', ['mgcrea.ngStrap.helpers.debounce', 'mgcrea.ngStrap.helpers.dimensions'])\r\n\r\n  .provider('$scrollspy', function () {\r\n\r\n    // Pool of registered spies\r\n    var spies = this.$$spies = {};\r\n\r\n    var defaults = this.defaults = {\r\n      debounce: 150,\r\n      throttle: 100,\r\n      offset: 100\r\n    };\r\n\r\n    this.$get = function ($window, $document, $rootScope, dimensions, debounce, throttle) {\r\n\r\n      var windowEl = angular.element($window);\r\n      var docEl = angular.element($document.prop('documentElement'));\r\n      var bodyEl = angular.element($window.document.body);\r\n\r\n      // Helper functions\r\n\r\n      function nodeName (element, name) {\r\n        return element[0].nodeName && element[0].nodeName.toLowerCase() === name.toLowerCase();\r\n      }\r\n\r\n      function ScrollSpyFactory (config) {\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n        if (!options.element) options.element = bodyEl;\r\n        var isWindowSpy = nodeName(options.element, 'body');\r\n        var scrollEl = isWindowSpy ? windowEl : options.element;\r\n        var scrollId = isWindowSpy ? 'window' : options.id;\r\n\r\n        // Use existing spy\r\n        if (spies[scrollId]) {\r\n          spies[scrollId].$$count++;\r\n          return spies[scrollId];\r\n        }\r\n\r\n        var $scrollspy = {};\r\n\r\n        // Private vars\r\n        var unbindViewContentLoaded;\r\n        var unbindIncludeContentLoaded;\r\n        var trackedElements = $scrollspy.$trackedElements = [];\r\n        var sortedElements = [];\r\n        var activeTarget;\r\n        var debouncedCheckPosition;\r\n        var throttledCheckPosition;\r\n        var debouncedCheckOffsets;\r\n        /* eslint-disable no-unused-vars */\r\n        var viewportHeight;\r\n        /* eslint-enable no-unused-vars */\r\n        var scrollTop;\r\n\r\n        $scrollspy.init = function () {\r\n\r\n          // Setup internal ref counter\r\n          this.$$count = 1;\r\n\r\n          // Bind events\r\n          debouncedCheckPosition = debounce(this.checkPosition, options.debounce);\r\n          throttledCheckPosition = throttle(this.checkPosition, options.throttle);\r\n          scrollEl.on('click', this.checkPositionWithEventLoop);\r\n          windowEl.on('resize', debouncedCheckPosition);\r\n          scrollEl.on('scroll', throttledCheckPosition);\r\n\r\n          debouncedCheckOffsets = debounce(this.checkOffsets, options.debounce);\r\n          unbindViewContentLoaded = $rootScope.$on('$viewContentLoaded', debouncedCheckOffsets);\r\n          unbindIncludeContentLoaded = $rootScope.$on('$includeContentLoaded', debouncedCheckOffsets);\r\n          debouncedCheckOffsets();\r\n\r\n          // Register spy for reuse\r\n          if (scrollId) {\r\n            spies[scrollId] = $scrollspy;\r\n          }\r\n\r\n        };\r\n\r\n        $scrollspy.destroy = function () {\r\n\r\n          // Check internal ref counter\r\n          this.$$count--;\r\n          if (this.$$count > 0) {\r\n            return;\r\n          }\r\n\r\n          // Unbind events\r\n          scrollEl.off('click', this.checkPositionWithEventLoop);\r\n          windowEl.off('resize', debouncedCheckPosition);\r\n          scrollEl.off('scroll', throttledCheckPosition);\r\n          unbindViewContentLoaded();\r\n          unbindIncludeContentLoaded();\r\n          if (scrollId) {\r\n            delete spies[scrollId];\r\n          }\r\n        };\r\n\r\n        $scrollspy.checkPosition = function () {\r\n\r\n          // Not ready yet\r\n          if (!sortedElements.length) return;\r\n\r\n          // Calculate the scroll position\r\n          scrollTop = (isWindowSpy ? $window.pageYOffset : scrollEl.prop('scrollTop')) || 0;\r\n\r\n          // Calculate the viewport height for use by the components\r\n          viewportHeight = Math.max($window.innerHeight, docEl.prop('clientHeight'));\r\n\r\n          // Activate first element if scroll is smaller\r\n          if (scrollTop < sortedElements[0].offsetTop && activeTarget !== sortedElements[0].target) {\r\n            return $scrollspy.$activateElement(sortedElements[0]);\r\n          }\r\n\r\n          // Activate proper element\r\n          for (var i = sortedElements.length; i--;) {\r\n            if (angular.isUndefined(sortedElements[i].offsetTop) || sortedElements[i].offsetTop === null) continue;\r\n            if (activeTarget === sortedElements[i].target) continue;\r\n            if (scrollTop < sortedElements[i].offsetTop) continue;\r\n            if (sortedElements[i + 1] && scrollTop > sortedElements[i + 1].offsetTop) continue;\r\n            return $scrollspy.$activateElement(sortedElements[i]);\r\n          }\r\n\r\n        };\r\n\r\n        $scrollspy.checkPositionWithEventLoop = function () {\r\n          // IE 9 throws an error if we use 'this' instead of '$scrollspy'\r\n          // in this setTimeout call\r\n          setTimeout($scrollspy.checkPosition, 1);\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $scrollspy.$activateElement = function (element) {\r\n          if (activeTarget) {\r\n            var activeElement = $scrollspy.$getTrackedElement(activeTarget);\r\n            if (activeElement) {\r\n              activeElement.source.removeClass('active');\r\n              if (nodeName(activeElement.source, 'li') && nodeName(activeElement.source.parent().parent(), 'li')) {\r\n                activeElement.source.parent().parent().removeClass('active');\r\n              }\r\n            }\r\n          }\r\n          activeTarget = element.target;\r\n          element.source.addClass('active');\r\n          if (nodeName(element.source, 'li') && nodeName(element.source.parent().parent(), 'li')) {\r\n            element.source.parent().parent().addClass('active');\r\n          }\r\n        };\r\n\r\n        $scrollspy.$getTrackedElement = function (target) {\r\n          return trackedElements.filter(function (obj) {\r\n            return obj.target === target;\r\n          })[0];\r\n        };\r\n\r\n        // Track offsets behavior\r\n\r\n        $scrollspy.checkOffsets = function () {\r\n\r\n          angular.forEach(trackedElements, function (trackedElement) {\r\n            var targetElement = document.querySelector(trackedElement.target);\r\n            trackedElement.offsetTop = targetElement ? dimensions.offset(targetElement).top : null;\r\n            if (options.offset && trackedElement.offsetTop !== null) trackedElement.offsetTop -= options.offset * 1;\r\n          });\r\n\r\n          sortedElements = trackedElements\r\n          .filter(function (el) {\r\n            return el.offsetTop !== null;\r\n          })\r\n          .sort(function (a, b) {\r\n            return a.offsetTop - b.offsetTop;\r\n          });\r\n\r\n          debouncedCheckPosition();\r\n\r\n        };\r\n\r\n        $scrollspy.trackElement = function (target, source) {\r\n          trackedElements.push({target: target, source: source});\r\n        };\r\n\r\n        $scrollspy.untrackElement = function (target, source) {\r\n          var toDelete;\r\n          for (var i = trackedElements.length; i--;) {\r\n            if (trackedElements[i].target === target && trackedElements[i].source === source) {\r\n              toDelete = i;\r\n              break;\r\n            }\r\n          }\r\n          trackedElements.splice(toDelete, 1);\r\n        };\r\n\r\n        $scrollspy.activate = function (i) {\r\n          trackedElements[i].addClass('active');\r\n        };\r\n\r\n        // Initialize plugin\r\n\r\n        $scrollspy.init();\r\n        return $scrollspy;\r\n\r\n      }\r\n\r\n      return ScrollSpyFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsScrollspy', function ($rootScope, debounce, dimensions, $scrollspy) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      link: function postLink (scope, element, attr) {\r\n\r\n        var options = {scope: scope};\r\n        angular.forEach(['offset', 'target'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        var scrollspy = $scrollspy(options);\r\n        scrollspy.trackElement(options.target, element);\r\n\r\n        scope.$on('$destroy', function () {\r\n          if (scrollspy) {\r\n            scrollspy.untrackElement(options.target, element);\r\n            scrollspy.destroy();\r\n          }\r\n          options = null;\r\n          scrollspy = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n\r\n  .directive('bsScrollspyList', function ($rootScope, debounce, dimensions, $scrollspy) {\r\n\r\n    return {\r\n      restrict: 'A',\r\n      compile: function postLink (element, attr) {\r\n        var children = element[0].querySelectorAll('li > a[href]');\r\n        angular.forEach(children, function (child) {\r\n          var childEl = angular.element(child);\r\n          childEl.parent().attr('bs-scrollspy', '').attr('data-target', childEl.attr('href'));\r\n        });\r\n      }\r\n\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.popover', ['mgcrea.ngStrap.tooltip'])\r\n\r\n  .provider('$popover', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      customClass: '',\r\n      // uncommenting the next two lines will break backwards compatability\r\n      // prefixClass: 'popover',\r\n      // prefixEvent: 'popover',\r\n      container: false,\r\n      target: false,\r\n      placement: 'right',\r\n      templateUrl: 'popover/popover.tpl.html',\r\n      contentTemplate: false,\r\n      trigger: 'click',\r\n      keyboard: true,\r\n      html: false,\r\n      title: '',\r\n      content: '',\r\n      delay: 0,\r\n      autoClose: false\r\n    };\r\n\r\n    this.$get = function ($tooltip) {\r\n\r\n      function PopoverFactory (element, config) {\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n\r\n        var $popover = $tooltip(element, options);\r\n\r\n        // Support scope as string options [/*title, */content]\r\n        if (options.content) {\r\n          $popover.$scope.content = options.content;\r\n        }\r\n\r\n        return $popover;\r\n\r\n      }\r\n\r\n      return PopoverFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsPopover', function ($window, $sce, $popover) {\r\n\r\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink (scope, element, attr) {\r\n\r\n        var popover;\r\n        // Directive options\r\n        var options = {scope: scope};\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'customClass', 'autoClose', 'id', 'prefixClass', 'prefixEvent', 'bsEnabled'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container', 'autoClose'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // should not parse target attribute (anchor tag), only data-target #1454\r\n        var dataTarget = element.attr('data-target');\r\n        if (angular.isDefined(dataTarget)) {\r\n          if (falseValueRegExp.test(dataTarget)) {\r\n            options.target = false;\r\n          } else {\r\n            options.target = dataTarget;\r\n          }\r\n        }\r\n\r\n        // Support scope as data-attrs\r\n        angular.forEach(['title', 'content'], function (key) {\r\n          if (attr[key]) {\r\n            attr.$observe(key, function (newValue, oldValue) {\r\n              scope[key] = $sce.trustAsHtml(newValue);\r\n              if (angular.isDefined(oldValue)) {\r\n                requestAnimationFrame(function () {\r\n                  if (popover) popover.$applyPlacement();\r\n                });\r\n              }\r\n            });\r\n          }\r\n        });\r\n\r\n        // Support scope as an object\r\n        if (attr.bsPopover) {\r\n          scope.$watch(attr.bsPopover, function (newValue, oldValue) {\r\n            if (angular.isObject(newValue)) {\r\n              angular.extend(scope, newValue);\r\n            } else {\r\n              scope.content = newValue;\r\n            }\r\n            if (angular.isDefined(oldValue)) {\r\n              requestAnimationFrame(function () {\r\n                if (popover) popover.$applyPlacement();\r\n              });\r\n            }\r\n          }, true);\r\n        }\r\n\r\n        // Visibility binding support\r\n        if (attr.bsShow) {\r\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\r\n            if (!popover || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(popover),?/i);\r\n            if (newValue === true) {\r\n              popover.show();\r\n            } else {\r\n              popover.hide();\r\n            }\r\n          });\r\n        }\r\n\r\n        // Enabled binding support\r\n        if (attr.bsEnabled) {\r\n          scope.$watch(attr.bsEnabled, function (newValue) {\r\n            if (!popover || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(popover),?/i);\r\n            if (newValue === false) {\r\n              popover.setEnabled(false);\r\n            } else {\r\n              popover.setEnabled(true);\r\n            }\r\n          });\r\n        }\r\n\r\n        // Viewport support\r\n        if (attr.viewport) {\r\n          scope.$watch(attr.viewport, function (newValue) {\r\n            if (!popover || !angular.isDefined(newValue)) return;\r\n            popover.setViewport(newValue);\r\n          });\r\n        }\r\n\r\n        // Initialize popover\r\n        popover = $popover(element, options);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (popover) popover.destroy();\r\n          options = null;\r\n          popover = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.navbar', [])\r\n\r\n  .provider('$navbar', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      activeClass: 'active',\r\n      routeAttr: 'data-match-route',\r\n      strict: false\r\n    };\r\n\r\n    this.$get = function () {\r\n      return {defaults: defaults};\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsNavbar', function ($window, $location, $navbar) {\r\n\r\n    var defaults = $navbar.defaults;\r\n\r\n    return {\r\n      restrict: 'A',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        // Directive options\r\n        var options = angular.copy(defaults);\r\n        angular.forEach(Object.keys(defaults), function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // Watch for the $location\r\n        scope.$watch(function () {\r\n\r\n          return $location.path();\r\n\r\n        }, function (newValue, oldValue) {\r\n\r\n          var liElements = element[0].querySelectorAll('li[' + options.routeAttr + ']');\r\n\r\n          angular.forEach(liElements, function (li) {\r\n\r\n            var liElement = angular.element(li);\r\n            var pattern = liElement.attr(options.routeAttr).replace('/', '\\\\/');\r\n            if (options.strict) {\r\n              pattern = '^' + pattern + '$';\r\n            }\r\n            var regexp = new RegExp(pattern, 'i');\r\n\r\n            if (regexp.test(newValue)) {\r\n              liElement.addClass(options.activeClass);\r\n            } else {\r\n              liElement.removeClass(options.activeClass);\r\n            }\r\n\r\n          });\r\n\r\n        });\r\n\r\n      }\r\n\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.modal', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\r\n\r\n  .provider('$modal', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      backdropAnimation: 'am-fade',\r\n      customClass: '',\r\n      prefixClass: 'modal',\r\n      prefixEvent: 'modal',\r\n      placement: 'top',\r\n      templateUrl: 'modal/modal.tpl.html',\r\n      template: '',\r\n      contentTemplate: false,\r\n      container: false,\r\n      element: null,\r\n      backdrop: true,\r\n      keyboard: true,\r\n      html: false,\r\n      show: true,\r\n      size: null,\r\n      zIndex: null,\r\n      containerElement: null\r\n    };\r\n\r\n    this.$get = function ($window, $rootScope, $bsCompiler, $animate, $timeout, $sce, dimensions) {\r\n\r\n      var forEach = angular.forEach;\r\n      var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\r\n      var bodyElement = angular.element($window.document.body);\r\n\r\n      var layoutHideElement = angular.element('#layoutContainer');\r\n\r\n      var backdropCount = 0;\r\n      var dialogBaseZindex = 1050;\r\n      var backdropBaseZindex = 1040;\r\n\r\n      var validSizes = {\r\n        lg: 'modal-lg',\r\n        sm: 'modal-sm'\r\n      };\r\n\r\n      function ModalFactory (config) {\r\n\r\n        var $modal = {};\r\n\r\n        // Common vars\r\n        var options = $modal.$options = angular.extend({}, defaults, config);\r\n\r\n        var promise = $modal.$promise = $bsCompiler.compile(options);\r\n        var scope = $modal.$scope = options.scope && options.scope.$new() || $rootScope.$new();\r\n\r\n        if (options.containerElement) {\r\n          layoutHideElement = angular.element(options.containerElement);\r\n        }\r\n        if (!options.element && !options.container) {\r\n          options.container = 'body';\r\n        }\r\n\r\n        if (options.zIndex) {\r\n          dialogBaseZindex = parseInt(options.zIndex, 10);\r\n          backdropBaseZindex = dialogBaseZindex - 10;\r\n        }\r\n\r\n        // Store $id to identify the triggering element in events\r\n        // give priority to options.id, otherwise, try to use\r\n        // element id if defined\r\n        $modal.$id = options.id || options.element && options.element.attr('id') || '';\r\n\r\n        $modal.returnFocus = function () {\r\n\r\n        };\r\n\r\n        // Support scope as string options\r\n        forEach(['title', 'content'], function (key) {\r\n          if (options[key]) scope[key] = $sce.trustAsHtml(options[key]);\r\n        });\r\n\r\n        // Provide scope helpers\r\n        scope.$hide = function () {\r\n          scope.$$postDigest(function () {\r\n            $modal.hide();\r\n          });\r\n        };\r\n        scope.$show = function () {\r\n          scope.$$postDigest(function () {\r\n            $modal.show();\r\n          });\r\n        };\r\n        scope.$toggle = function () {\r\n          scope.$$postDigest(function () {\r\n            $modal.toggle();\r\n          });\r\n        };\r\n        // Publish isShown as a protected var on scope\r\n        $modal.$isShown = scope.$isShown = false;\r\n\r\n        // Fetch, compile then initialize modal\r\n        var compileData;\r\n        var modalElement;\r\n        var modalScope;\r\n        var backdropElement = angular.element('<div class=\"' + options.prefixClass + '-backdrop\"/>');\r\n        backdropElement.css({\r\n          position: 'fixed',\r\n          top: '0px',\r\n          left: '0px',\r\n          bottom: '0px',\r\n          right: '0px'\r\n        });\r\n        promise.then(function (data) {\r\n          compileData = data;\r\n          $modal.init();\r\n        });\r\n\r\n        $modal.init = function () {\r\n\r\n          // Options: show\r\n          if (options.show) {\r\n            scope.$$postDigest(function () {\r\n              $modal.show();\r\n            });\r\n          }\r\n\r\n        };\r\n\r\n        $modal.destroy = function () {\r\n\r\n          // Remove element\r\n          destroyModalElement();\r\n\r\n          // remove backdrop element\r\n          if (backdropElement) {\r\n            backdropElement.remove();\r\n            backdropElement = null;\r\n          }\r\n\r\n          // Destroy scope\r\n          scope.$destroy();\r\n        };\r\n\r\n        $modal.show = function () {\r\n          if ($modal.$isShown) return;\r\n\r\n          var parent;\r\n          var after;\r\n          if (angular.isElement(options.container)) {\r\n            parent = options.container;\r\n            after = options.container[0].lastChild ? angular.element(options.container[0].lastChild) : null;\r\n          } else {\r\n            if (options.container) {\r\n              parent = findElement(options.container);\r\n              after = parent[0] && parent[0].lastChild ? angular.element(parent[0].lastChild) : null;\r\n            } else {\r\n              parent = null;\r\n              after = options.element;\r\n            }\r\n          }\r\n\r\n          // destroy any existing modal elements\r\n          if (modalElement) destroyModalElement();\r\n\r\n          // create a new scope, so we can destroy it and all child scopes\r\n          // when destroying the modal element\r\n          modalScope = $modal.$scope.$new();\r\n          // Fetch a cloned element linked from template (noop callback is required)\r\n          modalElement = $modal.$element = compileData.link(modalScope, function (clonedElement, scope) {});\r\n\r\n          if (options.backdrop) {\r\n            // set z-index\r\n            modalElement.css({\r\n              'z-index': dialogBaseZindex + (backdropCount * 20)\r\n            });\r\n            backdropElement.css({\r\n              'z-index': backdropBaseZindex + (backdropCount * 20)\r\n            });\r\n\r\n            // increment number of backdrops\r\n            backdropCount++;\r\n          }\r\n\r\n          if (scope.$emit(options.prefixEvent + '.show.before', $modal).defaultPrevented) {\r\n            return;\r\n          }\r\n          if (angular.isDefined(options.onBeforeShow) && angular.isFunction(options.onBeforeShow)) {\r\n            options.onBeforeShow($modal);\r\n          }\r\n\r\n          // Set the initial positioning.\r\n          modalElement.css({\r\n            display: 'block'\r\n          }).addClass(options.placement);\r\n\r\n          // Options: customClass\r\n          if (options.customClass) {\r\n            modalElement.addClass(options.customClass);\r\n          }\r\n\r\n          // Options: size\r\n          if (options.size && validSizes[options.size]) {\r\n            angular.element(findElement('.modal-dialog', modalElement[0])).addClass(validSizes[options.size]);\r\n          }\r\n\r\n          // Options: animation\r\n          if (options.animation) {\r\n            if (options.backdrop) {\r\n              backdropElement.addClass(options.backdropAnimation);\r\n            }\r\n            modalElement.addClass(options.animation);\r\n          }\r\n\r\n          if (options.backdrop) {\r\n            $animate.enter(backdropElement, bodyElement, null);\r\n          }\r\n\r\n          // Support v1.2+ $animate\r\n          // https://github.com/angular/angular.js/issues/11713\r\n          if (angular.version.minor <= 2) {\r\n            $animate.enter(modalElement, parent, after, enterAnimateCallback);\r\n          } else {\r\n            $animate.enter(modalElement, parent, after).then(enterAnimateCallback);\r\n          }\r\n\r\n          $modal.$isShown = scope.$isShown = true;\r\n          safeDigest(scope);\r\n          // Focus once the enter-animation has started\r\n          // Weird PhantomJS bug hack\r\n          var el = modalElement[0];\r\n          requestAnimationFrame(function () {\r\n            el.focus();\r\n          });\r\n\r\n          bodyElement.addClass(options.prefixClass + '-open');\r\n\r\n          layoutHideElement.attr('aria-hidden', 'true');\r\n\r\n          if (options.animation) {\r\n            bodyElement.addClass(options.prefixClass + '-with-' + options.animation);\r\n          }\r\n\r\n          // Bind events\r\n          bindBackdropEvents();\r\n          bindKeyboardEvents();\r\n        };\r\n\r\n        function enterAnimateCallback () {\r\n          scope.$emit(options.prefixEvent + '.show', $modal);\r\n          if (angular.isDefined(options.onShow) && angular.isFunction(options.onShow)) {\r\n            options.onShow($modal);\r\n          }\r\n\r\n          modalElement.attr('aria-hidden', 'false');\r\n\r\n          var focusableElement = angular.element(findElement('.modal'));\r\n\r\n          if (focusableElement.length > 0) {\r\n            focusableElement.attr('tabindex', '0');\r\n            setTimeout(function () {\r\n              focusableElement.focus();\r\n            }, 500);\r\n          }\r\n        }\r\n\r\n        $modal.hide = function () {\r\n          if (!$modal.$isShown) return;\r\n\r\n          if (scope.$emit(options.prefixEvent + '.hide.before', $modal).defaultPrevented) {\r\n            return;\r\n          }\r\n          if (angular.isDefined(options.onBeforeHide) && angular.isFunction(options.onBeforeHide)) {\r\n            options.onBeforeHide($modal);\r\n          }\r\n\r\n          modalElement.attr('aria-hidden', 'true');\r\n\r\n          if ($modal.returnFocus && typeof $modal.returnFocus === 'function') $modal.returnFocus();\r\n\r\n          // Support v1.2+ $animate\r\n          // https://github.com/angular/angular.js/issues/11713\r\n          if (angular.version.minor <= 2) {\r\n            $animate.leave(modalElement, leaveAnimateCallback);\r\n          } else {\r\n            $animate.leave(modalElement).then(leaveAnimateCallback);\r\n          }\r\n\r\n          if (options.backdrop) {\r\n            // decrement number of backdrops\r\n            backdropCount--;\r\n            $animate.leave(backdropElement);\r\n          }\r\n          $modal.$isShown = scope.$isShown = false;\r\n          safeDigest(scope);\r\n\r\n          // Unbind events\r\n          unbindBackdropEvents();\r\n          unbindKeyboardEvents();\r\n        };\r\n\r\n        function leaveAnimateCallback () {\r\n          scope.$emit(options.prefixEvent + '.hide', $modal);\r\n          if (angular.isDefined(options.onHide) && angular.isFunction(options.onHide)) {\r\n            options.onHide($modal);\r\n          }\r\n          if (findElement('.modal').length <= 0) {\r\n            bodyElement.removeClass(options.prefixClass + '-open');\r\n            layoutHideElement.attr('aria-hidden', 'false');\r\n          }\r\n          if (options.animation) {\r\n            bodyElement.removeClass(options.prefixClass + '-with-' + options.animation);\r\n          }\r\n        }\r\n\r\n        function findFocusableElements () {\r\n          // Add all elements we want to include in our selection\r\n          var focusableElements = 'a:not([disabled]), button:not([disabled]), input:not([disabled]), [tabindex]:not([disabled]):not([tabindex=\"-1\"])';\r\n          if (document.activeElement) {\r\n            var focusable = Array.prototype.filter.call(modalElement[0].querySelectorAll(focusableElements),\r\n              function (element) {\r\n                // Check for visibility while always include the current activeElement\r\n                return element.offsetWidth > 0 || element.offsetHeight > 0 || element === document.activeElement;\r\n              });\r\n\r\n            return focusable;\r\n          }\r\n        }\r\n\r\n        function findNextFocusableElement (inReverse) {\r\n          if (document.activeElement) {\r\n            var focusable = findFocusableElements();\r\n            if (focusable === undefined) return;\r\n            if (inReverse) {\r\n              focusable = Array.prototype.reverse.call(focusable);\r\n            }\r\n\r\n            var index = focusable.indexOf(document.activeElement);\r\n            return focusable[index + 1];\r\n          }\r\n        }\r\n\r\n        $modal.toggle = function () {\r\n          if ($modal.$isShown) {\r\n            $modal.hide();\r\n          } else {\r\n            $modal.show();\r\n          }\r\n        };\r\n\r\n        $modal.focus = function () {\r\n          modalElement[0].focus();\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $modal.$onKeyUp = function (evt) {\r\n\r\n          // Escape was pressed on an open modal. Hide it.  Backspace key, nothing happen.\r\n          if ((evt.which === 8||evt.which === 27) && $modal.$isShown) {\r\n            if (evt.which === 27) {\r\n               $modal.hide();\r\n            }\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        $modal.$onKeyDown = function (evt) {\r\n          if (options.keyboard) {\r\n            if (evt.keyCode === 8 && evt.target.tagName!=='TEXTAREA' && evt.target.tagName!=='INPUT') {\r\n                evt.preventDefault();\r\n            }\t\t\t\t\r\n\t\t\t  \r\n            if (evt.keyCode === 9) {\r\n\r\n              var nextFocusable = findNextFocusableElement(evt.shiftKey);\r\n              if (nextFocusable === undefined) {\r\n                if (evt.preventDefault) evt.preventDefault();\r\n                if (evt.stopPropagation) evt.stopPropagation();\r\n\r\n                var focusable = findFocusableElements();\r\n                if (evt.shiftKey) {\r\n                  focusable[focusable.length - 1].focus();\r\n                } else {\r\n                  focusable[0].focus();\r\n                }\r\n              }\r\n            }\r\n          }\r\n        };\r\n\r\n        function bindBackdropEvents () {\r\n          if (options.backdrop) {\r\n            modalElement.on('click', hideOnBackdropClick);\r\n            backdropElement.on('click', hideOnBackdropClick);\r\n            backdropElement.on('wheel', preventEventDefault);\r\n          }\r\n        }\r\n\r\n        function unbindBackdropEvents () {\r\n          if (options.backdrop) {\r\n            modalElement.off('click', hideOnBackdropClick);\r\n            backdropElement.off('click', hideOnBackdropClick);\r\n            backdropElement.off('wheel', preventEventDefault);\r\n          }\r\n        }\r\n\r\n        function bindKeyboardEvents () {\r\n          if (options.keyboard) {\r\n            modalElement.on('keyup', $modal.$onKeyUp);\r\n            modalElement.on('keydown', $modal.$onKeyDown);\r\n          }\r\n        }\r\n\r\n        function unbindKeyboardEvents () {\r\n          if (options.keyboard) {\r\n            modalElement.off('keyup', $modal.$onKeyUp);\r\n            modalElement.off('keydown', $modal.$onKeyDown);\r\n          }\r\n        }\r\n\r\n        // Private helpers\r\n\r\n        function hideOnBackdropClick (evt) {\r\n          if (evt.target !== evt.currentTarget) return;\r\n          if (options.backdrop === 'static') {\r\n            $modal.focus();\r\n          } else {\r\n            $modal.hide();\r\n          }\r\n        }\r\n\r\n        function preventEventDefault (evt) {\r\n          evt.preventDefault();\r\n        }\r\n\r\n        function destroyModalElement () {\r\n          if ($modal.$isShown && modalElement !== null) {\r\n            // un-bind events\r\n            unbindBackdropEvents();\r\n            unbindKeyboardEvents();\r\n          }\r\n\r\n          if (modalScope) {\r\n            modalScope.$destroy();\r\n            modalScope = null;\r\n          }\r\n\r\n          if (modalElement) {\r\n            modalElement.remove();\r\n            modalElement = $modal.$element = null;\r\n          }\r\n        }\r\n\r\n        return $modal;\r\n\r\n      }\r\n\r\n      // Helper functions\r\n\r\n      function safeDigest (scope) {\r\n        /* eslint-disable no-unused-expressions */\r\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\r\n        /* eslint-enable no-unused-expressions */\r\n      }\r\n\r\n      function findElement (query, element) {\r\n        return angular.element((element || document).querySelectorAll(query));\r\n      }\r\n\r\n      return ModalFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsModal', function ($window, $sce, $parse, $modal) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink (scope, element, attr, transclusion) {\r\n\r\n        // Directive options\r\n        var options = {\r\n          scope: scope,\r\n          element: element,\r\n          show: false\r\n        };\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation', 'backdropAnimation', 'id', 'prefixEvent', 'prefixClass', 'customClass', 'modalClass', 'size', 'zIndex'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // Options: alias modalClass to customClass\r\n        if (options.modalClass) {\r\n          options.customClass = options.modalClass;\r\n        }\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['backdrop', 'keyboard', 'html', 'container'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Support scope as data-attrs\r\n        angular.forEach(['title', 'content'], function (key) {\r\n          if (attr[key]) {\r\n            attr.$observe(key, function (newValue, oldValue) {\r\n              scope[key] = $sce.trustAsHtml(newValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Support scope as an object\r\n        if (attr.bsModal) {\r\n          scope.$watch(attr.bsModal, function (newValue, oldValue) {\r\n            if (angular.isObject(newValue)) {\r\n              angular.extend(scope, newValue);\r\n            } else {\r\n              scope.content = newValue;\r\n            }\r\n          }, true);\r\n        }\r\n\r\n        // Initialize modal\r\n        var modal = $modal(options);\r\n\r\n        if (options.keyboard) {\r\n          modal.returnFocus = function () {\r\n            element[0].focus();\r\n          };\r\n        }\r\n\r\n        // Trigger\r\n        element.on(attr.trigger || 'click', modal.toggle);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (modal) modal.destroy();\r\n          options = null;\r\n          modal = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nif (angular.version.minor < 3 && angular.version.dot < 14) {\r\n  angular.module('ng')\r\n\r\n  .factory('$$rAF', function ($window, $timeout) {\r\n\r\n    var requestAnimationFrame = $window.requestAnimationFrame ||\r\n                                $window.webkitRequestAnimationFrame ||\r\n                                $window.mozRequestAnimationFrame;\r\n\r\n    var cancelAnimationFrame = $window.cancelAnimationFrame ||\r\n                               $window.webkitCancelAnimationFrame ||\r\n                               $window.mozCancelAnimationFrame ||\r\n                               $window.webkitCancelRequestAnimationFrame;\r\n\r\n    var rafSupported = !!requestAnimationFrame;\r\n    var raf = rafSupported ?\r\n      function (fn) {\r\n        var id = requestAnimationFrame(fn);\r\n        return function () {\r\n          cancelAnimationFrame(id);\r\n        };\r\n      } :\r\n      function (fn) {\r\n        var timer = $timeout(fn, 16.66, false); // 1000 / 60 = 16.666\r\n        return function () {\r\n          $timeout.cancel(timer);\r\n        };\r\n      };\r\n\r\n    raf.supported = rafSupported;\r\n\r\n    return raf;\r\n\r\n  });\r\n}\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.helpers.parseOptions', [])\r\n\r\n  .provider('$parseOptions', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      regexp: /^\\s*(.*?)(?:\\s+as\\s+(.*?))?(?:\\s+group\\s+by\\s+(.*))?\\s+for\\s+(?:([\\$\\w][\\$\\w]*)|(?:\\(\\s*([\\$\\w][\\$\\w]*)\\s*,\\s*([\\$\\w][\\$\\w]*)\\s*\\)))\\s+in\\s+(.*?)(?:\\s+track\\s+by\\s+(.*?))?$/\r\n    };\r\n\r\n    this.$get = function ($parse, $q) {\r\n\r\n      function ParseOptionsFactory (attr, config) {\r\n\r\n        var $parseOptions = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n        $parseOptions.$values = [];\r\n\r\n        // Private vars\r\n        var match;\r\n        var displayFn;\r\n        var valueName;\r\n        /* eslint-disable no-unused-vars */\r\n        var keyName;\r\n        var groupByFn;\r\n        /* eslint-enable no-unused-vars */\r\n        var valueFn;\r\n        var valuesFn;\r\n\r\n        $parseOptions.init = function () {\r\n          $parseOptions.$match = match = attr.match(options.regexp);\r\n          displayFn = $parse(match[2] || match[1]);\r\n          valueName = match[4] || match[6];\r\n          keyName = match[5];\r\n          groupByFn = $parse(match[3] || '');\r\n          valueFn = $parse(match[2] ? match[1] : valueName);\r\n          valuesFn = $parse(match[7]);\r\n        };\r\n\r\n        $parseOptions.valuesFn = function (scope, controller) {\r\n          return $q.when(valuesFn(scope, controller))\r\n          .then(function (values) {\r\n            if (!angular.isArray(values)) {\r\n              values = [];\r\n            }\r\n            $parseOptions.$values = values.length ? parseValues(values, scope) : [];\r\n            return $parseOptions.$values;\r\n          });\r\n        };\r\n\r\n        $parseOptions.displayValue = function (modelValue) {\r\n          var scope = {};\r\n          scope[valueName] = modelValue;\r\n          return displayFn(scope);\r\n        };\r\n\r\n        // Private functions\r\n\r\n        function parseValues (values, scope) {\r\n          return values.map(function (match, index) {\r\n            var locals = {};\r\n            var label;\r\n            var value;\r\n            locals[valueName] = match;\r\n            label = displayFn(scope, locals);\r\n            value = valueFn(scope, locals);\r\n            return {label: label, value: value, index: index};\r\n          });\r\n        }\r\n\r\n        $parseOptions.init();\r\n        return $parseOptions;\r\n\r\n      }\r\n\r\n      return ParseOptionsFactory;\r\n\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.helpers.ngFocusOut', [])\r\n  .directive('ngFocusOut', ['$parse', '$rootScope', function ($parse, $rootScope) {\r\n    return {\r\n      restrict: 'A',\r\n      compile: function ($element, attr) {\r\n        // NOTE:\r\n        // We expose the powerful `$event` object on the scope that provides access to the Window,\r\n        // etc. This is OK, because expressions are not sandboxed any more (and the expression\r\n        // sandbox was never meant to be a security feature anyway).\r\n        var fn = $parse(attr.ngFocusOut);\r\n\r\n        return function link (scope, element) {\r\n          function ngEventHandler (event) {\r\n            var callback = function () {\r\n              fn(scope, {\r\n                $event: event\r\n              });\r\n            };\r\n            if ($rootScope.$$phase) {\r\n              scope.$evalAsync(callback);\r\n            } else {\r\n              scope.$apply(callback);\r\n            }\r\n          }\r\n\r\n          // setup the handler\r\n          element.on('focusout', ngEventHandler);\r\n\r\n          scope.$on('$destroy', function () {\r\n            // tear down the handler\r\n            element.off('focusout', ngEventHandler);\r\n          });\r\n        };\r\n      }\r\n    };\r\n  }]);\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.helpers.focusElement', [])\r\n  .directive('focusElement', ['$timeout', '$parse', function ($timeout, $parse) {\r\n    return {\r\n      link: function (scope, element, attrs) {\r\n        scope.$watch(attrs.focusElement, function (value) {\r\n          if (value === true) {\r\n            $timeout(function () {\r\n              element[0].focus();\r\n            });\r\n          }\r\n        });\r\n      }\r\n    };\r\n  }]);\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.helpers.dimensions', [])\r\n\r\n  .factory('dimensions', function () {\r\n\r\n    var fn = {};\r\n\r\n    /**\r\n     * Test the element nodeName\r\n     * @param element\r\n     * @param name\r\n     */\r\n    var nodeName = fn.nodeName = function (element, name) {\r\n      return element.nodeName && element.nodeName.toLowerCase() === name.toLowerCase();\r\n    };\r\n\r\n    /**\r\n     * Returns the element computed style\r\n     * @param element\r\n     * @param prop\r\n     * @param extra\r\n     */\r\n    fn.css = function (element, prop, extra) {\r\n      var value;\r\n      if (element.currentStyle) { // IE\r\n        value = element.currentStyle[prop];\r\n      } else if (window.getComputedStyle) {\r\n        value = window.getComputedStyle(element)[prop];\r\n      } else {\r\n        value = element.style[prop];\r\n      }\r\n      return extra === true ? parseFloat(value) || 0 : value;\r\n    };\r\n\r\n    /**\r\n     * Provides read-only equivalent of jQuery's offset function:\r\n     * @required-by bootstrap-tooltip, bootstrap-affix\r\n     * @url http://api.jquery.com/offset/\r\n     * @param element\r\n     */\r\n    fn.offset = function (element) {\r\n      var boxRect = element.getBoundingClientRect();\r\n      var docElement = element.ownerDocument;\r\n      return {\r\n        width: boxRect.width || element.offsetWidth,\r\n        height: boxRect.height || element.offsetHeight,\r\n        top: boxRect.top + (window.pageYOffset || docElement.documentElement.scrollTop) - (docElement.documentElement.clientTop || 0),\r\n        left: boxRect.left + (window.pageXOffset || docElement.documentElement.scrollLeft) - (docElement.documentElement.clientLeft || 0)\r\n      };\r\n    };\r\n\r\n    /**\r\n     * Provides set equivalent of jQuery's offset function:\r\n     * @required-by bootstrap-tooltip\r\n     * @url http://api.jquery.com/offset/\r\n     * @param element\r\n     * @param options\r\n     * @param i\r\n     */\r\n    fn.setOffset = function (element, options, i) {\r\n      var curPosition;\r\n      var curLeft;\r\n      var curCSSTop;\r\n      var curTop;\r\n      var curOffset;\r\n      var curCSSLeft;\r\n      var calculatePosition;\r\n      var position = fn.css(element, 'position');\r\n      var curElem = angular.element(element);\r\n      var props = {};\r\n\r\n      // Set position first, in-case top/left are set even on static elem\r\n      if (position === 'static') {\r\n        element.style.position = 'relative';\r\n      }\r\n\r\n      curOffset = fn.offset(element);\r\n      curCSSTop = fn.css(element, 'top');\r\n      curCSSLeft = fn.css(element, 'left');\r\n      calculatePosition = (position === 'absolute' || position === 'fixed') &&\r\n                          (curCSSTop + curCSSLeft).indexOf('auto') > -1;\r\n\r\n      // Need to be able to calculate position if either\r\n      // top or left is auto and position is either absolute or fixed\r\n      if (calculatePosition) {\r\n        curPosition = fn.position(element);\r\n        curTop = curPosition.top;\r\n        curLeft = curPosition.left;\r\n      } else {\r\n        curTop = parseFloat(curCSSTop) || 0;\r\n        curLeft = parseFloat(curCSSLeft) || 0;\r\n      }\r\n\r\n      if (angular.isFunction(options)) {\r\n        options = options.call(element, i, curOffset);\r\n      }\r\n\r\n      if (options.top !== null) {\r\n        props.top = (options.top - curOffset.top) + curTop;\r\n      }\r\n      if (options.left !== null) {\r\n        props.left = (options.left - curOffset.left) + curLeft;\r\n      }\r\n\r\n      if ('using' in options) {\r\n        options.using.call(curElem, props);\r\n      } else {\r\n        curElem.css({\r\n          top: props.top + 'px',\r\n          left: props.left + 'px'\r\n        });\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Provides read-only equivalent of jQuery's position function\r\n     * @required-by bootstrap-tooltip, bootstrap-affix\r\n     * @url http://api.jquery.com/offset/\r\n     * @param element\r\n     */\r\n    fn.position = function (element) {\r\n\r\n      var offsetParentRect = {top: 0, left: 0};\r\n      var offsetParentEl;\r\n      var offset;\r\n\r\n      // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\r\n      if (fn.css(element, 'position') === 'fixed') {\r\n\r\n        // We assume that getBoundingClientRect is available when computed position is fixed\r\n        offset = element.getBoundingClientRect();\r\n\r\n      } else {\r\n\r\n        // Get *real* offsetParentEl\r\n        offsetParentEl = offsetParentElement(element);\r\n\r\n        // Get correct offsets\r\n        offset = fn.offset(element);\r\n        if (!nodeName(offsetParentEl, 'html')) {\r\n          offsetParentRect = fn.offset(offsetParentEl);\r\n        }\r\n\r\n        // Add offsetParent borders\r\n        offsetParentRect.top += fn.css(offsetParentEl, 'borderTopWidth', true);\r\n        offsetParentRect.left += fn.css(offsetParentEl, 'borderLeftWidth', true);\r\n      }\r\n\r\n      // Subtract parent offsets and element margins\r\n      return {\r\n        width: element.offsetWidth,\r\n        height: element.offsetHeight,\r\n        top: offset.top - offsetParentRect.top - fn.css(element, 'marginTop', true),\r\n        left: offset.left - offsetParentRect.left - fn.css(element, 'marginLeft', true)\r\n      };\r\n\r\n    };\r\n\r\n    /**\r\n     * Returns the closest, non-statically positioned offsetParent of a given element\r\n     * @required-by fn.position\r\n     * @param element\r\n     */\r\n    function offsetParentElement (element) {\r\n      var docElement = element.ownerDocument;\r\n      var offsetParent = element.offsetParent || docElement;\r\n      if (nodeName(offsetParent, '#document')) return docElement.documentElement;\r\n      while (offsetParent && !nodeName(offsetParent, 'html') && fn.css(offsetParent, 'position') === 'static') {\r\n        offsetParent = offsetParent.offsetParent;\r\n      }\r\n      return offsetParent || docElement.documentElement;\r\n    }\r\n\r\n    /**\r\n     * Provides equivalent of jQuery's height function\r\n     * @required-by bootstrap-affix\r\n     * @url http://api.jquery.com/height/\r\n     * @param element\r\n     * @param outer\r\n     */\r\n    fn.height = function (element, outer) {\r\n      var value = element.offsetHeight;\r\n      if (outer) {\r\n        value += fn.css(element, 'marginTop', true) + fn.css(element, 'marginBottom', true);\r\n      } else {\r\n        value -= fn.css(element, 'paddingTop', true) + fn.css(element, 'paddingBottom', true) + fn.css(element, 'borderTopWidth', true) + fn.css(element, 'borderBottomWidth', true);\r\n      }\r\n      return value;\r\n    };\r\n\r\n    /**\r\n     * Provides equivalent of jQuery's width function\r\n     * @required-by bootstrap-affix\r\n     * @url http://api.jquery.com/width/\r\n     * @param element\r\n     * @param outer\r\n     */\r\n    fn.width = function (element, outer) {\r\n      var value = element.offsetWidth;\r\n      if (outer) {\r\n        value += fn.css(element, 'marginLeft', true) + fn.css(element, 'marginRight', true);\r\n      } else {\r\n        value -= fn.css(element, 'paddingLeft', true) + fn.css(element, 'paddingRight', true) + fn.css(element, 'borderLeftWidth', true) + fn.css(element, 'borderRightWidth', true);\r\n      }\r\n      return value;\r\n    };\r\n\r\n    return fn;\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.helpers.debounce', [])\r\n\r\n// @source jashkenas/underscore\r\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L693\r\n.factory('debounce', function ($timeout) {\r\n  return function (func, wait, immediate) {\r\n    var timeout = null;\r\n    return function () {\r\n      var context = this;\r\n      var args = arguments;\r\n      var callNow = immediate && !timeout;\r\n      if (timeout) {\r\n        $timeout.cancel(timeout);\r\n      }\r\n      timeout = $timeout(function later () {\r\n        timeout = null;\r\n        if (!immediate) {\r\n          func.apply(context, args);\r\n        }\r\n      }, wait, false);\r\n      if (callNow) {\r\n        func.apply(context, args);\r\n      }\r\n      return timeout;\r\n    };\r\n  };\r\n})\r\n\r\n\r\n// @source jashkenas/underscore\r\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L661\r\n.factory('throttle', function ($timeout) {\r\n  return function (func, wait, options) {\r\n    var timeout = null;\r\n    if (!options) options = {};\r\n    return function () {\r\n      var context = this;\r\n      var args = arguments;\r\n      if (!timeout) {\r\n        if (options.leading !== false) {\r\n          func.apply(context, args);\r\n        }\r\n        timeout = $timeout(function later () {\r\n          timeout = null;\r\n          if (options.trailing !== false) {\r\n            func.apply(context, args);\r\n          }\r\n        }, wait, false);\r\n      }\r\n    };\r\n  };\r\n});\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.helpers.dateParser', [])\r\n\r\n.provider('$dateParser', function ($localeProvider) {\r\n\r\n  // define a custom ParseDate object to use instead of native Date\r\n  // to avoid date values wrapping when setting date component values\r\n  function ParseDate () {\r\n    this.year = 1970;\r\n    this.month = 0;\r\n    this.day = 1;\r\n    this.hours = 0;\r\n    this.minutes = 0;\r\n    this.seconds = 0;\r\n    this.milliseconds = 0;\r\n  }\r\n\r\n  ParseDate.prototype.setMilliseconds = function (value) { this.milliseconds = value; };\r\n  ParseDate.prototype.setSeconds = function (value) { this.seconds = value; };\r\n  ParseDate.prototype.setMinutes = function (value) { this.minutes = value; };\r\n  ParseDate.prototype.setHours = function (value) { this.hours = value; };\r\n  ParseDate.prototype.getHours = function () { return this.hours; };\r\n  ParseDate.prototype.setDate = function (value) { this.day = value; };\r\n  ParseDate.prototype.setMonth = function (value) { this.month = value; };\r\n  ParseDate.prototype.setFullYear = function (value) { this.year = value; };\r\n  ParseDate.prototype.fromDate = function (value) {\r\n    this.year = value.getFullYear();\r\n    this.month = value.getMonth();\r\n    this.day = value.getDate();\r\n    this.hours = value.getHours();\r\n    this.minutes = value.getMinutes();\r\n    this.seconds = value.getSeconds();\r\n    this.milliseconds = value.getMilliseconds();\r\n    return this;\r\n  };\r\n\r\n  ParseDate.prototype.toDate = function () {\r\n    return new Date(this.year, this.month, this.day, this.hours, this.minutes, this.seconds, this.milliseconds);\r\n  };\r\n\r\n  var proto = ParseDate.prototype;\r\n\r\n  function noop () {\r\n  }\r\n\r\n  function isNumeric (n) {\r\n    return !isNaN(parseFloat(n)) && isFinite(n);\r\n  }\r\n\r\n  function indexOfCaseInsensitive (array, value) {\r\n    var len = array.length;\r\n    var str = value.toString().toLowerCase();\r\n    for (var i = 0; i < len; i++) {\r\n      if (array[i].toLowerCase() === str) { return i; }\r\n    }\r\n    return -1; // Return -1 per the \"Array.indexOf()\" method.\r\n  }\r\n\r\n  var defaults = this.defaults = {\r\n    format: 'shortDate',\r\n    strict: false\r\n  };\r\n\r\n  this.$get = function ($locale, dateFilter) {\r\n\r\n    var DateParserFactory = function (config) {\r\n\r\n      var options = angular.extend({}, defaults, config);\r\n\r\n      var $dateParser = {};\r\n\r\n      /* eslint-disable key-spacing, quote-props */\r\n      var regExpMap = {\r\n        'sss'   : '[0-9]{3}',\r\n        'ss'    : '[0-5][0-9]',\r\n        's'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\r\n        'mm'    : '[0-5][0-9]',\r\n        'm'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\r\n        'HH'    : '[01][0-9]|2[0-3]',\r\n        'H'     : options.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',\r\n        'hh'    : '[0][1-9]|[1][012]',\r\n        'h'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\r\n        'a'     : 'AM|PM',\r\n        'EEEE'  : $locale.DATETIME_FORMATS.DAY.join('|'),\r\n        'EEE'   : $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\r\n        'dd'    : '0[1-9]|[12][0-9]|3[01]',\r\n        'd'     : options.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',\r\n        'MMMM'  : $locale.DATETIME_FORMATS.MONTH.join('|'),\r\n        'MMM'   : $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\r\n        'MM'    : '0[1-9]|1[012]',\r\n        'M'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\r\n        'yyyy'  : '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',\r\n        'yy'    : '[0-9]{2}',\r\n        'y'     : options.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}'\r\n      };\r\n\r\n      var setFnMap = {\r\n        'sss'   : proto.setMilliseconds,\r\n        'ss'    : proto.setSeconds,\r\n        's'     : proto.setSeconds,\r\n        'mm'    : proto.setMinutes,\r\n        'm'     : proto.setMinutes,\r\n        'HH'    : proto.setHours,\r\n        'H'     : proto.setHours,\r\n        'hh'    : proto.setHours,\r\n        'h'     : proto.setHours,\r\n        'EEEE'  : noop,\r\n        'EEE'   : noop,\r\n        'dd'    : proto.setDate,\r\n        'd'     : proto.setDate,\r\n        'a'     : function (value) { var hours = this.getHours() % 12; return this.setHours(value.match(/pm/i) ? hours + 12 : hours); },\r\n        'MMMM'  : function (value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.MONTH, value)); },\r\n        'MMM'   : function (value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.SHORTMONTH, value)); },\r\n        'MM'    : function (value) { return this.setMonth(1 * value - 1); },\r\n        'M'     : function (value) { return this.setMonth(1 * value - 1); },\r\n        'yyyy'  : proto.setFullYear,\r\n        'yy'    : function (value) { return this.setFullYear(2000 + 1 * value); },\r\n        'y'     : function (value) { return (1 * value <= 50 && value.length === 2) ? this.setFullYear(2000 + 1 * value) : this.setFullYear(1 * value); }\r\n      };\r\n      /* eslint-enable key-spacing, quote-props */\r\n\r\n      var regex;\r\n      var setMap;\r\n\r\n      $dateParser.init = function () {\r\n        $dateParser.$format = $locale.DATETIME_FORMATS[options.format] || options.format;\r\n        regex = regExpForFormat($dateParser.$format);\r\n        setMap = setMapForFormat($dateParser.$format);\r\n      };\r\n\r\n      $dateParser.isValid = function (date) {\r\n        if (angular.isDate(date)) return !isNaN(date.getTime());\r\n        return regex.test(date);\r\n      };\r\n\r\n      $dateParser.parse = function (value, baseDate, format, timezone) {\r\n        // check for date format special names\r\n        if (format) format = $locale.DATETIME_FORMATS[format] || format;\r\n        if (angular.isDate(value)) value = dateFilter(value, format || $dateParser.$format, timezone);\r\n        var formatRegex = format ? regExpForFormat(format) : regex;\r\n        var formatSetMap = format ? setMapForFormat(format) : setMap;\r\n        var matches = formatRegex.exec(value);\r\n        if (!matches) return false;\r\n        // use custom ParseDate object to set parsed values\r\n        var date = baseDate && !isNaN(baseDate.getTime()) ? new ParseDate().fromDate(baseDate) : new ParseDate().fromDate(new Date(1970, 0, 1, 0));\r\n        for (var i = 0; i < matches.length - 1; i++) {\r\n          if (formatSetMap[i]) formatSetMap[i].call(date, matches[i + 1]);\r\n        }\r\n        // convert back to native Date object\r\n        var newDate = date.toDate();\r\n\r\n        // check new native Date object for day values overflow\r\n        if (parseInt(date.day, 10) !== newDate.getDate()) {\r\n          return false;\r\n        }\r\n\r\n        return newDate;\r\n      };\r\n\r\n      $dateParser.getDateForAttribute = function (key, value) {\r\n        var date;\r\n\r\n        if (value === 'today') {\r\n          var today = new Date();\r\n          date = new Date(today.getFullYear(), today.getMonth(), today.getDate() + (key === 'maxDate' ? 1 : 0), 0, 0, 0, (key === 'minDate' ? 0 : -1));\r\n        } else if (angular.isString(value) && value.match(/^\".+\"$/)) { // Support {{ dateObj }}\r\n          if (value.match(/Z/)) {\r\n            date = new Date(value.substr(1, value.length - 3));\r\n          } else {\r\n            date = new Date(value.substr(1, value.length - 2));\r\n          }\r\n        } else if (isNumeric(value)) {\r\n          date = new Date(parseInt(value, 10));\r\n        } else if (angular.isString(value) && value.length === 0) { // Reset date\r\n          date = key === 'minDate' ? -Infinity : +Infinity;\r\n        } else {\r\n          date = new Date(value);\r\n        }\r\n\r\n        return date;\r\n      };\r\n\r\n      $dateParser.getTimeForAttribute = function (key, value) {\r\n        var time;\r\n\r\n        if (value === 'now') {\r\n          time = new Date().setFullYear(1970, 0, 1);\r\n        } else if (angular.isString(value) && value.match(/^\".+\"$/)) {\r\n          time = new Date(value.substr(1, value.length - 2)).setFullYear(1970, 0, 1);\r\n        } else if (isNumeric(value)) {\r\n          time = new Date(parseInt(value, 10)).setFullYear(1970, 0, 1);\r\n        } else if (angular.isString(value) && value.length === 0) { // Reset time\r\n          time = key === 'minTime' ? -Infinity : +Infinity;\r\n        } else {\r\n          time = $dateParser.parse(value, new Date(1970, 0, 1, 0));\r\n        }\r\n\r\n        return time;\r\n      };\r\n\r\n      /* Handle switch to/from daylight saving.\r\n      * Hours may be non-zero on daylight saving cut-over:\r\n      * > 12 when midnight changeover, but then cannot generate\r\n      * midnight datetime, so jump to 1AM, otherwise reset.\r\n      * @param  date  (Date) the date to check\r\n      * @return  (Date) the corrected date\r\n      *\r\n      * __ copied from jquery ui datepicker __\r\n      */\r\n      $dateParser.daylightSavingAdjust = function (date) {\r\n        if (!date) {\r\n          return null;\r\n        }\r\n        date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);\r\n        return date;\r\n      };\r\n\r\n      /* Correct the date for timezone offset.\r\n      * @param  date  (Date) the date to adjust\r\n      * @param  timezone  (string) the timezone to adjust for\r\n      * @param  undo  (boolean) to add or subtract timezone offset\r\n      * @return  (Date) the corrected date\r\n      */\r\n      $dateParser.timezoneOffsetAdjust = function (date, timezone, undo) {\r\n        if (!date) {\r\n          return null;\r\n        }\r\n        // Right now, only 'UTC' is supported.\r\n        if (timezone && timezone === 'UTC') {\r\n          date = new Date(date.getTime());\r\n          date.setMinutes(date.getMinutes() + (undo ? -1 : 1) * date.getTimezoneOffset());\r\n        }\r\n        return date;\r\n      };\r\n\r\n      // Private functions\r\n\r\n      function regExpForFormat (format) {\r\n        // `format` string can contain literal values.\r\n        // These need to be escaped by surrounding with\r\n        // single quotes (e.g. `\"h 'in the morning'\"`).\r\n        // In order to output a single quote, escape it - i.e.,\r\n        // two single quotes in a sequence (e.g. `\"h 'o''clock'\"`).\r\n\r\n        var re = buildDateAbstractRegex(format);\r\n        return buildDateParseRegex(re);\r\n      }\r\n\r\n      function buildDateAbstractRegex (format) {\r\n        var escapedFormat = escapeReservedSymbols(format);\r\n        var escapedLiteralFormat = escapedFormat.replace(/''/g, '\\\\\\'');\r\n        var literalRegex = /('(?:\\\\'|.)*?')/;\r\n        var formatParts = escapedLiteralFormat.split(literalRegex);\r\n        var dateElements = Object.keys(regExpMap);\r\n        var dateRegexParts = [];\r\n\r\n        angular.forEach(formatParts, function (part) {\r\n          if (isFormatStringLiteral(part)) {\r\n            part = trimLiteralEscapeChars(part);\r\n          } else {\r\n            // Abstract replaces to avoid collisions\r\n            for (var i = 0; i < dateElements.length; i++) {\r\n              part = part.split(dateElements[i]).join('${' + i + '}');\r\n            }\r\n          }\r\n          dateRegexParts.push(part);\r\n        });\r\n\r\n        return dateRegexParts.join('');\r\n      }\r\n\r\n      function escapeReservedSymbols (text) {\r\n        return text.replace(/\\\\/g, '[\\\\\\\\]')\r\n                   .replace(/-/g, '[-]')\r\n                   .replace(/\\./g, '[.]')\r\n                   .replace(/\\*/g, '[*]')\r\n                   .replace(/\\+/g, '[+]')\r\n                   .replace(/\\?/g, '[?]')\r\n                   .replace(/\\$/g, '[$]')\r\n                   .replace(/\\^/g, '[^]')\r\n                   .replace(/\\//g, '[/]')\r\n                   .replace(/\\\\s/g, '[\\\\s]');\r\n      }\r\n\r\n      function isFormatStringLiteral (text) {\r\n        return /^'.*'$/.test(text);\r\n      }\r\n\r\n      function trimLiteralEscapeChars (text) {\r\n        return text.replace(/^'(.*)'$/, '$1');\r\n      }\r\n\r\n      function buildDateParseRegex (abstractRegex) {\r\n        var dateElements = Object.keys(regExpMap);\r\n        var re = abstractRegex;\r\n\r\n        // Replace abstracted values\r\n        for (var i = 0; i < dateElements.length; i++) {\r\n          re = re.split('${' + i + '}').join('(' + regExpMap[dateElements[i]] + ')');\r\n        }\r\n\r\n        return new RegExp('^' + re + '$', ['i']);\r\n      }\r\n\r\n      function setMapForFormat (format) {\r\n        var re = buildDateAbstractRegex(format);\r\n        return buildDateParseValuesMap(re);\r\n      }\r\n\r\n      function buildDateParseValuesMap (abstractRegex) {\r\n        var dateElements = Object.keys(regExpMap);\r\n        var valuesRegex = new RegExp('\\\\${(\\\\d+)}', 'g');\r\n        var valuesMatch;\r\n        var keyIndex;\r\n        var valueKey;\r\n        var valueFunction;\r\n        var valuesFunctionMap = [];\r\n\r\n        /* eslint-disable no-cond-assign */\r\n        while ((valuesMatch = valuesRegex.exec(abstractRegex)) !== null) {\r\n          keyIndex = valuesMatch[1];\r\n          valueKey = dateElements[keyIndex];\r\n          valueFunction = setFnMap[valueKey];\r\n\r\n          valuesFunctionMap.push(valueFunction);\r\n        }\r\n\r\n        return valuesFunctionMap;\r\n      }\r\n\r\n      $dateParser.init();\r\n      return $dateParser;\r\n\r\n    };\r\n\r\n    return DateParserFactory;\r\n\r\n  };\r\n\r\n});\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.helpers.dateFormatter', [])\r\n\r\n  .service('$dateFormatter', function ($locale, dateFilter) {\r\n\r\n    // The unused `lang` arguments are on purpose. The default implementation does not\r\n    // use them and it always uses the locale loaded into the `$locale` service.\r\n    // Custom implementations might use it, thus allowing different directives to\r\n    // have different languages.\r\n\r\n    this.getDefaultLocale = function () {\r\n      return $locale.id;\r\n    };\r\n\r\n    // Format is either a data format name, e.g. \"shortTime\" or \"fullDate\", or a date format\r\n    // Return either the corresponding date format or the given date format.\r\n    this.getDatetimeFormat = function (format, lang) {\r\n      return $locale.DATETIME_FORMATS[format] || format;\r\n    };\r\n\r\n    this.weekdaysShort = function (lang) {\r\n      return $locale.DATETIME_FORMATS.SHORTDAY;\r\n    };\r\n\r\n    this.weekdays = function (lang) {\r\n      return $locale.DATETIME_FORMATS.DAY;\r\n    };\r\n\r\n    function splitTimeFormat (format) {\r\n      return /(h+)([:\\.])?(m+)([:\\.])?(s*)[ ]?(a?)/i.exec(format).slice(1);\r\n    }\r\n\r\n    // h:mm a => h\r\n    this.hoursFormat = function (timeFormat) {\r\n      return splitTimeFormat(timeFormat)[0];\r\n    };\r\n\r\n    // h:mm a => mm\r\n    this.minutesFormat = function (timeFormat) {\r\n      return splitTimeFormat(timeFormat)[2];\r\n    };\r\n\r\n    // h:mm:ss a => ss\r\n    this.secondsFormat = function (timeFormat) {\r\n      return splitTimeFormat(timeFormat)[4];\r\n    };\r\n\r\n    // h:mm a => :\r\n    this.timeSeparator = function (timeFormat) {\r\n      return splitTimeFormat(timeFormat)[1];\r\n    };\r\n\r\n    // h:mm:ss a => true, h:mm a => false\r\n    this.showSeconds = function (timeFormat) {\r\n      return !!splitTimeFormat(timeFormat)[4];\r\n    };\r\n\r\n    // h:mm a => true, H.mm => false\r\n    this.showAM = function (timeFormat) {\r\n      return !!splitTimeFormat(timeFormat)[5];\r\n    };\r\n\r\n    this.formatDate = function (date, format, lang, timezone) {\r\n      return dateFilter(date, format, timezone);\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.datepicker', ['mgcrea.ngStrap.helpers.dateParser', 'mgcrea.ngStrap.helpers.dateFormatter', 'mgcrea.ngStrap.helpers.focusElement', 'mgcrea.ngStrap.helpers.ngFocusOut', 'mgcrea.ngStrap.tooltip'])\r\n  .provider('$datepicker', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      // Uncommenting the following line will break backwards compatability\r\n      // prefixEvent: 'datepicker',\r\n      prefixClass: 'datepicker',\r\n      placement: 'bottom-left',\r\n      templateUrl: 'datepicker/datepicker.tpl.html',\r\n      trigger: 'focus',\r\n      container: false,\r\n      keyboard: true,\r\n      html: false,\r\n      delay: 0,\r\n      // lang: $locale.id,\r\n      useNative: false,\r\n      dateType: 'date',\r\n      dateFormat: 'shortDate',\r\n      timezone: null,\r\n      modelDateFormat: null,\r\n      dayFormat: 'dd',\r\n      monthFormat: 'MMM',\r\n      yearFormat: 'yyyy',\r\n      monthTitleFormat: 'MMMM yyyy',\r\n      yearTitleFormat: 'yyyy',\r\n      strictFormat: false,\r\n      autoclose: false,\r\n      minDate: -Infinity,\r\n      maxDate: +Infinity,\r\n      startView: 0,\r\n      minView: 0,\r\n      startWeek: 0,\r\n      daysOfWeekDisabled: '',\r\n      hasToday: false,\r\n      hasClear: false,\r\n      iconLeft: 'glyphicon glyphicon-chevron-left',\r\n      iconRight: 'glyphicon glyphicon-chevron-right',\r\n      // The format that will be given to the screen reader values placed in the DOM.\r\n      screenReaderDateFormat: 'fullDate',\r\n      // Focuses the table element in the dropdown upon display of the picker.\r\n      // Used mainly in 508 situations when a button is pressed via a keyboard to show the calendar.\r\n      focusOnOpen: false\r\n    };\r\n\r\n    this.$get = function ($window, $document, $rootScope, $sce, $dateFormatter, datepickerViews, $tooltip, $timeout) {\r\n\r\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n      var isTouch = ('createTouch' in $window.document) && isNative;\r\n      if (!defaults.lang) defaults.lang = $dateFormatter.getDefaultLocale();\r\n\r\n      function DatepickerFactory (element, controller, config) {\r\n\r\n        // The datepicker is based on the tooltip control. Build a basic tooltip from the\r\n        // defaults and the configuration passed.\r\n        var $datepicker = $tooltip(element, angular.extend({}, defaults, config));\r\n        var parentScope = config.scope;\r\n        var options = $datepicker.$options;\r\n        var scope = $datepicker.$scope;\r\n        if (options.startView) options.startView -= options.minView;\r\n\r\n        // Add assistive technology helper attributes.\r\n        element.attr('aria-expanded', 'false').attr('aria-haspopup', 'true');\r\n\r\n        // View vars\r\n\r\n        // Initialize the datepicker view collection by passing a reference to the base object.\r\n        var pickerViews = datepickerViews($datepicker);\r\n        $datepicker.$views = pickerViews.views;\r\n        var viewDate = pickerViews.viewDate;\r\n        /*\r\n         * View mode for the date picker.\r\n         * 0: days\r\n         * 1: months\r\n         * 2: years\r\n         */\r\n        scope.$mode = options.startView;\r\n        // icon class override\r\n        scope.$iconLeft = options.iconLeft;\r\n        scope.$iconRight = options.iconRight;\r\n        // Show buttons at the bottom of the picker.\r\n        scope.$hasToday = options.hasToday;\r\n        scope.$hasClear = options.hasClear;\r\n        /*\r\n         * An id on the element is necessary when working with assistive technologies. The view will use the id to build out the\r\n         * aria attributes which are linked via ids.\r\n         */\r\n        scope.id = options.id !== null && options.id !== undefined ? options.id : undefined;\r\n        scope.dropdownId = options.id !== null && options.id !== undefined ? (options.id + '_dropdown') : undefined;\r\n        scope.keyboard = options.keyboard;\r\n        scope.focusOnOpen = options.focusOnOpen;\r\n\r\n        // labels\r\n        scope.$nextLabel = options.labelNext;\r\n        scope.$previousLabel = options.labelPrevious;\r\n\r\n        // This is the actual current picker view.\r\n        var $picker = $datepicker.$views[scope.$mode];\r\n\r\n        // Internal handlers\r\n\r\n        function handleOnKeyDown (evt, apply) {\r\n          if (!/(33|34|38|37|39|40|13)/.test(evt.keyCode) &&\r\n            !(/(33|34|38|37|39|40|13)/.test(evt.keyCode) && evt.shiftKey) &&\r\n            !(/(33|34|38|37|39|40|13)/.test(evt.keyCode) && evt.altKey)) {\r\n            return false;\r\n          }\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n\r\n          if (evt.keyCode === 13) {\r\n            if (!scope.$mode) {\r\n              $datepicker.hide(true);\r\n              if (options.focusOnOpen) return true;\r\n            } else {\r\n              if (apply === undefined || apply) {\r\n                scope.$apply(function () {\r\n                  $datepicker.setMode(scope.$mode - 1);\r\n                });\r\n              } else {\r\n                $datepicker.setMode(scope.$mode - 1);\r\n              }\r\n            }\r\n            return false;\r\n          }\r\n\r\n          return true;\r\n        }\r\n\r\n        // Scope methods\r\n\r\n        /**\r\n         * Pass through from the scope to the provider for the selection of a date.\r\n         */\r\n        scope.$select = function (date, disabled) {\r\n          if (disabled) return;\r\n          $datepicker.select(date);\r\n        };\r\n        scope.$selectPane = function (value) {\r\n          $datepicker.$selectPane(value);\r\n        };\r\n        scope.$toggleMode = function () {\r\n          $datepicker.setMode((scope.$mode + 1) % $datepicker.$views.length);\r\n        };\r\n        scope.$setToday = function () {\r\n          if (options.autoclose) {\r\n            $datepicker.setMode(0);\r\n            $datepicker.select(new Date());\r\n          } else {\r\n            $datepicker.select(new Date(), true);\r\n          }\r\n        };\r\n        scope.$clear = function () {\r\n          if (options.autoclose) {\r\n            $datepicker.setMode(0);\r\n            $datepicker.select(null);\r\n          } else {\r\n            $datepicker.select(null, true);\r\n          }\r\n        };\r\n        scope.$focused = function (dayInfo) {\r\n          scope.selectedDayId = dayInfo.id;\r\n          if (dayInfo.isNext && !scope.selected) {\r\n            if (scope.$mode) {\r\n              $datepicker.update(dayInfo.date);\r\n            } else {\r\n              scope.$select(dayInfo.date);\r\n            }\r\n          }\r\n        };\r\n        scope.$onKeyDown = function (evt, day) {\r\n          var continueHandling = handleOnKeyDown(evt, false);\r\n\r\n          if (continueHandling) {\r\n            // Navigate with keyboard\r\n            $picker.onKeyDown(evt);\r\n          }\r\n        };\r\n        scope.$onFocusOut = function (evt) {\r\n          // find out if the related target's parents contain the datepicker's $element\r\n          var inTable = false;\r\n          var parent = angular.element(evt.relatedTarget);\r\n          while (parent !== undefined && parent.length && parent[0] !== $window.document.body) {\r\n            parent = parent.parent();\r\n            if (parent !== undefined && parent[0] === $datepicker.$element[0]) {\r\n              inTable = true;\r\n              break;\r\n            } else {\r\n              inTable = false;\r\n            }\r\n          }\r\n\r\n          // In Chrome there is an issue when moving from month to month, year to year, etc.\r\n          //\r\n\r\n          if (!inTable && !evt.relatedTarget) {\r\n            // hmm\r\n          } else if (!inTable) {\r\n            $datepicker.hide();\r\n          } else {\r\n            evt.stopPropagation();\r\n            evt.preventDefault();\r\n          }\r\n        };\r\n\r\n        // Public methods\r\n\r\n        $datepicker.update = function (date) {\r\n          // console.warn('$datepicker.update() newValue=%o', date);\r\n          if (angular.isDate(date) && !isNaN(date.getTime())) {\r\n            $datepicker.$date = date;\r\n            $picker.update.call($picker, date);\r\n          }\r\n          // Build only if pristine\r\n          $datepicker.$build(true);\r\n        };\r\n\r\n        $datepicker.updateDisabledDates = function (dateRanges) {\r\n          options.disabledDateRanges = dateRanges;\r\n          for (var i = 0, l = scope.rows.length; i < l; i++) {\r\n            angular.forEach(scope.rows[i], $datepicker.$setDisabledEl);\r\n          }\r\n        };\r\n\r\n        $datepicker.select = function (date, keep) {\r\n          // console.warn('$datepicker.select', date, scope.$mode);\r\n          if (angular.isDate(date)) {\r\n            if (!angular.isDate(controller.$dateValue) || isNaN(controller.$dateValue.getTime())) {\r\n              controller.$dateValue = new Date(date);\r\n            }\r\n          } else {\r\n            controller.$dateValue = null;\r\n          }\r\n          if (!scope.$mode || keep) {\r\n            controller.$setViewValue(angular.copy(date));\r\n            controller.$render();\r\n            if (options.autoclose && !keep) {\r\n              $timeout(function () {\r\n                $datepicker.hide(true);\r\n              });\r\n            }\r\n          } else {\r\n            angular.extend(viewDate, {\r\n              year: date.getFullYear(),\r\n              month: date.getMonth(),\r\n              date: date.getDate()\r\n            });\r\n            $datepicker.setMode(scope.$mode - 1);\r\n            $datepicker.$build();\r\n          }\r\n        };\r\n\r\n        /**\r\n         * This changes the mode of the picker. By setting the mode the view for the picker will be\r\n         * rebuilt. The views are days, months, and years.\r\n         * @param {int} mode View mode for the datepicker. 0: day view, 1: month view, 2: year view.\r\n         */\r\n        $datepicker.setMode = function setMode (mode) {\r\n          scope.$mode = mode;\r\n          $picker = $datepicker.$views[scope.$mode];\r\n          // The picker has been changed so the view needs to be built.\r\n          $datepicker.$build();\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        /**\r\n         * Builds the datepicker's view based on the picker that is currently set.\r\n         */\r\n        $datepicker.$build = function $build (pristine) {\r\n          // console.warn('$datepicker.$build() viewDate=%o', viewDate);\r\n          if (pristine === true && $picker.built) return;\r\n          if (pristine === false && !$picker.built) return;\r\n          $picker.build.call($picker);\r\n        };\r\n\r\n        $datepicker.$updateSelected = function () {\r\n          for (var i = 0, l = scope.rows.length; i < l; i++) {\r\n            angular.forEach(scope.rows[i], function (day) {\r\n              updateSelected(day);\r\n              if (day.selected) scope.selected = day;\r\n            });\r\n          }\r\n        };\r\n\r\n        $datepicker.$isSelected = function (date) {\r\n          return $picker.isSelected(date);\r\n        };\r\n\r\n        $datepicker.$setDisabledEl = function (el) {\r\n          el.disabled = $picker.isDisabled(el.date);\r\n        };\r\n\r\n        $datepicker.$selectPane = function (value) {\r\n          var steps = $picker.steps;\r\n          // set targetDate to first day of month to avoid problems with\r\n          // date values rollover. This assumes the viewDate does not\r\n          // depend on the day of the month\r\n          var targetDate = new Date(Date.UTC(viewDate.year + ((steps.year || 0) * value), viewDate.month + ((steps.month || 0) * value), 1));\r\n          angular.extend(viewDate, {\r\n            year: targetDate.getUTCFullYear(),\r\n            month: targetDate.getUTCMonth(),\r\n            date: targetDate.getUTCDate()\r\n          });\r\n          $datepicker.$build();\r\n        };\r\n\r\n        $datepicker.$onMouseDown = function (evt) {\r\n          // Prevent blur on mousedown on .dropdown-menu\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n          // Emulate click for mobile devices\r\n          if (isTouch) {\r\n            var targetEl = angular.element(evt.target);\r\n            if (targetEl[0].nodeName.toLowerCase() !== 'button') {\r\n              targetEl = targetEl.parent();\r\n            }\r\n            targetEl.triggerHandler('click');\r\n          }\r\n        };\r\n\r\n        /**\r\n         * Handles the onKeyDown event from the element that this datepicker is bound.\r\n         * In the standard case this will be an input element. If the trigger is set\r\n         * to click and is bound to a button then it is likely we're servicing a 508\r\n         * type situation where the implementation will no longer uses. Focus will be\r\n         * given to the table.\r\n         */\r\n        $datepicker.$onKeyDown = function (evt) {\r\n          var continueHandling = handleOnKeyDown(evt);\r\n\r\n          if (continueHandling) {\r\n            // Navigate with keyboard\r\n            $picker.onKeyDown(evt);\r\n            parentScope.$digest();\r\n          }\r\n        };\r\n\r\n        // $datepicker.$onFocusOut = function (evt) {\r\n        //   // find out if the related target's parents contain the datepicker's $element\r\n        //   var inTable = false;\r\n        //   var parent = angular.element(evt.relatedTarget);\r\n        //   while (parent !== undefined && parent.length && parent[0] !== $window.document.body) {\r\n        //     parent = parent.parent();\r\n        //     if (parent !== undefined && parent[0] === $datepicker.$element[0]) {\r\n        //       inTable = true;\r\n        //       break;\r\n        //     } else {\r\n        //       inTable = false;\r\n        //     }\r\n        //   }\r\n\r\n        //   // In Chrome there is an issue when moving from month to month, year to year, etc.\r\n        //   //\r\n\r\n        //   if (!inTable && !evt.relatedTarget) {\r\n        //     // hmm\r\n        //   } else if (!inTable) {\r\n        //     $datepicker.hide();\r\n        //   } else {\r\n        //     evt.stopPropagation();\r\n        //     evt.preventDefault();\r\n        //   }\r\n        // };\r\n\r\n        // Private\r\n\r\n        function updateSelected (el) {\r\n          el.selected = $datepicker.$isSelected(el.date);\r\n          el.focused = el.selected;\r\n        }\r\n\r\n        function focusElement () {\r\n          element[0].focus();\r\n        }\r\n\r\n        // Overrides\r\n\r\n        // The datepicker will override the init functionality of the tool\r\n        var _init = $datepicker.init;\r\n        /**\r\n         * Initialize the datepicker.\r\n         */\r\n        $datepicker.init = function () {\r\n          if (isNative && options.useNative) {\r\n            element.prop('type', 'date');\r\n            element.css('-webkit-appearance', 'textfield');\r\n            return;\r\n          } else if (isTouch) {\r\n            element.prop('type', 'text');\r\n            element.attr('readonly', 'true');\r\n            element.on('click', focusElement);\r\n          }\r\n          _init();\r\n        };\r\n\r\n        // The datepicker will override the destroy functionalty of the tooltip. Storing a ref to the\r\n        // tooltip's destroy function so that it can be invoked when the datepicker needs to be destroyed.\r\n        var _destroy = $datepicker.destroy;\r\n\r\n        /**\r\n         * Destroys the datepicker by removing bound events. Calls the destroy function on the tooltip.\r\n         */\r\n        $datepicker.destroy = function () {\r\n          if (isNative && options.useNative) {\r\n            element.off('click', focusElement);\r\n          }\r\n          _destroy();\r\n        };\r\n\r\n        // The datepicker will override the show functionality of the tooltip. Store a ref to the\r\n        // tooltip's show function so that it can be invoked at the appropriate time when the picker\r\n        // is to be shown.\r\n        var _show = $datepicker.show;\r\n\r\n        /**\r\n         * Override for the tooltip's show function.\r\n         *\r\n         * Checks the element for readonly or disabled before showing the \"tooltip\".\r\n         * Once shown it sets up the appropriate events.\r\n         */\r\n        $datepicker.show = function show () {\r\n          // If the input the directive is bound to is readonly or disabled then do not show a picker.\r\n          if ((!isTouch && element.attr('readonly')) || element.attr('disabled')) return;\r\n\r\n          // Call the \"overriden base\" function on the tooltip.\r\n          _show();\r\n\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed imediately.\r\n          $timeout(function () {\r\n            // if $datepicker is no longer showing, don't setup events\r\n            if (!$datepicker.$isShown) return;\r\n\r\n            // Update assistive technologies for view changes:\r\n            $datepicker.$element.attr('aria-hidden', 'false');\r\n            element.attr('aria-expanded', 'true');\r\n\r\n            // Setup the event mouse click event. TODO: Can this be wired up in the view?\r\n            $datepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\r\n\r\n            // If keyboard navigation is enabled (true by default).\r\n            if (options.keyboard) {\r\n              // $datepicker.$element.on('keydown', $datepicker.$onKeyDown);\r\n              // Check to see if the table element should receive the focus when the picker is shown.\r\n              if (options.focusOnOpen) {\r\n                // Focus the table element.\r\n                // $datepicker.$element.find('table')[0].focus();\r\n                // $datepicker.$element.on('focusout', $datepicker.$onFocusOut);\r\n              } else {\r\n                element.on('keydown', $datepicker.$onKeyDown);\r\n              }\r\n            }\r\n          }, 0, false);\r\n        };\r\n\r\n        // The datepicker will override the hide functionality of the tooltip. Store a ref to the\r\n        // tooltip's show function so that it can be invoked at the appropriate time when the picker\r\n        // is to be hidden.\r\n        var _hide = $datepicker.hide;\r\n\r\n        /**\r\n         * Overrid efor the tooltip's hide function.\r\n         *\r\n         * Updates attributes for assistive technologies and unbinds events.\r\n         */\r\n        $datepicker.hide = function (blur) {\r\n          // If the picker is already hidden don't do anything.\r\n          if (!$datepicker.$isShown) return;\r\n\r\n          // Update the attributes used by assisteive technologies\r\n          $datepicker.$element.attr('aria-hidden', 'true');\r\n          element.attr('aria-expanded', 'false');\r\n\r\n          // Unbind the mouse and touch events\r\n          $datepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\r\n\r\n          // If keyboard events were bound then unbind them.\r\n          if (options.keyboard) {\r\n            element.off('keydown', $datepicker.$onKeyDown);\r\n            $datepicker.$element.off('keydown', $datepicker.$onKeyDown);\r\n          }\r\n          if (options.focusOnOpen) {\r\n            // $datepicker.$element.off('focusout', $datepicker.$onFocusOut);\r\n            element[0].focus();\r\n          }\r\n          // Call the tooltip's hide function.\r\n          _hide(blur);\r\n        };\r\n\r\n        return $datepicker;\r\n      }\r\n\r\n      DatepickerFactory.defaults = defaults;\r\n      return DatepickerFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsDatepicker', function ($window, $parse, $q, $dateFormatter, $dateParser, $datepicker) {\r\n\r\n    // var defaults = $datepicker.defaults;\r\n    var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        // Directive options\r\n        var options = {\r\n          scope: scope\r\n        };\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'autoclose', 'dateType', 'dateFormat', 'timezone', 'modelDateFormat', 'dayFormat', 'strictFormat', 'startWeek', 'startDate', 'useNative', 'lang', 'startView', 'minView', 'iconLeft', 'iconRight', 'daysOfWeekDisabled', 'id', 'prefixClass', 'prefixEvent', 'hasToday', 'hasClear', 'focusOnOpen', 'labelNext', 'labelPrevious', 'labelMonth', 'labelYear', 'labelDays'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container', 'autoclose', 'useNative', 'hasToday', 'hasClear', 'focusOnOpen'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\r\n            options[key] = false;\r\n          }\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Initialize datepicker\r\n        var datepicker = $datepicker(element, controller, options);\r\n        options = datepicker.$options;\r\n        // Set expected iOS format\r\n        if (isNative && options.useNative) options.dateFormat = 'yyyy-MM-dd';\r\n\r\n        var lang = options.lang;\r\n\r\n        var formatDate = function (date, format) {\r\n          return $dateFormatter.formatDate(date, format, lang);\r\n        };\r\n\r\n        var dateParser = $dateParser({\r\n          format: options.dateFormat,\r\n          lang: lang,\r\n          strict: options.strictFormat\r\n        });\r\n\r\n        // Visibility binding support\r\n        if (attr.bsShow) {\r\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\r\n            if (!datepicker || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(datepicker),?/i);\r\n            if (newValue === true) {\r\n              datepicker.show();\r\n            } else {\r\n              datepicker.hide();\r\n            }\r\n          });\r\n        }\r\n\r\n        // Observe attributes for changes\r\n        angular.forEach(['minDate', 'maxDate'], function (key) {\r\n          // console.warn('attr.$observe(%s)', key, attr[key]);\r\n          if (angular.isDefined(attr[key])) {\r\n            attr.$observe(key, function (newValue) {\r\n              // console.warn('attr.$observe(%s)=%o', key, newValue);\r\n              datepicker.$options[key] = dateParser.getDateForAttribute(key, newValue);\r\n              // Build only if dirty\r\n              if (!isNaN(datepicker.$options[key])) datepicker.$build(false);\r\n              validateAgainstMinMaxDate(controller.$dateValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Observe date format\r\n        if (angular.isDefined(attr.dateFormat)) {\r\n          attr.$observe('dateFormat', function (newValue) {\r\n            datepicker.$options.dateFormat = newValue;\r\n          });\r\n        }\r\n\r\n        // Watch model for changes\r\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\r\n          datepicker.update(controller.$dateValue);\r\n        }, true);\r\n\r\n        // Normalize undefined/null/empty array,\r\n        // so that we don't treat changing from undefined->null as a change.\r\n        function normalizeDateRanges (ranges) {\r\n          if (!ranges || !ranges.length) return null;\r\n          return ranges;\r\n        }\r\n\r\n        if (angular.isDefined(attr.disabledDates)) {\r\n          scope.$watch(attr.disabledDates, function (disabledRanges, previousValue) {\r\n            disabledRanges = normalizeDateRanges(disabledRanges);\r\n            previousValue = normalizeDateRanges(previousValue);\r\n\r\n            if (disabledRanges) {\r\n              datepicker.updateDisabledDates(disabledRanges);\r\n            }\r\n          });\r\n        }\r\n\r\n        function validateAgainstMinMaxDate (parsedDate) {\r\n          if (!angular.isDate(parsedDate)) return;\r\n          var isMinValid = isNaN(datepicker.$options.minDate) || parsedDate.getTime() >= datepicker.$options.minDate;\r\n          var isMaxValid = isNaN(datepicker.$options.maxDate) || parsedDate.getTime() <= datepicker.$options.maxDate;\r\n          var isValid = isMinValid && isMaxValid;\r\n          controller.$setValidity('date', isValid);\r\n          controller.$setValidity('min', isMinValid);\r\n          controller.$setValidity('max', isMaxValid);\r\n          // Only update the model when we have a valid date\r\n          if (isValid) controller.$dateValue = parsedDate;\r\n        }\r\n\r\n        // viewValue -> $parsers -> modelValue\r\n        controller.$parsers.unshift(function (viewValue) {\r\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\r\n          var date;\r\n          // Null values should correctly reset the model value & validity\r\n          if (!viewValue) {\r\n            controller.$setValidity('date', true);\r\n            // BREAKING CHANGE:\r\n            // return null (not undefined) when input value is empty, so angularjs 1.3\r\n            // ngModelController can go ahead and run validators, like ngRequired\r\n            return null;\r\n          }\r\n          var parsedDate = dateParser.parse(viewValue, controller.$dateValue);\r\n          if (!parsedDate || isNaN(parsedDate.getTime())) {\r\n            controller.$setValidity('date', false);\r\n            // return undefined, causes ngModelController to\r\n            // invalidate model value\r\n            return;\r\n          }\r\n          validateAgainstMinMaxDate(parsedDate);\r\n\r\n          if (options.dateType === 'string') {\r\n            date = dateParser.timezoneOffsetAdjust(parsedDate, options.timezone, true);\r\n            return formatDate(date, options.modelDateFormat || options.dateFormat);\r\n          }\r\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\r\n          if (options.dateType === 'number') {\r\n            return date.getTime();\r\n          } else if (options.dateType === 'unix') {\r\n            return date.getTime() / 1000;\r\n          } else if (options.dateType === 'iso') {\r\n            return date.toISOString();\r\n          }\r\n          return new Date(date);\r\n        });\r\n\r\n        // modelValue -> $formatters -> viewValue\r\n        controller.$formatters.push(function (modelValue) {\r\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n          var date;\r\n          if (angular.isUndefined(modelValue) || modelValue === null) {\r\n            date = NaN;\r\n          } else if (angular.isDate(modelValue)) {\r\n            date = modelValue;\r\n          } else if (options.dateType === 'string') {\r\n            date = dateParser.parse(modelValue, null, options.modelDateFormat);\r\n          } else if (options.dateType === 'unix') {\r\n            date = new Date(modelValue * 1000);\r\n          } else {\r\n            date = new Date(modelValue);\r\n          }\r\n          // Setup default value?\r\n          // if (isNaN(date.getTime())) {\r\n          //   var today = new Date();\r\n          //   date = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0);\r\n          // }\r\n          // do not adjust date if timezone is UTC\r\n          if (options.timezone === 'UTC') {\r\n            controller.$dateValue = date;\r\n          } else {\r\n            controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\r\n          }\r\n          return getDateFormattedString();\r\n        });\r\n\r\n        // viewValue -> element\r\n        controller.$render = function () {\r\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\r\n          element.val(getDateFormattedString());\r\n        };\r\n\r\n        function getDateFormattedString () {\r\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.dateFormat);\r\n        }\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (datepicker) datepicker.destroy();\r\n          options = null;\r\n          datepicker = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsDatepickerDisplay', function ($datepicker, $dateParser, $dateFormatter) {\r\n    return {\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n        // Directive options\r\n        var options = {\r\n          scope: scope\r\n        };\r\n        angular.forEach(['dateType', 'dateFormat', 'timezone', 'modelDateFormat', 'dayFormat', 'strictFormat', 'lang'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        options = angular.extend({}, $datepicker.defaults, options);\r\n\r\n        var lang = options.lang;\r\n\r\n        var formatDate = function (date, format) {\r\n          return $dateFormatter.formatDate(date, format, lang);\r\n        };\r\n\r\n        var dateParser = $dateParser({\r\n          format: options.dateFormat,\r\n          lang: lang,\r\n          strict: options.strictFormat\r\n        });\r\n\r\n        // Observe attributes for changes\r\n        angular.forEach(['minDate', 'maxDate'], function (key) {\r\n          if (angular.isDefined(attr[key])) {\r\n            attr.$observe(key, function (newValue) {\r\n              options[key] = dateParser.getDateForAttribute(key, newValue);\r\n              validateAgainstMinMaxDate(controller.$dateValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Observe date format\r\n        if (angular.isDefined(attr.dateFormat)) {\r\n          attr.$observe('dateFormat', function (newValue) {\r\n            options.dateFormat = newValue;\r\n          });\r\n        }\r\n\r\n        function validateAgainstMinMaxDate (parsedDate) {\r\n          if (!angular.isDate(parsedDate)) return;\r\n          var isMinValid = isNaN(options.minDate) || parsedDate.getTime() >= options.minDate;\r\n          var isMaxValid = isNaN(options.maxDate) || parsedDate.getTime() <= options.maxDate;\r\n          var isValid = isMinValid && isMaxValid;\r\n          controller.$setValidity('date', isValid);\r\n          controller.$setValidity('min', isMinValid);\r\n          controller.$setValidity('max', isMaxValid);\r\n          // Only update the model when we have a valid date\r\n          if (isValid) controller.$dateValue = parsedDate;\r\n        }\r\n\r\n        // viewValue -> $parsers -> modelValue\r\n        controller.$parsers.unshift(function (viewValue) {\r\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\r\n          var date;\r\n          // Null values should correctly reset the model value & validity\r\n          if (!viewValue) {\r\n            controller.$setValidity('date', true);\r\n            // BREAKING CHANGE:\r\n            // return null (not undefined) when input value is empty, so angularjs 1.3\r\n            // ngModelController can go ahead and run validators, like ngRequired\r\n            return null;\r\n          }\r\n          var parsedDate = dateParser.parse(viewValue, controller.$dateValue);\r\n          if (!parsedDate || isNaN(parsedDate.getTime())) {\r\n            controller.$setValidity('date', false);\r\n            // return undefined, causes ngModelController to\r\n            // invalidate model value\r\n            return;\r\n          }\r\n          validateAgainstMinMaxDate(parsedDate);\r\n\r\n          if (options.dateType === 'string') {\r\n            date = dateParser.timezoneOffsetAdjust(parsedDate, options.timezone, true);\r\n            return formatDate(date, options.modelDateFormat || options.dateFormat);\r\n          }\r\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\r\n          if (options.dateType === 'number') {\r\n            return date.getTime();\r\n          } else if (options.dateType === 'unix') {\r\n            return date.getTime() / 1000;\r\n          } else if (options.dateType === 'iso') {\r\n            return date.toISOString();\r\n          }\r\n\r\n          return date === null ? null : new Date(date);\r\n        });\r\n\r\n        // modelValue -> $formatters -> viewValue\r\n        controller.$formatters.push(function (modelValue) {\r\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n          var date;\r\n          if (angular.isUndefined(modelValue) || modelValue === null) {\r\n            date = NaN;\r\n          } else if (angular.isDate(modelValue)) {\r\n            date = modelValue;\r\n          } else if (options.dateType === 'string') {\r\n            date = dateParser.parse(modelValue, null, options.modelDateFormat);\r\n          } else if (options.dateType === 'unix') {\r\n            date = new Date(modelValue * 1000);\r\n          } else {\r\n            date = new Date(modelValue);\r\n          }\r\n          // Setup default value?\r\n          // if (isNaN(date.getTime())) {\r\n          //   var today = new Date();\r\n          //   date = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0);\r\n          // }\r\n          // do not adjust date if timezone is UTC\r\n          if (options.timezone === 'UTC') {\r\n            controller.$dateValue = date;\r\n          } else {\r\n            controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\r\n          }\r\n\r\n          return getDateFormattedString();\r\n        });\r\n\r\n        function getDateFormattedString () {\r\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.dateFormat);\r\n        }\r\n      }\r\n    };\r\n  })\r\n\r\n  .provider('datepickerViews', function () {\r\n\r\n    // var defaults = this.defaults = {\r\n    //   dayFormat: 'dd',\r\n    //   daySplit: 7\r\n    // };\r\n\r\n    // Split array into smaller arrays\r\n    function split (arr, size) {\r\n      var arrays = [];\r\n      while (arr.length > 0) {\r\n        arrays.push(arr.splice(0, size));\r\n      }\r\n      return arrays;\r\n    }\r\n\r\n    // Modulus operator\r\n    function mod (n, m) {\r\n      return ((n % m) + m) % m;\r\n    }\r\n\r\n    this.$get = function ($dateFormatter, $dateParser, $sce) {\r\n\r\n      return function (picker) {\r\n\r\n        var scope = picker.$scope;\r\n        var options = picker.$options;\r\n\r\n        var lang = options.lang;\r\n        var formatDate = function (date, format) {\r\n          return $dateFormatter.formatDate(date, format, lang);\r\n        };\r\n        var dateParser = $dateParser({\r\n          format: options.dateFormat,\r\n          lang: lang,\r\n          strict: options.strictFormat\r\n        });\r\n\r\n        var weekDaysMin = $dateFormatter.weekdaysShort(lang);\r\n        var weekDaysLong = $dateFormatter.weekdays(lang);\r\n        var weekDaysShortLabels = weekDaysMin.slice(options.startWeek).concat(weekDaysMin.slice(0, options.startWeek));\r\n        var weekDaysLongLabels = weekDaysLong.slice(options.startWeek).concat(weekDaysMin.slice(0, options.startWeek));\r\n\r\n        var weekDaysLabelsHtml = '';\r\n        for (var i = 0; i < weekDaysShortLabels.length; i++) {\r\n          var weekDayShortLabel = weekDaysShortLabels[i];\r\n          var weekDayLabel = weekDaysLongLabels[i];\r\n          weekDaysLabelsHtml += '<th scope=\"col\" role=\"columnheader\" class=\"dow text-center\" aria-label=\"' + weekDayLabel + '\"><abbr title=\"' + weekDayLabel + '\">' + weekDayShortLabel + '</abbr></th>';\r\n        }\r\n        weekDaysLabelsHtml = $sce.trustAsHtml(weekDaysLabelsHtml);\r\n\r\n        var startDate = picker.$date || (options.startDate ? dateParser.getDateForAttribute('startDate', options.startDate) : new Date());\r\n        var viewDate = {\r\n          year: startDate.getFullYear(),\r\n          month: startDate.getMonth(),\r\n          date: startDate.getDate()\r\n        };\r\n\r\n        var views = [{\r\n          format: options.dayFormat,\r\n          split: 7,\r\n          steps: {\r\n            month: 1\r\n          },\r\n          update: function (date, force) {\r\n            if (!this.built || force || date.getFullYear() !== viewDate.year || date.getMonth() !== viewDate.month) {\r\n              angular.extend(viewDate, {\r\n                year: picker.$date.getFullYear(),\r\n                month: picker.$date.getMonth(),\r\n                date: picker.$date.getDate()\r\n              });\r\n              picker.$build();\r\n            } else if (date.getDate() !== viewDate.date || date.getDate() === 1) {\r\n              // chaging picker current month will cause viewDate.date to be set to first day of the month,\r\n              // in $datepicker.$selectPane, so picker would not update selected day display if\r\n              // user picks first day of the new month.\r\n              // As a workaround, we are always forcing update when picked date is first day of month.\r\n              viewDate.date = picker.$date.getDate();\r\n              picker.$updateSelected();\r\n            }\r\n          },\r\n          build: function () {\r\n            var firstDayOfMonth = new Date(viewDate.year, viewDate.month, 1);\r\n            var firstDayOfMonthOffset = firstDayOfMonth.getTimezoneOffset();\r\n            var firstDate = new Date(+firstDayOfMonth - mod(firstDayOfMonth.getDay() - options.startWeek, 7) * 864e5);\r\n            var firstDateOffset = firstDate.getTimezoneOffset();\r\n            var today = dateParser.timezoneOffsetAdjust(new Date(), options.timezone).toDateString();\r\n            // Handle daylight time switch\r\n            if (firstDateOffset !== firstDayOfMonthOffset) firstDate = new Date(+firstDate + (firstDateOffset - firstDayOfMonthOffset) * 60e3);\r\n            var days = [];\r\n            var day;\r\n            var selectedDay;\r\n            var todayDay;\r\n            for (var i = 0; i < 42; i++) { // < 7 * 6\r\n              day = dateParser.daylightSavingAdjust(new Date(firstDate.getFullYear(), firstDate.getMonth(), firstDate.getDate() + i));\r\n              // push the day information onto the collection\r\n              var dayItem = {\r\n                id: options.id !== null && options.id !== undefined ? (options.id + '_cell_' + i) : undefined,\r\n                date: day,\r\n                value: day.getDate(),\r\n                isToday: day.toDateString() === today,\r\n                label: formatDate(day, this.format),\r\n                screenReaderLabel: formatDate(day, $dateFormatter.getDatetimeFormat(options.screenReaderDateFormat)),\r\n                selected: picker.$date && this.isSelected(day),\r\n                muted: day.getMonth() !== viewDate.month,\r\n                disabled: this.isDisabled(day)\r\n              };\r\n\r\n              if (dayItem.selected) selectedDay = dayItem;\r\n              if (dayItem.isToday) todayDay = dayItem;\r\n\r\n              days.push(dayItem);\r\n            }\r\n\r\n            scope.selected = null;\r\n\r\n            var defaultFirstDayTabIndex = false;\r\n            // Setup the focusing\r\n            if (options.focusOnOpen) {\r\n              if (selectedDay) {\r\n                scope.selectedDayId = selectedDay.id;\r\n                if (todayDay) todayDay.focused = false;\r\n                // Needs to fire after the today focusing is unset in case the selected day is today.\r\n                selectedDay.focused = true;\r\n                scope.selected = selectedDay;\r\n              } else if (todayDay) {\r\n                todayDay.focused = true;\r\n              } else {\r\n                defaultFirstDayTabIndex = true;\r\n              }\r\n            }\r\n\r\n            scope.title = formatDate(firstDayOfMonth, options.monthTitleFormat);\r\n            scope.showLabels = true;\r\n            scope.labels = weekDaysLabelsHtml;\r\n            scope.rows = split(days, this.split);\r\n            if (defaultFirstDayTabIndex) {\r\n              scope.rows[0][0].isNext = true;\r\n            }\r\n            scope.isTodayDisabled = this.isDisabled(new Date());\r\n            scope.hasSelectedDate = picker.$date != null;\r\n            scope.$modeLabel = options.labelMonth;\r\n            this.built = true;\r\n          },\r\n          isSelected: function (date) {\r\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear() &&\r\n              date.getMonth() === picker.$date.getMonth() &&\r\n              date.getDate() === picker.$date.getDate();\r\n          },\r\n          isDisabled: function (date) {\r\n            var time = date.getTime();\r\n\r\n            // Disabled because of min/max date.\r\n            if (time < options.minDate || time > options.maxDate) return true;\r\n\r\n            // Disabled due to being a disabled day of the week\r\n            if (options.daysOfWeekDisabled.indexOf(date.getDay()) !== -1) return true;\r\n\r\n            // Disabled because of disabled date range.\r\n            if (options.disabledDateRanges) {\r\n              for (var i = 0; i < options.disabledDateRanges.length; i++) {\r\n                if (time >= options.disabledDateRanges[i].start && time <= options.disabledDateRanges[i].end) {\r\n                  return true;\r\n                }\r\n              }\r\n            }\r\n\r\n            return false;\r\n          },\r\n          onKeyDown: function (evt) {\r\n            var actualTime;\r\n\r\n            // If the picker doesn't have a date selected and the event comes from the today TD\r\n            // then set the picker's $date to today and set the actual time to its value.\r\n            if (options.keyboard &&\r\n              options.focusOnOpen &&\r\n              !picker.$date) {\r\n              if (angular.element(evt.target).find('span').hasClass('btn-today')) {\r\n                picker.$date = new Date();\r\n              } else {\r\n                picker.$date = dateParser.parse(angular.element(evt.target).attr('aria-label'), null, options.screenReaderDateFormat);\r\n              }\r\n            }\r\n\r\n            if (!picker.$date) {\r\n              return false;\r\n            }\r\n\r\n            actualTime = picker.$date.getTime();\r\n\r\n            var newDate;\r\n\r\n            switch (evt.keyCode) {\r\n              // enter\r\n              case 13:\r\n                if (options.focusOnOpen) {\r\n                  picker.select(new Date(actualTime), true);\r\n                  return false;\r\n                }\r\n                break;\r\n                // pageup\r\n              case 33:\r\n                if (evt.altKey) { // move back a year\r\n                  newDate = new Date(picker.$date.getFullYear() - 1, picker.$date.getMonth(), picker.$date.getDate());\r\n                } else { // move back a month\r\n                  newDate = new Date(picker.$date.getFullYear(), picker.$date.getMonth() - 1, picker.$date.getDate());\r\n                  if (newDate.getMonth() > (picker.$date.getMonth() - 1)) {\r\n                    newDate = new Date(picker.$date.getFullYear(), picker.$date.getMonth(), 0);\r\n                  }\r\n                }\r\n                break;\r\n\r\n                // pagedown\r\n              case 34:\r\n                if (evt.altKey) { // move forward a year\r\n                  newDate = new Date(picker.$date.getFullYear() + 1, picker.$date.getMonth(), picker.$date.getDate());\r\n                } else { // move forward a month\r\n                  newDate = new Date(picker.$date.getFullYear(), picker.$date.getMonth() + 1, picker.$date.getDate());\r\n                  if (newDate.getMonth() > (picker.$date.getMonth() + 1)) {\r\n                    newDate = new Date(picker.$date.getFullYear(), picker.$date.getMonth() + 1, 1);\r\n                  }\r\n                }\r\n\r\n                break;\r\n\r\n                // left arrow\r\n              case 37:\r\n                newDate = new Date(actualTime - 1 * 864e5);\r\n                break;\r\n\r\n                // up arrow\r\n              case 38:\r\n                newDate = new Date(actualTime - 7 * 864e5);\r\n                break;\r\n\r\n                // right arrow\r\n              case 39:\r\n                newDate = new Date(actualTime + 1 * 864e5);\r\n                break;\r\n\r\n                // down arrow\r\n              case 40:\r\n                newDate = new Date(actualTime + 7 * 864e5);\r\n                break;\r\n\r\n              default:\r\n                return false;\r\n            }\r\n\r\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\r\n\r\n            if (evt && evt.stopPropagation) evt.stopPropagation();\r\n\r\n            return false;\r\n          }\r\n        }, {\r\n          name: 'month',\r\n          format: options.monthFormat,\r\n          split: 4,\r\n          steps: {\r\n            year: 1\r\n          },\r\n          update: function (date, force) {\r\n            if (!this.built || date.getFullYear() !== viewDate.year) {\r\n              angular.extend(viewDate, {\r\n                year: picker.$date.getFullYear(),\r\n                month: picker.$date.getMonth(),\r\n                date: picker.$date.getDate()\r\n              });\r\n              picker.$build();\r\n            } else if (date.getMonth() !== viewDate.month) {\r\n              angular.extend(viewDate, {\r\n                month: picker.$date.getMonth(),\r\n                date: picker.$date.getDate()\r\n              });\r\n              picker.$updateSelected();\r\n            }\r\n          },\r\n          build: function () {\r\n            // var firstMonth = new Date(viewDate.year, 0, 1);\r\n            var months = [];\r\n            var month;\r\n            var thisMonthDate = new Date((new Date()).getFullYear(), (new Date()).getMonth(), 1);\r\n            var selectedMonth;\r\n            var thisMonth;\r\n            for (var i = 0; i < 12; i++) {\r\n              month = new Date(viewDate.year, i, 1);\r\n\r\n              var monthItem = {\r\n                date: month,\r\n                label: formatDate(month, this.format),\r\n                selected: picker.$isSelected(month),\r\n                isToday: month.getFullYear() === thisMonthDate.getFullYear() && month.getMonth() === thisMonthDate.getMonth(),\r\n                disabled: this.isDisabled(month)\r\n              };\r\n\r\n              if (monthItem.selected) selectedMonth = monthItem;\r\n              if (monthItem.isToday) thisMonth = monthItem;\r\n\r\n              months.push(monthItem);\r\n            }\r\n\r\n            scope.selected = null;\r\n\r\n            var defaultFirstDayTabIndex = false;\r\n            // Setup the focusing\r\n            if (options.focusOnOpen) {\r\n              if (selectedMonth) {\r\n                scope.selectedDayId = selectedMonth.id;\r\n                if (thisMonth) thisMonth.focused = false;\r\n                // Needs to fire after the today focusing is unset in case the selected day is today.\r\n                selectedMonth.focused = true;\r\n                scope.selected = selectedMonth;\r\n              } else if (thisMonth) {\r\n                thisMonth.focused = true;\r\n              } else {\r\n                defaultFirstDayTabIndex = true;\r\n              }\r\n            }\r\n\r\n            scope.title = formatDate(month, options.yearTitleFormat);\r\n            scope.showLabels = false;\r\n            scope.rows = split(months, this.split);\r\n            if (defaultFirstDayTabIndex) {\r\n              scope.rows[0][0].isNext = true;\r\n            }\r\n            scope.$modeLabel = options.labelYear;\r\n            this.built = true;\r\n          },\r\n          isSelected: function (date) {\r\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth();\r\n          },\r\n          isDisabled: function (date) {\r\n            var lastDate = +new Date(date.getFullYear(), date.getMonth() + 1, 0);\r\n            return lastDate < options.minDate || date.getTime() > options.maxDate;\r\n          },\r\n          onKeyDown: function (evt) {\r\n            // If the picker doesn't have a date selected and the event comes from the today TD\r\n            // then set the picker's $date to today and set the actual time to its value.\r\n            if (options.keyboard &&\r\n              options.focusOnOpen &&\r\n              !picker.$date &&\r\n              angular.element(evt.target).find('span').hasClass('btn-today')) {\r\n              picker.$date = new Date((new Date()).getFullYear(), (new Date()).getMonth(), 1);\r\n            }\r\n\r\n            if (!picker.$date) {\r\n              return;\r\n            }\r\n            var actualMonth = picker.$date.getMonth();\r\n            var newDate = new Date(picker.$date);\r\n\r\n            if (evt.keyCode === 37) newDate.setMonth(actualMonth - 1);\r\n            else if (evt.keyCode === 38) newDate.setMonth(actualMonth - 4);\r\n            else if (evt.keyCode === 39) newDate.setMonth(actualMonth + 1);\r\n            else if (evt.keyCode === 40) newDate.setMonth(actualMonth + 4);\r\n\r\n            if (options.focusOnOpen && evt.keyCode === 13) picker.select(new Date(picker.$date));\r\n            else if (!this.isDisabled(newDate)) picker.select(newDate, true);\r\n          }\r\n        }, {\r\n          name: 'year',\r\n          format: options.yearFormat,\r\n          split: 4,\r\n          steps: {\r\n            year: 12\r\n          },\r\n          update: function (date, force) {\r\n            if (!this.built || force || parseInt(date.getFullYear() / 20, 10) !== parseInt(viewDate.year / 20, 10)) {\r\n              angular.extend(viewDate, {\r\n                year: picker.$date.getFullYear(),\r\n                month: picker.$date.getMonth(),\r\n                date: picker.$date.getDate()\r\n              });\r\n              picker.$build();\r\n            } else if (date.getFullYear() !== viewDate.year) {\r\n              angular.extend(viewDate, {\r\n                year: picker.$date.getFullYear(),\r\n                month: picker.$date.getMonth(),\r\n                date: picker.$date.getDate()\r\n              });\r\n              picker.$updateSelected();\r\n            }\r\n          },\r\n          build: function () {\r\n            var firstYear = viewDate.year - viewDate.year % (this.split * 3);\r\n            var years = [];\r\n            var year;\r\n            var selectedYear;\r\n            var thisYear;\r\n            for (var i = 0; i < 12; i++) {\r\n              year = new Date(firstYear + i, 0, 1);\r\n\r\n              var yearItem = {\r\n                date: year,\r\n                label: formatDate(year, this.format),\r\n                selected: picker.$isSelected(year),\r\n                isToday: year.getFullYear() === (new Date()).getFullYear(),\r\n                disabled: this.isDisabled(year)\r\n              };\r\n\r\n              if (yearItem.selected) selectedYear = yearItem;\r\n              if (yearItem.isToday) thisYear = yearItem;\r\n\r\n              years.push(yearItem);\r\n            }\r\n\r\n            scope.selected = null;\r\n\r\n            var defaultFirstDayTabIndex = false;\r\n            // Setup the focusing\r\n            if (options.focusOnOpen) {\r\n              if (selectedYear) {\r\n                scope.selectedDayId = selectedYear.id;\r\n                if (thisYear) thisYear.focused = false;\r\n                // Needs to fire after the today focusing is unset in case the selected day is today.\r\n                selectedYear.focused = true;\r\n                scope.selected = selectedYear;\r\n              } else if (thisYear) {\r\n                thisYear.focused = true;\r\n              } else {\r\n                defaultFirstDayTabIndex = true;\r\n              }\r\n            }\r\n\r\n            scope.title = years[0].label + '-' + years[years.length - 1].label;\r\n            scope.showLabels = false;\r\n            scope.rows = split(years, this.split);\r\n            if (defaultFirstDayTabIndex) {\r\n              scope.rows[0][0].isNext = true;\r\n            }\r\n            scope.$modelLabel = options.labelDays;\r\n            this.built = true;\r\n          },\r\n          isSelected: function (date) {\r\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear();\r\n          },\r\n          isDisabled: function (date) {\r\n            var lastDate = +new Date(date.getFullYear() + 1, 0, 0);\r\n            return lastDate < options.minDate || date.getTime() > options.maxDate;\r\n          },\r\n          onKeyDown: function (evt) {\r\n            // If the picker doesn't have a date selected and the event comes from the today TD\r\n            // then set the picker's $date to today and set the actual time to its value.\r\n            if (options.keyboard &&\r\n              options.focusOnOpen &&\r\n              !picker.$date &&\r\n              angular.element(evt.target).find('span').hasClass('btn-today')) {\r\n              picker.$date = new Date((new Date()).getFullYear(), 0, 1);\r\n            }\r\n\r\n            if (!picker.$date) {\r\n              return;\r\n            }\r\n            var actualYear = picker.$date.getFullYear();\r\n            var newDate = new Date(picker.$date);\r\n\r\n            if (evt.keyCode === 37) newDate.setYear(actualYear - 1);\r\n            else if (evt.keyCode === 38) newDate.setYear(actualYear - 4);\r\n            else if (evt.keyCode === 39) newDate.setYear(actualYear + 1);\r\n            else if (evt.keyCode === 40) newDate.setYear(actualYear + 4);\r\n\r\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\r\n          }\r\n        }];\r\n\r\n        return {\r\n          views: options.minView ? Array.prototype.slice.call(views, options.minView) : views,\r\n          viewDate: viewDate\r\n        };\r\n\r\n      };\r\n\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.collapse', [])\r\n\r\n  .provider('$collapse', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-collapse',\r\n      disallowToggle: false,\r\n      activeClass: 'in',\r\n      startCollapsed: false,\r\n      allowMultiple: false\r\n    };\r\n\r\n    var controller = this.controller = function ($scope, $element, $attrs) {\r\n      var self = this;\r\n\r\n      // Attributes options\r\n      self.$options = angular.copy(defaults);\r\n      angular.forEach(['animation', 'disallowToggle', 'activeClass', 'startCollapsed', 'allowMultiple'], function (key) {\r\n        if (angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\r\n      });\r\n\r\n      // use string regex match boolean attr falsy values, leave truthy values be\r\n      var falseValueRegExp = /^(false|0|)$/i;\r\n      angular.forEach(['disallowToggle', 'startCollapsed', 'allowMultiple'], function (key) {\r\n        if (angular.isDefined($attrs[key]) && falseValueRegExp.test($attrs[key])) {\r\n          self.$options[key] = false;\r\n        }\r\n      });\r\n\r\n      self.$toggles = [];\r\n      self.$targets = [];\r\n\r\n      self.$viewChangeListeners = [];\r\n\r\n      self.$registerToggle = function (element) {\r\n        self.$toggles.push(element);\r\n        element.attr('aria-expanded', 'false');\r\n      };\r\n      self.$registerTarget = function (element) {\r\n        self.$targets.push(element);\r\n\r\n        var i = 0;\r\n        if (self.$targets) {\r\n          for (i = 0; i < self.$targets.length; i++) {\r\n            self.$targets[i].attr('aria-hidden', 'true');\r\n          }\r\n          for (i = 0; i < self.$targets.$active.length; i++) {\r\n            if (self.$targets[self.$targets.$active[i]]) {\r\n              self.$targets[self.$targets.$active[i]].attr('aria-hidden', 'false');\r\n            }\r\n            if (self.$toggles[self.$targets.$active[i]]) {\r\n              self.$toggles[self.$targets.$active[i]].attr('aria-expanded', 'true');\r\n            }\r\n          }\r\n        }\r\n      };\r\n\r\n      self.$unregisterToggle = function (element) {\r\n        var index = self.$toggles.indexOf(element);\r\n        // remove toggle from $toggles array\r\n        self.$toggles.splice(index, 1);\r\n      };\r\n      self.$unregisterTarget = function (element) {\r\n        var index = self.$targets.indexOf(element);\r\n\r\n        // remove element from $targets array\r\n        self.$targets.splice(index, 1);\r\n\r\n        if (self.$options.allowMultiple) {\r\n          // remove target index from $active array values\r\n          deactivateItem(element);\r\n        }\r\n\r\n        // fix active item indexes\r\n        fixActiveItemIndexes(index);\r\n\r\n        self.$viewChangeListeners.forEach(function (fn) {\r\n          fn();\r\n        });\r\n      };\r\n\r\n      // use array to store all the currently open panels\r\n      self.$targets.$active = !self.$options.startCollapsed ? [0] : [];\r\n      self.$setActive = $scope.$setActive = function (value) {\r\n        if (angular.isArray(value)) {\r\n          self.$targets.$active = value;\r\n        } else if (!self.$options.disallowToggle && isActive(value)) {\r\n          deactivateItem(value);\r\n        } else {\r\n          activateItem(value);\r\n        }\r\n\r\n        self.$viewChangeListeners.forEach(function (fn) {\r\n          fn();\r\n        });\r\n      };\r\n\r\n      self.$activeIndexes = function () {\r\n        if (self.$options.allowMultiple) {\r\n          return self.$targets.$active;\r\n        }\r\n        return self.$targets.$active.length === 1 ? self.$targets.$active[0] : -1;\r\n      };\r\n\r\n      function fixActiveItemIndexes (index) {\r\n        // item with index was removed, so we\r\n        // need to adjust other items index values\r\n        var activeIndexes = self.$targets.$active;\r\n        for (var i = 0; i < activeIndexes.length; i++) {\r\n          if (index < activeIndexes[i]) {\r\n            activeIndexes[i] = activeIndexes[i] - 1;\r\n          }\r\n\r\n          // the last item is active, so we need to\r\n          // adjust its index\r\n          if (activeIndexes[i] === self.$targets.length) {\r\n            activeIndexes[i] = self.$targets.length - 1;\r\n          }\r\n        }\r\n      }\r\n\r\n      function isActive (value) {\r\n        var activeItems = self.$targets.$active;\r\n        return activeItems.indexOf(value) !== -1;\r\n      }\r\n\r\n      function deactivateItem (value) {\r\n        var index = self.$targets.$active.indexOf(value);\r\n        if (index !== -1) {\r\n          self.$targets[self.$targets.$active[index]].attr('aria-hidden', 'true');\r\n          self.$toggles[self.$targets.$active[index]].attr('aria-expanded', 'false');\r\n          self.$targets.$active.splice(index, 1);\r\n        }\r\n      }\r\n\r\n      function activateItem (value) {\r\n        if (!self.$options.allowMultiple) {\r\n          // remove current selected item\r\n          if (self.$targets[self.$targets.$active[0]] !== undefined) {\r\n            self.$targets[self.$targets.$active[0]].attr('aria-hidden', 'true');\r\n          }\r\n          if (self.$toggles[self.$targets.$active[0]]) {\r\n            self.$toggles[self.$targets.$active[0]].attr('aria-expanded', 'false');\r\n          }\r\n          self.$targets.$active.splice(0, 1);\r\n        }\r\n\r\n        if (self.$targets.$active.indexOf(value) === -1) {\r\n          self.$targets.$active.push(value);\r\n\r\n          if (self.$targets[self.$targets.$active[self.$targets.$active.length - 1]] !== undefined) {\r\n            self.$targets[self.$targets.$active[self.$targets.$active.length - 1]].attr('aria-hidden', 'false');\r\n          }\r\n          if (self.$toggles[self.$targets.$active[self.$targets.$active.length - 1]] !== undefined) {\r\n            self.$toggles[self.$targets.$active[self.$targets.$active.length - 1]].attr('aria-expanded', 'true');\r\n          }\r\n        }\r\n      }\r\n\r\n    };\r\n\r\n    this.$get = function () {\r\n      var $collapse = {};\r\n      $collapse.defaults = defaults;\r\n      $collapse.controller = controller;\r\n      return $collapse;\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsCollapse', function ($window, $animate, $collapse) {\r\n\r\n    return {\r\n      require: ['?ngModel', 'bsCollapse'],\r\n      controller: ['$scope', '$element', '$attrs', $collapse.controller],\r\n      link: function postLink (scope, element, attrs, controllers) {\r\n\r\n        var ngModelCtrl = controllers[0];\r\n        var bsCollapseCtrl = controllers[1];\r\n\r\n        if (ngModelCtrl) {\r\n\r\n          // Update the modelValue following\r\n          bsCollapseCtrl.$viewChangeListeners.push(function () {\r\n            ngModelCtrl.$setViewValue(bsCollapseCtrl.$activeIndexes());\r\n          });\r\n\r\n          // modelValue -> $formatters -> viewValue\r\n          ngModelCtrl.$formatters.push(function (modelValue) {\r\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n            if (angular.isArray(modelValue)) {\r\n              // model value is an array, so just replace\r\n              // the active items directly\r\n              bsCollapseCtrl.$setActive(modelValue);\r\n            } else {\r\n              var activeIndexes = bsCollapseCtrl.$activeIndexes();\r\n\r\n              if (angular.isArray(activeIndexes)) {\r\n                // we have an array of selected indexes\r\n                if (activeIndexes.indexOf(modelValue * 1) === -1) {\r\n                  // item with modelValue index is not active\r\n                  bsCollapseCtrl.$setActive(modelValue * 1);\r\n                }\r\n              } else if (activeIndexes !== modelValue * 1) {\r\n                bsCollapseCtrl.$setActive(modelValue * 1);\r\n              }\r\n            }\r\n            return modelValue;\r\n          });\r\n\r\n        }\r\n\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsCollapseToggle', function () {\r\n    var KEY_CODES = {\r\n      ENTER: 13,\r\n      SPACE: 32\r\n    };\r\n    return {\r\n      require: ['^?ngModel', '^bsCollapse'],\r\n      link: function postLink (scope, element, attrs, controllers) {\r\n\r\n        // var ngModelCtrl = controllers[0];\r\n        var bsCollapseCtrl = controllers[1];\r\n\r\n        // Add base attr\r\n        element.attr('data-toggle', 'collapse');\r\n\r\n        // Push pane to parent bsCollapse controller\r\n        bsCollapseCtrl.$registerToggle(element);\r\n\r\n        // remove toggle from collapse controller when toggle is destroyed\r\n        scope.$on('$destroy', function () {\r\n          bsCollapseCtrl.$unregisterToggle(element);\r\n        });\r\n\r\n        var actionEventHandler = function () {\r\n          if (!attrs.disabled) {\r\n            var index = attrs.bsCollapseToggle && attrs.bsCollapseToggle !== 'bs-collapse-toggle' ? attrs.bsCollapseToggle : bsCollapseCtrl.$toggles.indexOf(element);\r\n            bsCollapseCtrl.$setActive(index * 1);\r\n            scope.$apply();\r\n          }\r\n        };\r\n\r\n        element.on('click', actionEventHandler);\r\n        element.bind('keydown keypress', function (e) {\r\n          if (e.which === KEY_CODES.ENTER || e.which === KEY_CODES.SPACE) {\r\n            console.log('key handler handling');\r\n            actionEventHandler();\r\n            e.preventDefault();\r\n          }\r\n        });\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsCollapseTarget', function ($animate) {\r\n\r\n    return {\r\n      require: ['^?ngModel', '^bsCollapse'],\r\n      // scope: true,\r\n      link: function postLink (scope, element, attrs, controllers) {\r\n\r\n        // var ngModelCtrl = controllers[0];\r\n        var bsCollapseCtrl = controllers[1];\r\n\r\n        // Add base class\r\n        element.addClass('collapse');\r\n\r\n        // Add animation class\r\n        if (bsCollapseCtrl.$options.animation) {\r\n          element.addClass(bsCollapseCtrl.$options.animation);\r\n        }\r\n\r\n        // Push pane to parent bsCollapse controller\r\n        bsCollapseCtrl.$registerTarget(element);\r\n\r\n        // remove pane target from collapse controller when target is destroyed\r\n        scope.$on('$destroy', function () {\r\n          bsCollapseCtrl.$unregisterTarget(element);\r\n        });\r\n\r\n        function render () {\r\n          var index = bsCollapseCtrl.$targets.indexOf(element);\r\n          var active = bsCollapseCtrl.$activeIndexes();\r\n          var action = 'removeClass';\r\n          if (angular.isArray(active)) {\r\n            if (active.indexOf(index) !== -1) {\r\n              action = 'addClass';\r\n            }\r\n          } else if (index === active) {\r\n            action = 'addClass';\r\n          }\r\n\r\n          $animate[action](element, bsCollapseCtrl.$options.activeClass);\r\n        }\r\n\r\n        bsCollapseCtrl.$viewChangeListeners.push(function () {\r\n          render();\r\n        });\r\n        render();\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.aside', ['mgcrea.ngStrap.modal'])\r\n\r\n  .provider('$aside', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade-and-slide-right',\r\n      prefixClass: 'aside',\r\n      prefixEvent: 'aside',\r\n      placement: 'right',\r\n      templateUrl: 'aside/aside.tpl.html',\r\n      contentTemplate: false,\r\n      container: false,\r\n      element: null,\r\n      backdrop: true,\r\n      keyboard: true,\r\n      html: false,\r\n      show: true\r\n    };\r\n\r\n    this.$get = function ($modal) {\r\n\r\n      function AsideFactory (config) {\r\n\r\n        var $aside = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n\r\n        $aside = $modal(options);\r\n\r\n        return $aside;\r\n\r\n      }\r\n\r\n      return AsideFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsAside', function ($window, $sce, $aside) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink (scope, element, attr, transclusion) {\r\n        // Directive options\r\n        var options = {scope: scope, element: element, show: false};\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['backdrop', 'keyboard', 'html', 'container'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Support scope as data-attrs\r\n        angular.forEach(['title', 'content'], function (key) {\r\n          if (attr[key]) {\r\n            attr.$observe(key, function (newValue, oldValue) {\r\n              scope[key] = $sce.trustAsHtml(newValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Support scope as an object\r\n        if (attr.bsAside) {\r\n          scope.$watch(attr.bsAside, function (newValue, oldValue) {\r\n            if (angular.isObject(newValue)) {\r\n              angular.extend(scope, newValue);\r\n            } else {\r\n              scope.content = newValue;\r\n            }\r\n          }, true);\r\n        }\r\n\r\n        // Initialize aside\r\n        var aside = $aside(options);\r\n\r\n        // Trigger\r\n        element.on(attr.trigger || 'click', aside.toggle);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (aside) aside.destroy();\r\n          options = null;\r\n          aside = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\n// @BUG: following snippet won't compile correctly\r\n\r\nangular.module('mgcrea.ngStrap.alert', ['mgcrea.ngStrap.modal'])\r\n\r\n  .provider('$alert', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      prefixClass: 'alert',\r\n      prefixEvent: 'alert',\r\n      placement: null,\r\n      templateUrl: 'alert/alert.tpl.html',\r\n      container: false,\r\n      element: null,\r\n      backdrop: false,\r\n      keyboard: true,\r\n      show: true,\r\n      // Specific options\r\n      duration: false,\r\n      type: false,\r\n      dismissable: true\r\n    };\r\n\r\n    this.$get = function ($modal, $timeout) {\r\n\r\n      function AlertFactory (config) {\r\n\r\n        var $alert = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n\r\n        $alert = $modal(options);\r\n\r\n        // Support scope as string options [/*title, content, */ type, dismissable]\r\n        $alert.$scope.dismissable = !!options.dismissable;\r\n        if (options.type) {\r\n          $alert.$scope.type = options.type;\r\n        }\r\n\r\n        // Support auto-close duration\r\n        var show = $alert.show;\r\n        if (options.duration) {\r\n          $alert.show = function () {\r\n            show();\r\n            $timeout(function () {\r\n              $alert.hide();\r\n            }, options.duration * 1000);\r\n          };\r\n        }\r\n\r\n        return $alert;\r\n\r\n      }\r\n\r\n      return AlertFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsAlert', function ($window, $sce, $alert) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink (scope, element, attr, transclusion) {\r\n\r\n        // Directive options\r\n        var options = {scope: scope, element: element, show: false};\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'keyboard', 'html', 'container', 'animation', 'duration', 'dismissable'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['keyboard', 'html', 'container', 'dismissable'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // overwrite inherited title value when no value specified\r\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\r\n        if (!scope.hasOwnProperty('title')) {\r\n          scope.title = '';\r\n        }\r\n\r\n        // Support scope as data-attrs\r\n        angular.forEach(['title', 'content', 'type'], function (key) {\r\n          if (attr[key]) {\r\n            attr.$observe(key, function (newValue, oldValue) {\r\n              scope[key] = $sce.trustAsHtml(newValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Support scope as an object\r\n        if (attr.bsAlert) {\r\n          scope.$watch(attr.bsAlert, function (newValue, oldValue) {\r\n            if (angular.isObject(newValue)) {\r\n              angular.extend(scope, newValue);\r\n            } else {\r\n              scope.content = newValue;\r\n            }\r\n          }, true);\r\n        }\r\n\r\n        // Initialize alert\r\n        var alert = $alert(options);\r\n\r\n        // Trigger\r\n        element.on(attr.trigger || 'click', alert.toggle);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (alert) alert.destroy();\r\n          options = null;\r\n          alert = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.affix', ['mgcrea.ngStrap.helpers.dimensions', 'mgcrea.ngStrap.helpers.debounce'])\r\n\r\n  .provider('$affix', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      offsetTop: 'auto',\r\n      inlineStyles: true,\r\n      setWidth: true\r\n    };\r\n\r\n    this.$get = function ($window, debounce, dimensions) {\r\n\r\n      var bodyEl = angular.element($window.document.body);\r\n      var windowEl = angular.element($window);\r\n\r\n      function AffixFactory (element, config) {\r\n\r\n        var $affix = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n        var targetEl = options.target;\r\n\r\n        // Initial private vars\r\n        var reset = 'affix affix-top affix-bottom';\r\n        var setWidth = false;\r\n        var initialAffixTop = 0;\r\n        var initialOffsetTop = 0;\r\n        var offsetTop = 0;\r\n        var offsetBottom = 0;\r\n        var affixed = null;\r\n        var unpin = null;\r\n\r\n        var parent = element.parent();\r\n        // Options: custom parent\r\n        if (options.offsetParent) {\r\n          if (options.offsetParent.match(/^\\d+$/)) {\r\n            for (var i = 0; i < (options.offsetParent * 1) - 1; i++) {\r\n              parent = parent.parent();\r\n            }\r\n          } else {\r\n            parent = angular.element(options.offsetParent);\r\n          }\r\n        }\r\n\r\n        $affix.init = function () {\r\n\r\n          this.$parseOffsets();\r\n          initialOffsetTop = dimensions.offset(element[0]).top + initialAffixTop;\r\n          setWidth = options.setWidth && !element[0].style.width;\r\n\r\n          // Bind events\r\n          targetEl.on('scroll', this.checkPosition);\r\n          targetEl.on('click', this.checkPositionWithEventLoop);\r\n          windowEl.on('resize', this.$debouncedOnResize);\r\n\r\n          // Both of these checkPosition() calls are necessary for the case where\r\n          // the user hits refresh after scrolling to the bottom of the page.\r\n          this.checkPosition();\r\n          this.checkPositionWithEventLoop();\r\n\r\n        };\r\n\r\n        $affix.destroy = function () {\r\n\r\n          // Unbind events\r\n          targetEl.off('scroll', this.checkPosition);\r\n          targetEl.off('click', this.checkPositionWithEventLoop);\r\n          windowEl.off('resize', this.$debouncedOnResize);\r\n\r\n        };\r\n\r\n        $affix.checkPositionWithEventLoop = function () {\r\n\r\n          // IE 9 throws an error if we use 'this' instead of '$affix'\r\n          // in this setTimeout call\r\n          setTimeout($affix.checkPosition, 1);\r\n\r\n        };\r\n\r\n        $affix.checkPosition = function () {\r\n          // if (!this.$element.is(':visible')) return\r\n\r\n          var scrollTop = getScrollTop();\r\n          var position = dimensions.offset(element[0]);\r\n          var elementHeight = dimensions.height(element[0]);\r\n\r\n          // Get required affix class according to position\r\n          var affix = getRequiredAffixClass(unpin, position, elementHeight);\r\n\r\n          // Did affix status changed this last check?\r\n          if (affixed === affix) return;\r\n          affixed = affix;\r\n\r\n          if (affix === 'top') {\r\n            unpin = null;\r\n            if (setWidth) {\r\n              element.css('width', '');\r\n            }\r\n            if (options.inlineStyles) {\r\n              element.css('position', (options.offsetParent) ? '' : 'relative');\r\n              element.css('top', '');\r\n            }\r\n          } else if (affix === 'bottom') {\r\n            if (options.offsetUnpin) {\r\n              unpin = -(options.offsetUnpin * 1);\r\n            } else {\r\n              // Calculate unpin threshold when affixed to bottom.\r\n              // Hopefully the browser scrolls pixel by pixel.\r\n              unpin = position.top - scrollTop;\r\n            }\r\n            if (setWidth) {\r\n              element.css('width', '');\r\n            }\r\n            if (options.inlineStyles) {\r\n              element.css('position', (options.offsetParent) ? '' : 'relative');\r\n              element.css('top', (options.offsetParent) ? '' : ((bodyEl[0].offsetHeight - offsetBottom - elementHeight - initialOffsetTop) + 'px'));\r\n            }\r\n          } else { // affix === 'middle'\r\n            unpin = null;\r\n            if (setWidth) {\r\n              element.css('width', element[0].offsetWidth + 'px');\r\n            }\r\n            if (options.inlineStyles) {\r\n              element.css('position', 'fixed');\r\n              element.css('top', initialAffixTop + 'px');\r\n            }\r\n          }\r\n\r\n          // Add proper affix class\r\n          element.removeClass(reset).addClass('affix' + ((affix !== 'middle') ? '-' + affix : ''));\r\n\r\n        };\r\n\r\n        $affix.$onResize = function () {\r\n          $affix.$parseOffsets();\r\n          $affix.checkPosition();\r\n        };\r\n        $affix.$debouncedOnResize = debounce($affix.$onResize, 50);\r\n\r\n        $affix.$parseOffsets = function () {\r\n          var initialPosition = element[0].style.position;\r\n          var initialTop = element[0].style.top;\r\n          // Reset position to calculate correct offsetTop\r\n          if (options.inlineStyles) {\r\n            element.css('position', (options.offsetParent) ? '' : 'relative');\r\n            element.css('top', '');\r\n          }\r\n\r\n          if (options.offsetTop) {\r\n            if (options.offsetTop === 'auto') {\r\n              options.offsetTop = '+0';\r\n            }\r\n            if (options.offsetTop.match(/^[-+]\\d+$/)) {\r\n              initialAffixTop = - options.offsetTop * 1;\r\n              if (options.offsetParent) {\r\n                offsetTop = dimensions.offset(parent[0]).top + (options.offsetTop * 1);\r\n              } else {\r\n                offsetTop = dimensions.offset(element[0]).top - dimensions.css(element[0], 'marginTop', true) + (options.offsetTop * 1);\r\n              }\r\n            } else {\r\n              offsetTop = options.offsetTop * 1;\r\n            }\r\n          }\r\n\r\n          if (options.offsetBottom) {\r\n            if (options.offsetParent && options.offsetBottom.match(/^[-+]\\d+$/)) {\r\n              // add 1 pixel due to rounding problems...\r\n              offsetBottom = getScrollHeight() - (dimensions.offset(parent[0]).top + dimensions.height(parent[0])) + (options.offsetBottom * 1) + 1;\r\n            } else {\r\n              offsetBottom = options.offsetBottom * 1;\r\n            }\r\n          }\r\n\r\n          // Bring back the element's position after calculations\r\n          if (options.inlineStyles) {\r\n            element.css('position', initialPosition);\r\n            element.css('top', initialTop);\r\n          }\r\n        };\r\n\r\n        // Private methods\r\n\r\n        function getRequiredAffixClass (_unpin, position, elementHeight) {\r\n          var scrollTop = getScrollTop();\r\n          var scrollHeight = getScrollHeight();\r\n\r\n          if (scrollTop <= offsetTop) {\r\n            return 'top';\r\n          } else if (_unpin !== null) {\r\n            return scrollTop + _unpin <= position.top ? 'middle' : 'bottom';\r\n          } else if (offsetBottom !== null && (position.top + elementHeight + initialAffixTop >= scrollHeight - offsetBottom)) {\r\n            return 'bottom';\r\n          }\r\n          return 'middle';\r\n        }\r\n\r\n        function getScrollTop () {\r\n          return targetEl[0] === $window ? $window.pageYOffset : targetEl[0].scrollTop;\r\n        }\r\n\r\n        function getScrollHeight () {\r\n          return targetEl[0] === $window ? $window.document.body.scrollHeight : targetEl[0].scrollHeight;\r\n        }\r\n\r\n        $affix.init();\r\n        return $affix;\r\n\r\n      }\r\n\r\n      return AffixFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsAffix', function ($affix, $window, $timeout) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      require: '^?bsAffixTarget',\r\n      link: function postLink (scope, element, attr, affixTarget) {\r\n\r\n        var options = {scope: scope, target: affixTarget ? affixTarget.$element : angular.element($window)};\r\n        angular.forEach(['offsetTop', 'offsetBottom', 'offsetParent', 'offsetUnpin', 'inlineStyles', 'setWidth'], function (key) {\r\n          if (angular.isDefined(attr[key])) {\r\n            var option = attr[key];\r\n            if (/true/i.test(option)) option = true;\r\n            if (/false/i.test(option)) option = false;\r\n            options[key] = option;\r\n          }\r\n        });\r\n\r\n        var affix;\r\n        $timeout(function () { affix = $affix(element, options); });\r\n        scope.$on('$destroy', function () {\r\n          if (affix) affix.destroy();\r\n          options = null;\r\n          affix = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsAffixTarget', function () {\r\n    return {\r\n      controller: function ($element) {\r\n        this.$element = $element;\r\n      }\r\n    };\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap', [\r\n  'mgcrea.ngStrap.modal',\r\n  'mgcrea.ngStrap.aside',\r\n  'mgcrea.ngStrap.alert',\r\n  'mgcrea.ngStrap.button',\r\n  'mgcrea.ngStrap.select',\r\n  'mgcrea.ngStrap.datepicker',\r\n  'mgcrea.ngStrap.timepicker',\r\n  'mgcrea.ngStrap.navbar',\r\n  'mgcrea.ngStrap.tooltip',\r\n  'mgcrea.ngStrap.popover',\r\n  'mgcrea.ngStrap.dropdown',\r\n  'mgcrea.ngStrap.typeahead',\r\n  'mgcrea.ngStrap.scrollspy',\r\n  'mgcrea.ngStrap.affix',\r\n  'mgcrea.ngStrap.tab',\r\n  'mgcrea.ngStrap.collapse'\r\n]);\r\n"],"sourceRoot":"/source/"}