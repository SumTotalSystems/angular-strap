{"version":3,"sources":["angular-strap.js","helpers/raf.js","helpers/compiler.js","typeahead/typeahead.js","helpers/parse-options.js","helpers/focus-out.js","helpers/focus-element.js","helpers/dimensions.js","helpers/debounce.js","helpers/date-parser.js","helpers/date-formatter.js","tooltip/tooltip.js","tab/tab.js","timepicker/timepicker.js","select/select.js","scrollspy/scrollspy.js","popover/popover.js","navbar/navbar.js","modal/modal.js","dropdown/dropdown.js","datepicker/datepicker.js","collapse/collapse.js","button/button.js","aside/aside.js","alert/alert.js","affix/affix.js","module.js"],"names":["rafSupported","requestAnimationFrame","templateUrl","options","cache","$templateCache","then","element","res","fetchTemplate","template","fetchPromises","module","$http","get","defaults","animation","prefixClass","data","this","compile","controller","console","controllerAs","resolve","locals","bindToController","angular","forEach","value","isString","$injector","key","transformTemplate","identity","extend","$template","when","$q","all","templateEl","Error","findElement","contentTemplate","templates","contentEl","removeAttr","html","replace","next","remove","outerHTML","link","scope","trim","contents","linkFn","invokeCtrl","children","instance","ctrl","isObject","arguments","apply","bsCompilerService","fn","version","minor","dot","cancelAnimationFrame","id","$window","webkitRequestAnimationFrame","mozRequestAnimationFrame","$timeout","raf","timer","cancel","supported","$get","config","$parseOptions","$values","regexp","match","valueName","keyName","values","map","index","label","displayFn","valueFn","ParseOptionsFactory","groupByFn","valuesFn","restrict","$parse","$match","attr","isArray","displayValue","init","callback","directive","$rootScope","$event","$element","ngFocusOut","$$phase","event","$on","off","$apply","on","ngEventHandler","attrs","$watch","focusElement","focus","factory","offsetParent","docElement","ownerDocument","height","outer","offsetHeight","nodeName","css","documentElement","window","getComputedStyle","name","prop","extra","currentStyle","boxRect","getBoundingClientRect","style","offset","left","width","curPosition","curLeft","top","curCSSTop","curTop","setOffset","calculatePosition","position","curElem","props","curCSSLeft","curOffset","parseFloat","indexOf","isFunction","call","i","using","offsetParentRect","offsetParentEl","offsetParentElement","offsetWidth","func","immediate","timeout","args","context","callNow","leading","wait","trailing","year","seconds","provider","$localeProvider","milliseconds","ParseDate","prototype","hours","noop","array","toLowerCase","isNaN","indexOfCaseInsensitive","len","length","str","toString","format","strict","DateParserFactory","minutes","day","month","getFullYear","getHours","getMilliseconds","getMonth","Date","getMinutes","proto","isNumeric","toDate","$dateParser","regExpMap","sss","$locale","dateFilter","mm","literalRegex","formatParts","escapedLiteralFormat","dateElements","keys","escapedFormat","isFormatStringLiteral","part","trimLiteralEscapeChars","split","dateRegexParts","escapeReservedSymbols","text","join","re","abstractRegex","buildDateParseRegex","setMapForFormat","buildDateAbstractRegex","buildDateParseValuesMap","Object","valuesMatch","keyIndex","valueKey","valuesFunctionMap","valueFunction","valuesRegex","exec","setFnMap","setMap","m","HH","H","hh","h","a","EEEE","EEE","DATETIME_FORMATS","SHORTDAY","dd","d","MMMM","MMM","SHORTMONTH","MM","M","DAY","yyyy","yy","y","MONTH","ss","setSeconds","s","setMinutes","setHours","setDate","setMonth","setFullYear","regex","$format","regExpForFormat","test","baseDate","formatRegex","formatSetMap","matches","date","getTime","timezone","newDate","parseInt","fromDate","getDate","today","getDateForAttribute","substr","getTimeForAttribute","time","daylightSavingAdjust","Infinity","parse","timezoneOffsetAdjust","undo","getTimezoneOffset","getDefaultLocale","getDatetimeFormat","weekdaysShort","lang","splitTimeFormat","timeFormat","slice","weekdays","hoursFormat","minutesFormat","secondsFormat","timeSeparator","showSeconds","formatDate","service","trigger","container","keyboard","delay","minLength","filter","limit","autoSelect","comparator","trimValue","$typeahead","parentScope","$resetMatches","$tooltip","$$rAF","$matches","$$postDigest","$scope","activate","$activeIndex","select","$select","evt","$isVisible","safeDigest","update","$render","$emit","prefixEvent","isDefined","onSelect","$setViewValue","equals","$onMouseDown","preventDefault","stopPropagation","clientTop","active","offsetTop","clientBottom","highWatermark","scrollTop","Math","lowWatermark","clientHeight","keyCode","$$updateScrollTop","$digest","show","isUndefined","hide","$onKeyDown","$root","TypeaheadFactory","$filter","expression","results","postLink","require","falseValueRegExp","bsKey","charAt","toUpperCase","bsOptions","parsedOptions","typeahead","watchedOptions","$watchCollection","watchOptions","ngModel","newValue","oldValue","$modelValue","selectMode","$viewValue","substring","$formatters","push","modelValue","selected","selectionStart","val","selectionEnd","setSelectionRange","sd","destroy","target","placement","titleTemplate","title","type","autoClose","bsEnabled","mouseDownPreventDefault","mouseDownStopPropagation","viewport","selector","padding","TooltipFactory","promise","$bsCompiler","clearTimeout","hoverState","onShow","leaveAnimateCallback","destroyTipElement","onHide","_tipToHide","triggers","isTouch","toggle","enter","unbindTriggerEvents","$onFocusElementMouseDown","bindKeyboardEvents","tipElement","$onKeyUp","unbindKeyboardEvents","_autoCloseEventsBinded","bindAutoCloseEvents","$body","unbindAutoCloseEvents","stopEventPropagation","getPosition","elRect","rect","p","dimensions","el","scroll","outerDims","isBody","document","body","clientWidth","innerHeight","actualWidth","actualHeight","marginLeft","right","marginTop","tip","getViewportAdjustedDelta","delta","isVertical","arrowDelta","replaceArrow","arrowOffsetPosition","viewportDimensions","$viewport","topEdgeOffset","bottomEdgeOffset","viewportPadding","leftEdgeOffset","rightEdgeOffset","dimension","isHorizontal","$arrow","$isShown","tipScope","$destroy","$options","$promise","$new","$id","$sce","trustAsHtml","$setEnabled","$hide","setEnabled","isEnabled","compileData","tipContainer","bindTriggerEvents","isElement","onBeforeShow","after","parent","lastChild","display","visibility","clonedElement","addClass","prepend","$applyPlacement","$animate","enterAnimateCallback","_blur","onBeforeHide","blur","leave","autoPlace","autoToken","elementPosition","tipWidth","tipHeight","viewportPosition","originalPlacement","removeClass","tipPosition","getCalculatedOffset","applyPlacement","query","querySelectorAll","isNative","tooltip","transclusion","$eval","dataTarget","hasOwnProperty","$observe","bsTooltip","bsShow","setViewport","_tabsHash","_addTabControl","navClass","activeClass","$attrs","control","$activeClass","self","newIndex","disabled","navigatePane","toLeft","$panes","$setActive","focusCurrentTab","activeAs","$activePaneChangeListeners","$viewChangeListeners","$push","pane","$onClick","copy","tabPane","$labeledBy","$active","activeIndex","undefined","$remove","splice","$pane","$onKeyPress","e","charCode","$index","$tab","transclude","ngModelCtrl","bsTabsCtrl","tabKey","addTabControl","controllers","liElements","find","iElement","bsActivePane","parsedBsActivePane","assign","render","$isActive","$describedBy","defaultDate","useNative","timeType","modelTimeFormat","autoclose","minTime","maxTime","hourStep","minuteStep","secondStep","roundDisplay","iconUp","iconDown","arrowBehavior","$timepicker","timepickerFactory","viewDate","hour","startDate","meridian","coeff","selRange","end","start","collapse","moveStart","moveEnd","_init","floorMinutes","floor","selectedIndex","second","getSeconds","millisecond","$dateValue","$dateFormatter","minute","$iconUp","$moveIndex","$switchMeridian","switchMeridian","isDate","$build","$isBuilt","keep","midIndex","$date","rows","$isDisabled","showAM","$isSelected","isAM","selectedTime","$arrowAction","$setTimeByStep","targetDate","targetEl","triggerHandler","hoursLength","minutesLength","sepLength","lateralMove","count","selectRange","incr","isSeconds","isMeridian","secondsLength","createSelection","createTextRange","_destroy","_show","_hide","navigator","userAgent","isMaxValid","isValid","parsedTime","isMinValid","$setValidity","$parsers","unshift","viewValue","getTimeFormattedString","timepicker","dateParser","validateAgainstMinMaxTime","NaN","multiple","allNoneButtons","sort","caretHtml","placeholder","allText","noneText","maxLength","maxLengthHtml","iconCheckmark","SelectFactory","$isMultiple","$showAllNoneButtons","$iconCheckmark","$allText","$activate","$selectNone","$updateActiveIndex","b","$getIndex","anchor","anchorCandidate","$selectScrollFix","$isIE","stopImmediatePropagation","ua","activeElement","tagName","dataMultiple","inputEl","addEventListener","$isEmpty","spies","$document","windowEl","debounce","bodyEl","throttle","ScrollSpyFactory","scrollEl","isWindowSpy","scrollId","$$count","$scrollspy","unbindViewContentLoaded","unbindIncludeContentLoaded","trackedElements","sortedElements","activeTarget","debouncedCheckOffsets","viewportHeight","debouncedCheckPosition","throttledCheckPosition","checkPositionWithEventLoop","checkOffsets","checkPosition","docEl","$activateElement","setTimeout","source","$getTrackedElement","targetElement","querySelector","trackedElement","trackElement","toDelete","untrackElement","scrollspy","childEl","child","content","$popover","PopoverFactory","bsPopover","popover","routeAttr","$navbar","li","liElement","pattern","path","RegExp","backdrop","size","zIndex","containerElement","bodyElement","defaultContainerElement","layoutHideElement","dialogBaseZindex","ModalFactory","focusableElement","$modal","modalElement","findFocusableElements","focusableElements","focusable","findNextFocusableElement","inReverse","reverse","unbindBackdropEvents","hideOnBackdropClick","backdropElement","preventEventDefault","modalScope","backdropBaseZindex","returnFocus","$show","bottom","destroyModalElement","z-index","backdropCount","defaultPrevented","customClass","validSizes","backdropAnimation","bindBackdropEvents","which","nextFocusable","shiftKey","lg","sm","modalClass","bsModal","modal","matchesSelector","DropdownFactory","$dropdown","onBodyClick","items","inMenu","relatedTarget","$onFocusOut","parentEl","hasClass","webkitMatchesSelector","Element","mozMatchesSelector","msMatchesSelector","oMatchesSelector","tAttrs","nextSibling","nodeType","parentNode","removeChild","dropdown","dateType","dateFormat","modelDateFormat","dayFormat","monthFormat","yearFormat","monthTitleFormat","yearTitleFormat","strictFormat","minDate","maxDate","startView","minView","startWeek","daysOfWeekDisabled","hasToday","hasClear","iconLeft","iconRight","screenReaderDateFormat","focusOnOpen","DatepickerFactory","$datepicker","pickerViews","datepickerViews","altKey","setMode","$mode","focused","$views","views","$iconLeft","$iconRight","$hasToday","dropdownId","$nextLabel","labelNext","$previousLabel","$picker","handleOnKeyDown","$toggleMode","$setToday","$clear","$focused","selectedDayId","dayInfo","isNext","continueHandling","onKeyDown","inTable","updateDisabledDates","disabledDateRanges","dateRanges","$setDisabledEl","mode","pristine","built","$updateSelected","updateSelected","build","isSelected","steps","getUTCFullYear","getUTCMonth","$selectPane","UTC","getUTCDate","previousValue","normalizeDateRanges","ranges","disabledRanges","datepicker","parsedDate","getDateFormattedString","validateAgainstMinMaxDate","disabledDates","arrays","mod","n","arr","weekDaysMin","weekDaysShortLabels","weekDaysLongLabels","weekDaysLabelsHtml","weekDayLabel","concat","picker","firstDayOfMonth","firstDayOfMonthOffset","firstDate","firstDateOffset","days","selectedDay","todayDay","dayItem","isToday","screenReaderLabel","muted","defaultFirstDayTabIndex","showLabels","labels","isTodayDisabled","hasSelectedDate","$modeLabel","isDisabled","getDay","actualTime","months","selectedMonth","monthItem","thisMonthDate","thisMonth","lastDate","actualMonth","firstYear","years","selectedYear","yearItem","thisYear","actualYear","setYear","Array","startCollapsed","allowMultiple","activeIndexes","$targets","deactivateItem","activateItem","$toggles","$collapse","$registerToggle","$registerTarget","$unregisterToggle","fixActiveItemIndexes","disallowToggle","isActive","$activeIndexes","bsCollapseCtrl","actionEventHandler","bsCollapseToggle","bind","action","$unregisterTarget","toggleEvent","$button","constantValueRegExp","isInput","trueValue","falseValue","hasExoticValues","checked","toggleClass","v","AsideFactory","$aside","bsAside","aside","duration","dismissable","AlertFactory","$alert","bsAlert","alert","AffixFactory","inlineStyles","$affix","setWidth","reset","initialOffsetTop","getRequiredAffixClass","_unpin","getScrollTop","scrollHeight","getScrollHeight","pageYOffset","offsetBottom","elementHeight","initialAffixTop","affixed","unpin","$parseOffsets","affix","offsetUnpin","$onResize","initialTop","$debouncedOnResize","initialPosition","affixTarget","option"],"mappings":"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","file":"angular-strap.min.js","sourcesContent":["(function(window, document, undefined) {\r\n'use strict';\r\n\r\n// Source: helpers\\raf.js\r\nif (angular.version.minor < 3 && angular.version.dot < 14) {\r\n  angular.module('ng')\r\n\r\n  .factory('$$rAF', function ($window, $timeout) {\r\n\r\n    var requestAnimationFrame = $window.requestAnimationFrame ||\r\n                                $window.webkitRequestAnimationFrame ||\r\n                                $window.mozRequestAnimationFrame;\r\n\r\n    var cancelAnimationFrame = $window.cancelAnimationFrame ||\r\n                               $window.webkitCancelAnimationFrame ||\r\n                               $window.mozCancelAnimationFrame ||\r\n                               $window.webkitCancelRequestAnimationFrame;\r\n\r\n    var rafSupported = !!requestAnimationFrame;\r\n    var raf = rafSupported ?\r\n      function (fn) {\r\n        var id = requestAnimationFrame(fn);\r\n        return function () {\r\n          cancelAnimationFrame(id);\r\n        };\r\n      } :\r\n      function (fn) {\r\n        var timer = $timeout(fn, 16.66, false); // 1000 / 60 = 16.666\r\n        return function () {\r\n          $timeout.cancel(timer);\r\n        };\r\n      };\r\n\r\n    raf.supported = rafSupported;\r\n\r\n    return raf;\r\n\r\n  });\r\n}\r\n\r\n// Source: helpers\\parse-options.js\r\nangular.module('mgcrea.ngStrap.helpers.parseOptions', [])\r\n\r\n  .provider('$parseOptions', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      regexp: /^\\s*(.*?)(?:\\s+as\\s+(.*?))?(?:\\s+group\\s+by\\s+(.*))?\\s+for\\s+(?:([\\$\\w][\\$\\w]*)|(?:\\(\\s*([\\$\\w][\\$\\w]*)\\s*,\\s*([\\$\\w][\\$\\w]*)\\s*\\)))\\s+in\\s+(.*?)(?:\\s+track\\s+by\\s+(.*?))?$/\r\n    };\r\n\r\n    this.$get = function ($parse, $q) {\r\n\r\n      function ParseOptionsFactory (attr, config) {\r\n\r\n        var $parseOptions = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n        $parseOptions.$values = [];\r\n\r\n        // Private vars\r\n        var match;\r\n        var displayFn;\r\n        var valueName;\r\n        /* eslint-disable no-unused-vars */\r\n        var keyName;\r\n        var groupByFn;\r\n        /* eslint-enable no-unused-vars */\r\n        var valueFn;\r\n        var valuesFn;\r\n\r\n        $parseOptions.init = function () {\r\n          $parseOptions.$match = match = attr.match(options.regexp);\r\n          displayFn = $parse(match[2] || match[1]);\r\n          valueName = match[4] || match[6];\r\n          keyName = match[5];\r\n          groupByFn = $parse(match[3] || '');\r\n          valueFn = $parse(match[2] ? match[1] : valueName);\r\n          valuesFn = $parse(match[7]);\r\n        };\r\n\r\n        $parseOptions.valuesFn = function (scope, controller) {\r\n          return $q.when(valuesFn(scope, controller))\r\n          .then(function (values) {\r\n            if (!angular.isArray(values)) {\r\n              values = [];\r\n            }\r\n            $parseOptions.$values = values.length ? parseValues(values, scope) : [];\r\n            return $parseOptions.$values;\r\n          });\r\n        };\r\n\r\n        $parseOptions.displayValue = function (modelValue) {\r\n          var scope = {};\r\n          scope[valueName] = modelValue;\r\n          return displayFn(scope);\r\n        };\r\n\r\n        // Private functions\r\n\r\n        function parseValues (values, scope) {\r\n          return values.map(function (match, index) {\r\n            var locals = {};\r\n            var label;\r\n            var value;\r\n            locals[valueName] = match;\r\n            label = displayFn(scope, locals);\r\n            value = valueFn(scope, locals);\r\n            return {label: label, value: value, index: index};\r\n          });\r\n        }\r\n\r\n        $parseOptions.init();\r\n        return $parseOptions;\r\n\r\n      }\r\n\r\n      return ParseOptionsFactory;\r\n\r\n    };\r\n\r\n  });\r\n\r\n// Source: helpers\\focus-out.js\r\nangular.module('mgcrea.ngStrap.helpers.ngFocusOut', [])\r\n  .directive('ngFocusOut', ['$parse', '$rootScope', function ($parse, $rootScope) {\r\n    return {\r\n      restrict: 'A',\r\n      compile: function ($element, attr) {\r\n        // NOTE:\r\n        // We expose the powerful `$event` object on the scope that provides access to the Window,\r\n        // etc. This is OK, because expressions are not sandboxed any more (and the expression\r\n        // sandbox was never meant to be a security feature anyway).\r\n        var fn = $parse(attr.ngFocusOut);\r\n\r\n        return function link (scope, element) {\r\n          function ngEventHandler (event) {\r\n            var callback = function () {\r\n              fn(scope, {\r\n                $event: event\r\n              });\r\n            };\r\n            if ($rootScope.$$phase) {\r\n              scope.$evalAsync(callback);\r\n            } else {\r\n              scope.$apply(callback);\r\n            }\r\n          }\r\n\r\n          // setup the handler\r\n          element.on('focusout', ngEventHandler);\r\n\r\n          scope.$on('$destroy', function () {\r\n            // tear down the handler\r\n            element.off('focusout', ngEventHandler);\r\n          });\r\n        };\r\n      }\r\n    };\r\n  }]);\r\n\r\n// Source: helpers\\focus-element.js\r\nangular.module('mgcrea.ngStrap.helpers.focusElement', [])\r\n  .directive('focusElement', ['$timeout', '$parse', function ($timeout, $parse) {\r\n    return {\r\n      link: function (scope, element, attrs) {\r\n        scope.$watch(attrs.focusElement, function (value) {\r\n          if (value === true) {\r\n            $timeout(function () {\r\n              element[0].focus();\r\n            });\r\n          }\r\n        });\r\n      }\r\n    };\r\n  }]);\r\n\r\n// Source: helpers\\dimensions.js\r\nangular.module('mgcrea.ngStrap.helpers.dimensions', [])\r\n\r\n  .factory('dimensions', function () {\r\n\r\n    var fn = {};\r\n\r\n    /**\r\n     * Test the element nodeName\r\n     * @param element\r\n     * @param name\r\n     */\r\n    var nodeName = fn.nodeName = function (element, name) {\r\n      return element.nodeName && element.nodeName.toLowerCase() === name.toLowerCase();\r\n    };\r\n\r\n    /**\r\n     * Returns the element computed style\r\n     * @param element\r\n     * @param prop\r\n     * @param extra\r\n     */\r\n    fn.css = function (element, prop, extra) {\r\n      var value;\r\n      if (element.currentStyle) { // IE\r\n        value = element.currentStyle[prop];\r\n      } else if (window.getComputedStyle) {\r\n        value = window.getComputedStyle(element)[prop];\r\n      } else {\r\n        value = element.style[prop];\r\n      }\r\n      return extra === true ? parseFloat(value) || 0 : value;\r\n    };\r\n\r\n    /**\r\n     * Provides read-only equivalent of jQuery's offset function:\r\n     * @required-by bootstrap-tooltip, bootstrap-affix\r\n     * @url http://api.jquery.com/offset/\r\n     * @param element\r\n     */\r\n    fn.offset = function (element) {\r\n      var boxRect = element.getBoundingClientRect();\r\n      var docElement = element.ownerDocument;\r\n      return {\r\n        width: boxRect.width || element.offsetWidth,\r\n        height: boxRect.height || element.offsetHeight,\r\n        top: boxRect.top + (window.pageYOffset || docElement.documentElement.scrollTop) - (docElement.documentElement.clientTop || 0),\r\n        left: boxRect.left + (window.pageXOffset || docElement.documentElement.scrollLeft) - (docElement.documentElement.clientLeft || 0)\r\n      };\r\n    };\r\n\r\n    /**\r\n     * Provides set equivalent of jQuery's offset function:\r\n     * @required-by bootstrap-tooltip\r\n     * @url http://api.jquery.com/offset/\r\n     * @param element\r\n     * @param options\r\n     * @param i\r\n     */\r\n    fn.setOffset = function (element, options, i) {\r\n      var curPosition;\r\n      var curLeft;\r\n      var curCSSTop;\r\n      var curTop;\r\n      var curOffset;\r\n      var curCSSLeft;\r\n      var calculatePosition;\r\n      var position = fn.css(element, 'position');\r\n      var curElem = angular.element(element);\r\n      var props = {};\r\n\r\n      // Set position first, in-case top/left are set even on static elem\r\n      if (position === 'static') {\r\n        element.style.position = 'relative';\r\n      }\r\n\r\n      curOffset = fn.offset(element);\r\n      curCSSTop = fn.css(element, 'top');\r\n      curCSSLeft = fn.css(element, 'left');\r\n      calculatePosition = (position === 'absolute' || position === 'fixed') &&\r\n                          (curCSSTop + curCSSLeft).indexOf('auto') > -1;\r\n\r\n      // Need to be able to calculate position if either\r\n      // top or left is auto and position is either absolute or fixed\r\n      if (calculatePosition) {\r\n        curPosition = fn.position(element);\r\n        curTop = curPosition.top;\r\n        curLeft = curPosition.left;\r\n      } else {\r\n        curTop = parseFloat(curCSSTop) || 0;\r\n        curLeft = parseFloat(curCSSLeft) || 0;\r\n      }\r\n\r\n      if (angular.isFunction(options)) {\r\n        options = options.call(element, i, curOffset);\r\n      }\r\n\r\n      if (options.top !== null) {\r\n        props.top = (options.top - curOffset.top) + curTop;\r\n      }\r\n      if (options.left !== null) {\r\n        props.left = (options.left - curOffset.left) + curLeft;\r\n      }\r\n\r\n      if ('using' in options) {\r\n        options.using.call(curElem, props);\r\n      } else {\r\n        curElem.css({\r\n          top: props.top + 'px',\r\n          left: props.left + 'px'\r\n        });\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Provides read-only equivalent of jQuery's position function\r\n     * @required-by bootstrap-tooltip, bootstrap-affix\r\n     * @url http://api.jquery.com/offset/\r\n     * @param element\r\n     */\r\n    fn.position = function (element) {\r\n\r\n      var offsetParentRect = {top: 0, left: 0};\r\n      var offsetParentEl;\r\n      var offset;\r\n\r\n      // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\r\n      if (fn.css(element, 'position') === 'fixed') {\r\n\r\n        // We assume that getBoundingClientRect is available when computed position is fixed\r\n        offset = element.getBoundingClientRect();\r\n\r\n      } else {\r\n\r\n        // Get *real* offsetParentEl\r\n        offsetParentEl = offsetParentElement(element);\r\n\r\n        // Get correct offsets\r\n        offset = fn.offset(element);\r\n        if (!nodeName(offsetParentEl, 'html')) {\r\n          offsetParentRect = fn.offset(offsetParentEl);\r\n        }\r\n\r\n        // Add offsetParent borders\r\n        offsetParentRect.top += fn.css(offsetParentEl, 'borderTopWidth', true);\r\n        offsetParentRect.left += fn.css(offsetParentEl, 'borderLeftWidth', true);\r\n      }\r\n\r\n      // Subtract parent offsets and element margins\r\n      return {\r\n        width: element.offsetWidth,\r\n        height: element.offsetHeight,\r\n        top: offset.top - offsetParentRect.top - fn.css(element, 'marginTop', true),\r\n        left: offset.left - offsetParentRect.left - fn.css(element, 'marginLeft', true)\r\n      };\r\n\r\n    };\r\n\r\n    /**\r\n     * Returns the closest, non-statically positioned offsetParent of a given element\r\n     * @required-by fn.position\r\n     * @param element\r\n     */\r\n    function offsetParentElement (element) {\r\n      var docElement = element.ownerDocument;\r\n      var offsetParent = element.offsetParent || docElement;\r\n      if (nodeName(offsetParent, '#document')) return docElement.documentElement;\r\n      while (offsetParent && !nodeName(offsetParent, 'html') && fn.css(offsetParent, 'position') === 'static') {\r\n        offsetParent = offsetParent.offsetParent;\r\n      }\r\n      return offsetParent || docElement.documentElement;\r\n    }\r\n\r\n    /**\r\n     * Provides equivalent of jQuery's height function\r\n     * @required-by bootstrap-affix\r\n     * @url http://api.jquery.com/height/\r\n     * @param element\r\n     * @param outer\r\n     */\r\n    fn.height = function (element, outer) {\r\n      var value = element.offsetHeight;\r\n      if (outer) {\r\n        value += fn.css(element, 'marginTop', true) + fn.css(element, 'marginBottom', true);\r\n      } else {\r\n        value -= fn.css(element, 'paddingTop', true) + fn.css(element, 'paddingBottom', true) + fn.css(element, 'borderTopWidth', true) + fn.css(element, 'borderBottomWidth', true);\r\n      }\r\n      return value;\r\n    };\r\n\r\n    /**\r\n     * Provides equivalent of jQuery's width function\r\n     * @required-by bootstrap-affix\r\n     * @url http://api.jquery.com/width/\r\n     * @param element\r\n     * @param outer\r\n     */\r\n    fn.width = function (element, outer) {\r\n      var value = element.offsetWidth;\r\n      if (outer) {\r\n        value += fn.css(element, 'marginLeft', true) + fn.css(element, 'marginRight', true);\r\n      } else {\r\n        value -= fn.css(element, 'paddingLeft', true) + fn.css(element, 'paddingRight', true) + fn.css(element, 'borderLeftWidth', true) + fn.css(element, 'borderRightWidth', true);\r\n      }\r\n      return value;\r\n    };\r\n\r\n    return fn;\r\n\r\n  });\r\n\r\n// Source: helpers\\debounce.js\r\nangular.module('mgcrea.ngStrap.helpers.debounce', [])\r\n\r\n// @source jashkenas/underscore\r\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L693\r\n.factory('debounce', function ($timeout) {\r\n  return function (func, wait, immediate) {\r\n    var timeout = null;\r\n    return function () {\r\n      var context = this;\r\n      var args = arguments;\r\n      var callNow = immediate && !timeout;\r\n      if (timeout) {\r\n        $timeout.cancel(timeout);\r\n      }\r\n      timeout = $timeout(function later () {\r\n        timeout = null;\r\n        if (!immediate) {\r\n          func.apply(context, args);\r\n        }\r\n      }, wait, false);\r\n      if (callNow) {\r\n        func.apply(context, args);\r\n      }\r\n      return timeout;\r\n    };\r\n  };\r\n})\r\n\r\n\r\n// @source jashkenas/underscore\r\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L661\r\n.factory('throttle', function ($timeout) {\r\n  return function (func, wait, options) {\r\n    var timeout = null;\r\n    if (!options) options = {};\r\n    return function () {\r\n      var context = this;\r\n      var args = arguments;\r\n      if (!timeout) {\r\n        if (options.leading !== false) {\r\n          func.apply(context, args);\r\n        }\r\n        timeout = $timeout(function later () {\r\n          timeout = null;\r\n          if (options.trailing !== false) {\r\n            func.apply(context, args);\r\n          }\r\n        }, wait, false);\r\n      }\r\n    };\r\n  };\r\n});\r\n\r\n// Source: helpers\\date-parser.js\r\nangular.module('mgcrea.ngStrap.helpers.dateParser', [])\r\n\r\n.provider('$dateParser', function ($localeProvider) {\r\n\r\n  // define a custom ParseDate object to use instead of native Date\r\n  // to avoid date values wrapping when setting date component values\r\n  function ParseDate () {\r\n    this.year = 1970;\r\n    this.month = 0;\r\n    this.day = 1;\r\n    this.hours = 0;\r\n    this.minutes = 0;\r\n    this.seconds = 0;\r\n    this.milliseconds = 0;\r\n  }\r\n\r\n  ParseDate.prototype.setMilliseconds = function (value) { this.milliseconds = value; };\r\n  ParseDate.prototype.setSeconds = function (value) { this.seconds = value; };\r\n  ParseDate.prototype.setMinutes = function (value) { this.minutes = value; };\r\n  ParseDate.prototype.setHours = function (value) { this.hours = value; };\r\n  ParseDate.prototype.getHours = function () { return this.hours; };\r\n  ParseDate.prototype.setDate = function (value) { this.day = value; };\r\n  ParseDate.prototype.setMonth = function (value) { this.month = value; };\r\n  ParseDate.prototype.setFullYear = function (value) { this.year = value; };\r\n  ParseDate.prototype.fromDate = function (value) {\r\n    this.year = value.getFullYear();\r\n    this.month = value.getMonth();\r\n    this.day = value.getDate();\r\n    this.hours = value.getHours();\r\n    this.minutes = value.getMinutes();\r\n    this.seconds = value.getSeconds();\r\n    this.milliseconds = value.getMilliseconds();\r\n    return this;\r\n  };\r\n\r\n  ParseDate.prototype.toDate = function () {\r\n    return new Date(this.year, this.month, this.day, this.hours, this.minutes, this.seconds, this.milliseconds);\r\n  };\r\n\r\n  var proto = ParseDate.prototype;\r\n\r\n  function noop () {\r\n  }\r\n\r\n  function isNumeric (n) {\r\n    return !isNaN(parseFloat(n)) && isFinite(n);\r\n  }\r\n\r\n  function indexOfCaseInsensitive (array, value) {\r\n    var len = array.length;\r\n    var str = value.toString().toLowerCase();\r\n    for (var i = 0; i < len; i++) {\r\n      if (array[i].toLowerCase() === str) { return i; }\r\n    }\r\n    return -1; // Return -1 per the \"Array.indexOf()\" method.\r\n  }\r\n\r\n  var defaults = this.defaults = {\r\n    format: 'shortDate',\r\n    strict: false\r\n  };\r\n\r\n  this.$get = function ($locale, dateFilter) {\r\n\r\n    var DateParserFactory = function (config) {\r\n\r\n      var options = angular.extend({}, defaults, config);\r\n\r\n      var $dateParser = {};\r\n\r\n      /* eslint-disable key-spacing, quote-props */\r\n      var regExpMap = {\r\n        'sss'   : '[0-9]{3}',\r\n        'ss'    : '[0-5][0-9]',\r\n        's'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\r\n        'mm'    : '[0-5][0-9]',\r\n        'm'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\r\n        'HH'    : '[01][0-9]|2[0-3]',\r\n        'H'     : options.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',\r\n        'hh'    : '[0][1-9]|[1][012]',\r\n        'h'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\r\n        'a'     : 'AM|PM',\r\n        'EEEE'  : $locale.DATETIME_FORMATS.DAY.join('|'),\r\n        'EEE'   : $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\r\n        'dd'    : '0[1-9]|[12][0-9]|3[01]',\r\n        'd'     : options.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',\r\n        'MMMM'  : $locale.DATETIME_FORMATS.MONTH.join('|'),\r\n        'MMM'   : $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\r\n        'MM'    : '0[1-9]|1[012]',\r\n        'M'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\r\n        'yyyy'  : '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',\r\n        'yy'    : '[0-9]{2}',\r\n        'y'     : options.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}'\r\n      };\r\n\r\n      var setFnMap = {\r\n        'sss'   : proto.setMilliseconds,\r\n        'ss'    : proto.setSeconds,\r\n        's'     : proto.setSeconds,\r\n        'mm'    : proto.setMinutes,\r\n        'm'     : proto.setMinutes,\r\n        'HH'    : proto.setHours,\r\n        'H'     : proto.setHours,\r\n        'hh'    : proto.setHours,\r\n        'h'     : proto.setHours,\r\n        'EEEE'  : noop,\r\n        'EEE'   : noop,\r\n        'dd'    : proto.setDate,\r\n        'd'     : proto.setDate,\r\n        'a'     : function (value) { var hours = this.getHours() % 12; return this.setHours(value.match(/pm/i) ? hours + 12 : hours); },\r\n        'MMMM'  : function (value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.MONTH, value)); },\r\n        'MMM'   : function (value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.SHORTMONTH, value)); },\r\n        'MM'    : function (value) { return this.setMonth(1 * value - 1); },\r\n        'M'     : function (value) { return this.setMonth(1 * value - 1); },\r\n        'yyyy'  : proto.setFullYear,\r\n        'yy'    : function (value) { return this.setFullYear(2000 + 1 * value); },\r\n        'y'     : function (value) { return (1 * value <= 50 && value.length === 2) ? this.setFullYear(2000 + 1 * value) : this.setFullYear(1 * value); }\r\n      };\r\n      /* eslint-enable key-spacing, quote-props */\r\n\r\n      var regex;\r\n      var setMap;\r\n\r\n      $dateParser.init = function () {\r\n        $dateParser.$format = $locale.DATETIME_FORMATS[options.format] || options.format;\r\n        regex = regExpForFormat($dateParser.$format);\r\n        setMap = setMapForFormat($dateParser.$format);\r\n      };\r\n\r\n      $dateParser.isValid = function (date) {\r\n        if (angular.isDate(date)) return !isNaN(date.getTime());\r\n        return regex.test(date);\r\n      };\r\n\r\n      $dateParser.parse = function (value, baseDate, format, timezone) {\r\n        // check for date format special names\r\n        if (format) format = $locale.DATETIME_FORMATS[format] || format;\r\n        if (angular.isDate(value)) value = dateFilter(value, format || $dateParser.$format, timezone);\r\n        var formatRegex = format ? regExpForFormat(format) : regex;\r\n        var formatSetMap = format ? setMapForFormat(format) : setMap;\r\n        var matches = formatRegex.exec(value);\r\n        if (!matches) return false;\r\n        // use custom ParseDate object to set parsed values\r\n        var date = baseDate && !isNaN(baseDate.getTime()) ? new ParseDate().fromDate(baseDate) : new ParseDate().fromDate(new Date(1970, 0, 1, 0));\r\n        for (var i = 0; i < matches.length - 1; i++) {\r\n          if (formatSetMap[i]) formatSetMap[i].call(date, matches[i + 1]);\r\n        }\r\n        // convert back to native Date object\r\n        var newDate = date.toDate();\r\n\r\n        // check new native Date object for day values overflow\r\n        if (parseInt(date.day, 10) !== newDate.getDate()) {\r\n          return false;\r\n        }\r\n\r\n        return newDate;\r\n      };\r\n\r\n      $dateParser.getDateForAttribute = function (key, value) {\r\n        var date;\r\n\r\n        if (value === 'today') {\r\n          var today = new Date();\r\n          date = new Date(today.getFullYear(), today.getMonth(), today.getDate() + (key === 'maxDate' ? 1 : 0), 0, 0, 0, (key === 'minDate' ? 0 : -1));\r\n        } else if (angular.isString(value) && value.match(/^\".+\"$/)) { // Support {{ dateObj }}\r\n          date = new Date(value.substr(1, value.length - 2));\r\n        } else if (isNumeric(value)) {\r\n          date = new Date(parseInt(value, 10));\r\n        } else if (angular.isString(value) && value.length === 0) { // Reset date\r\n          date = key === 'minDate' ? -Infinity : +Infinity;\r\n        } else {\r\n          date = new Date(value);\r\n        }\r\n\r\n        return date;\r\n      };\r\n\r\n      $dateParser.getTimeForAttribute = function (key, value) {\r\n        var time;\r\n\r\n        if (value === 'now') {\r\n          time = new Date().setFullYear(1970, 0, 1);\r\n        } else if (angular.isString(value) && value.match(/^\".+\"$/)) {\r\n          time = new Date(value.substr(1, value.length - 2)).setFullYear(1970, 0, 1);\r\n        } else if (isNumeric(value)) {\r\n          time = new Date(parseInt(value, 10)).setFullYear(1970, 0, 1);\r\n        } else if (angular.isString(value) && value.length === 0) { // Reset time\r\n          time = key === 'minTime' ? -Infinity : +Infinity;\r\n        } else {\r\n          time = $dateParser.parse(value, new Date(1970, 0, 1, 0));\r\n        }\r\n\r\n        return time;\r\n      };\r\n\r\n      /* Handle switch to/from daylight saving.\r\n      * Hours may be non-zero on daylight saving cut-over:\r\n      * > 12 when midnight changeover, but then cannot generate\r\n      * midnight datetime, so jump to 1AM, otherwise reset.\r\n      * @param  date  (Date) the date to check\r\n      * @return  (Date) the corrected date\r\n      *\r\n      * __ copied from jquery ui datepicker __\r\n      */\r\n      $dateParser.daylightSavingAdjust = function (date) {\r\n        if (!date) {\r\n          return null;\r\n        }\r\n        date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);\r\n        return date;\r\n      };\r\n\r\n      /* Correct the date for timezone offset.\r\n      * @param  date  (Date) the date to adjust\r\n      * @param  timezone  (string) the timezone to adjust for\r\n      * @param  undo  (boolean) to add or subtract timezone offset\r\n      * @return  (Date) the corrected date\r\n      */\r\n      $dateParser.timezoneOffsetAdjust = function (date, timezone, undo) {\r\n        if (!date) {\r\n          return null;\r\n        }\r\n        // Right now, only 'UTC' is supported.\r\n        if (timezone && timezone === 'UTC') {\r\n          date = new Date(date.getTime());\r\n          date.setMinutes(date.getMinutes() + (undo ? -1 : 1) * date.getTimezoneOffset());\r\n        }\r\n        return date;\r\n      };\r\n\r\n      // Private functions\r\n\r\n      function regExpForFormat (format) {\r\n        // `format` string can contain literal values.\r\n        // These need to be escaped by surrounding with\r\n        // single quotes (e.g. `\"h 'in the morning'\"`).\r\n        // In order to output a single quote, escape it - i.e.,\r\n        // two single quotes in a sequence (e.g. `\"h 'o''clock'\"`).\r\n\r\n        var re = buildDateAbstractRegex(format);\r\n        return buildDateParseRegex(re);\r\n      }\r\n\r\n      function buildDateAbstractRegex (format) {\r\n        var escapedFormat = escapeReservedSymbols(format);\r\n        var escapedLiteralFormat = escapedFormat.replace(/''/g, '\\\\\\'');\r\n        var literalRegex = /('(?:\\\\'|.)*?')/;\r\n        var formatParts = escapedLiteralFormat.split(literalRegex);\r\n        var dateElements = Object.keys(regExpMap);\r\n        var dateRegexParts = [];\r\n\r\n        angular.forEach(formatParts, function (part) {\r\n          if (isFormatStringLiteral(part)) {\r\n            part = trimLiteralEscapeChars(part);\r\n          } else {\r\n            // Abstract replaces to avoid collisions\r\n            for (var i = 0; i < dateElements.length; i++) {\r\n              part = part.split(dateElements[i]).join('${' + i + '}');\r\n            }\r\n          }\r\n          dateRegexParts.push(part);\r\n        });\r\n\r\n        return dateRegexParts.join('');\r\n      }\r\n\r\n      function escapeReservedSymbols (text) {\r\n        return text.replace(/\\\\/g, '[\\\\\\\\]')\r\n                   .replace(/-/g, '[-]')\r\n                   .replace(/\\./g, '[.]')\r\n                   .replace(/\\*/g, '[*]')\r\n                   .replace(/\\+/g, '[+]')\r\n                   .replace(/\\?/g, '[?]')\r\n                   .replace(/\\$/g, '[$]')\r\n                   .replace(/\\^/g, '[^]')\r\n                   .replace(/\\//g, '[/]')\r\n                   .replace(/\\\\s/g, '[\\\\s]');\r\n      }\r\n\r\n      function isFormatStringLiteral (text) {\r\n        return /^'.*'$/.test(text);\r\n      }\r\n\r\n      function trimLiteralEscapeChars (text) {\r\n        return text.replace(/^'(.*)'$/, '$1');\r\n      }\r\n\r\n      function buildDateParseRegex (abstractRegex) {\r\n        var dateElements = Object.keys(regExpMap);\r\n        var re = abstractRegex;\r\n\r\n        // Replace abstracted values\r\n        for (var i = 0; i < dateElements.length; i++) {\r\n          re = re.split('${' + i + '}').join('(' + regExpMap[dateElements[i]] + ')');\r\n        }\r\n\r\n        return new RegExp('^' + re + '$', ['i']);\r\n      }\r\n\r\n      function setMapForFormat (format) {\r\n        var re = buildDateAbstractRegex(format);\r\n        return buildDateParseValuesMap(re);\r\n      }\r\n\r\n      function buildDateParseValuesMap (abstractRegex) {\r\n        var dateElements = Object.keys(regExpMap);\r\n        var valuesRegex = new RegExp('\\\\${(\\\\d+)}', 'g');\r\n        var valuesMatch;\r\n        var keyIndex;\r\n        var valueKey;\r\n        var valueFunction;\r\n        var valuesFunctionMap = [];\r\n\r\n        /* eslint-disable no-cond-assign */\r\n        while ((valuesMatch = valuesRegex.exec(abstractRegex)) !== null) {\r\n          keyIndex = valuesMatch[1];\r\n          valueKey = dateElements[keyIndex];\r\n          valueFunction = setFnMap[valueKey];\r\n\r\n          valuesFunctionMap.push(valueFunction);\r\n        }\r\n\r\n        return valuesFunctionMap;\r\n      }\r\n\r\n      $dateParser.init();\r\n      return $dateParser;\r\n\r\n    };\r\n\r\n    return DateParserFactory;\r\n\r\n  };\r\n\r\n});\r\n\r\n// Source: helpers\\date-formatter.js\r\nangular.module('mgcrea.ngStrap.helpers.dateFormatter', [])\r\n\r\n  .service('$dateFormatter', function ($locale, dateFilter) {\r\n\r\n    // The unused `lang` arguments are on purpose. The default implementation does not\r\n    // use them and it always uses the locale loaded into the `$locale` service.\r\n    // Custom implementations might use it, thus allowing different directives to\r\n    // have different languages.\r\n\r\n    this.getDefaultLocale = function () {\r\n      return $locale.id;\r\n    };\r\n\r\n    // Format is either a data format name, e.g. \"shortTime\" or \"fullDate\", or a date format\r\n    // Return either the corresponding date format or the given date format.\r\n    this.getDatetimeFormat = function (format, lang) {\r\n      return $locale.DATETIME_FORMATS[format] || format;\r\n    };\r\n\r\n    this.weekdaysShort = function (lang) {\r\n      return $locale.DATETIME_FORMATS.SHORTDAY;\r\n    };\r\n\r\n    this.weekdays = function (lang) {\r\n      return $locale.DATETIME_FORMATS.DAY;\r\n    };\r\n\r\n    function splitTimeFormat (format) {\r\n      return /(h+)([:\\.])?(m+)([:\\.])?(s*)[ ]?(a?)/i.exec(format).slice(1);\r\n    }\r\n\r\n    // h:mm a => h\r\n    this.hoursFormat = function (timeFormat) {\r\n      return splitTimeFormat(timeFormat)[0];\r\n    };\r\n\r\n    // h:mm a => mm\r\n    this.minutesFormat = function (timeFormat) {\r\n      return splitTimeFormat(timeFormat)[2];\r\n    };\r\n\r\n    // h:mm:ss a => ss\r\n    this.secondsFormat = function (timeFormat) {\r\n      return splitTimeFormat(timeFormat)[4];\r\n    };\r\n\r\n    // h:mm a => :\r\n    this.timeSeparator = function (timeFormat) {\r\n      return splitTimeFormat(timeFormat)[1];\r\n    };\r\n\r\n    // h:mm:ss a => true, h:mm a => false\r\n    this.showSeconds = function (timeFormat) {\r\n      return !!splitTimeFormat(timeFormat)[4];\r\n    };\r\n\r\n    // h:mm a => true, H.mm => false\r\n    this.showAM = function (timeFormat) {\r\n      return !!splitTimeFormat(timeFormat)[5];\r\n    };\r\n\r\n    this.formatDate = function (date, format, lang, timezone) {\r\n      return dateFilter(date, format, timezone);\r\n    };\r\n\r\n  });\r\n\r\n// Source: helpers\\compiler.js\r\n// NOTICE: This file was forked from the angular-material project (github.com/angular/material)\r\n// MIT Licensed - Copyright (c) 2014-2015 Google, Inc. http://angularjs.org\r\n\r\nangular.module('mgcrea.ngStrap.core', [])\r\n  .service('$bsCompiler', bsCompilerService);\r\n\r\nfunction bsCompilerService ($q, $http, $injector, $compile, $controller, $templateCache) {\r\n\r\n  /*\r\n   * @ngdoc service\r\n   * @name $bsCompiler\r\n   * @module material.core\r\n   * @description\r\n   * The $bsCompiler service is an abstraction of angular's compiler, that allows the developer\r\n   * to easily compile an element with a templateUrl, controller, and locals.\r\n   *\r\n   * @usage\r\n   * <hljs lang=\"js\">\r\n   * $bsCompiler.compile({\r\n   *   templateUrl: 'modal.html',\r\n   *   controller: 'ModalCtrl',\r\n   *   locals: {\r\n   *     modal: myModalInstance;\r\n   *   }\r\n   * }).then(function(compileData) {\r\n   *   compileData.element; // modal.html's template in an element\r\n   *   compileData.link(myScope); //attach controller & scope to element\r\n   * });\r\n   * </hljs>\r\n   */\r\n\r\n   /*\r\n    * @ngdoc method\r\n    * @name $bsCompiler#compile\r\n    * @description A helper to compile an HTML template/templateUrl with a given controller,\r\n    * locals, and scope.\r\n    * @param {object} options An options object, with the following properties:\r\n    *\r\n    *    - `controller` - `{(string=|function()=}` Controller fn that should be associated with\r\n    *      newly created scope or the name of a registered controller if passed as a string.\r\n    *    - `controllerAs` - `{string=}` A controller alias name. If present the controller will be\r\n    *      published to scope under the `controllerAs` name.\r\n    *    - `template` - `{string=}` An html template as a string.\r\n    *    - `templateUrl` - `{string=}` A path to an html template.\r\n    *    - `transformTemplate` - `{function(template)=}` A function which transforms the template after\r\n    *      it is loaded. It will be given the template string as a parameter, and should\r\n    *      return a a new string representing the transformed template.\r\n    *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should\r\n    *      be injected into the controller. If any of these dependencies are promises, the compiler\r\n    *      will wait for them all to be resolved, or if one is rejected before the controller is\r\n    *      instantiated `compile()` will fail..\r\n    *      * `key` - `{string}`: a name of a dependency to be injected into the controller.\r\n    *      * `factory` - `{string|function}`: If `string` then it is an alias for a service.\r\n    *        Otherwise if function, then it is injected and the return value is treated as the\r\n    *        dependency. If the result is a promise, it is resolved before its value is\r\n    *        injected into the controller.\r\n    *\r\n    * @returns {object=} promise A promise, which will be resolved with a `compileData` object.\r\n    * `compileData` has the following properties:\r\n    *\r\n    *   - `element` - `{element}`: an uncompiled element matching the provided template.\r\n    *   - `link` - `{function(scope)}`: A link function, which, when called, will compile\r\n    *     the element and instantiate the provided controller (if given).\r\n    *   - `locals` - `{object}`: The locals which will be passed into the controller once `link` is\r\n    *     called. If `bindToController` is true, they will be coppied to the ctrl instead\r\n    *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in.\r\n    */\r\n  this.compile = function (options) {\r\n\r\n    if (options.template && /\\.html$/.test(options.template)) {\r\n      console.warn('Deprecated use of `template` option to pass a file. Please use the `templateUrl` option instead.');\r\n      options.templateUrl = options.template;\r\n      options.template = '';\r\n    }\r\n\r\n    var templateUrl = options.templateUrl;\r\n    var template = options.template || '';\r\n    var controller = options.controller;\r\n    var controllerAs = options.controllerAs;\r\n    var resolve = options.resolve || {};\r\n    var locals = options.locals || {};\r\n    var transformTemplate = options.transformTemplate || angular.identity;\r\n    var bindToController = options.bindToController;\r\n\r\n    // Take resolve values and invoke them.\r\n    // Resolves can either be a string (value: 'MyRegisteredAngularConst'),\r\n    // or an invokable 'factory' of sorts: (value: function ValueGetter($dependency) {})\r\n    angular.forEach(resolve, function (value, key) {\r\n      if (angular.isString(value)) {\r\n        resolve[key] = $injector.get(value);\r\n      } else {\r\n        resolve[key] = $injector.invoke(value);\r\n      }\r\n    });\r\n    // Add the locals, which are just straight values to inject\r\n    // eg locals: { three: 3 }, will inject three into the controller\r\n    angular.extend(resolve, locals);\r\n\r\n    if (template) {\r\n      resolve.$template = $q.when(template);\r\n    } else if (templateUrl) {\r\n      resolve.$template = fetchTemplate(templateUrl);\r\n    } else {\r\n      throw new Error('Missing `template` / `templateUrl` option.');\r\n    }\r\n\r\n    if (options.titleTemplate) {\r\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.titleTemplate)])\r\n        .then(function (templates) {\r\n          var templateEl = angular.element(templates[0]);\r\n          findElement('[ng-bind=\"title\"]', templateEl[0])\r\n            .removeAttr('ng-bind')\r\n            .html(templates[1]);\r\n          return templateEl[0].outerHTML;\r\n        });\r\n    }\r\n\r\n    if (options.contentTemplate) {\r\n      // TODO(mgcrea): deprecate?\r\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.contentTemplate)])\r\n        .then(function (templates) {\r\n          var templateEl = angular.element(templates[0]);\r\n          var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0])\r\n            .removeAttr('ng-bind')\r\n            .html(templates[1]);\r\n          // Drop the default footer as you probably don't want it if you use a custom contentTemplate\r\n          if (!options.templateUrl) contentEl.next().remove();\r\n          return templateEl[0].outerHTML;\r\n        });\r\n    }\r\n\r\n    // Wait for all the resolves to finish if they are promises\r\n    return $q.all(resolve).then(function (locals) {\r\n\r\n      var template = transformTemplate(locals.$template);\r\n      if (options.html) {\r\n        template = template.replace(/ng-bind=\"/ig, 'ng-bind-html=\"');\r\n      }\r\n      // var element = options.element || angular.element('<div>').html(template.trim()).contents();\r\n      var element = angular.element('<div>').html(template.trim()).contents();\r\n      var linkFn = $compile(element);\r\n\r\n      // Return a linking function that can be used later when the element is ready\r\n      return {\r\n        locals: locals,\r\n        element: element,\r\n        link: function link (scope) {\r\n          locals.$scope = scope;\r\n\r\n          // Instantiate controller if it exists, because we have scope\r\n          if (controller) {\r\n            var invokeCtrl = $controller(controller, locals, true);\r\n            if (bindToController) {\r\n              angular.extend(invokeCtrl.instance, locals);\r\n            }\r\n            // Support angular@~1.2 invokeCtrl\r\n            var ctrl = angular.isObject(invokeCtrl) ? invokeCtrl : invokeCtrl();\r\n            // See angular-route source for this logic\r\n            element.data('$ngControllerController', ctrl);\r\n            element.children().data('$ngControllerController', ctrl);\r\n\r\n            if (controllerAs) {\r\n              scope[controllerAs] = ctrl;\r\n            }\r\n          }\r\n\r\n          return linkFn.apply(null, arguments);\r\n        }\r\n      };\r\n    });\r\n\r\n  };\r\n\r\n  function findElement (query, element) {\r\n    return angular.element((element || document).querySelectorAll(query));\r\n  }\r\n\r\n  var fetchPromises = {};\r\n  function fetchTemplate (template) {\r\n    if (fetchPromises[template]) return fetchPromises[template];\r\n    return (fetchPromises[template] = $http.get(template, {cache: $templateCache})\r\n      .then(function (res) {\r\n        return res.data;\r\n      }));\r\n  }\r\n\r\n}\r\n\r\n// Source: typeahead\\typeahead.js\r\nangular.module('mgcrea.ngStrap.typeahead', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\r\n\r\n  .provider('$typeahead', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      prefixClass: 'typeahead',\r\n      prefixEvent: '$typeahead',\r\n      placement: 'bottom-left',\r\n      templateUrl: 'typeahead/typeahead.tpl.html',\r\n      trigger: 'focus',\r\n      container: false,\r\n      keyboard: true,\r\n      html: false,\r\n      delay: 0,\r\n      minLength: 1,\r\n      filter: 'bsAsyncFilter',\r\n      limit: 6,\r\n      autoSelect: false,\r\n      comparator: '',\r\n      trimValue: true\r\n    };\r\n\r\n    this.$get = function ($window, $rootScope, $tooltip, $$rAF, $timeout) {\r\n\r\n      function TypeaheadFactory (element, controller, config) {\r\n\r\n        var $typeahead = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n\r\n        $typeahead = $tooltip(element, options);\r\n        var parentScope = config.scope;\r\n        var scope = $typeahead.$scope;\r\n\r\n        scope.$resetMatches = function () {\r\n          scope.$matches = [];\r\n          scope.$activeIndex = options.autoSelect ? 0 : -1; // If set to 0, the first match will be highlighted\r\n        };\r\n        scope.$resetMatches();\r\n\r\n        scope.$activate = function (index) {\r\n          scope.$$postDigest(function () {\r\n            $typeahead.activate(index);\r\n          });\r\n        };\r\n\r\n        scope.$select = function (index, evt) {\r\n          scope.$$postDigest(function () {\r\n            $typeahead.select(index);\r\n          });\r\n        };\r\n\r\n        scope.$isVisible = function () {\r\n          return $typeahead.$isVisible();\r\n        };\r\n\r\n        // Public methods\r\n\r\n        $typeahead.update = function (matches) {\r\n          scope.$matches = matches;\r\n          if (scope.$activeIndex >= matches.length) {\r\n            scope.$activeIndex = options.autoSelect ? 0 : -1;\r\n          }\r\n\r\n          // wrap in a $timeout so the results are updated\r\n          // before repositioning\r\n          safeDigest(scope);\r\n          $$rAF($typeahead.$applyPlacement);\r\n        };\r\n\r\n        $typeahead.activate = function (index) {\r\n          scope.$activeIndex = index;\r\n        };\r\n\r\n        $typeahead.select = function (index) {\r\n          if (index === -1) return;\r\n          var value = scope.$matches[index].value;\r\n          // console.log('$setViewValue', value);\r\n          controller.$setViewValue(value);\r\n          controller.$render();\r\n          scope.$resetMatches();\r\n          if (parentScope) parentScope.$digest();\r\n          // Emit event\r\n          scope.$emit(options.prefixEvent + '.select', value, index, $typeahead);\r\n          if (angular.isDefined(options.onSelect) && angular.isFunction(options.onSelect)) {\r\n            options.onSelect(value, index, $typeahead);\r\n          }\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $typeahead.$isVisible = function () {\r\n          if (!options.minLength || !controller) {\r\n            return !!scope.$matches.length;\r\n          }\r\n          // minLength support\r\n          return scope.$matches.length && angular.isString(controller.$viewValue) && controller.$viewValue.length >= options.minLength;\r\n        };\r\n\r\n        $typeahead.$getIndex = function (value) {\r\n          var index;\r\n          for (index = scope.$matches.length; index--;) {\r\n            if (angular.equals(scope.$matches[index].value, value)) break;\r\n          }\r\n          return index;\r\n        };\r\n\r\n        $typeahead.$onMouseDown = function (evt) {\r\n          // Prevent blur on mousedown\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n        };\r\n\r\n        $typeahead.$$updateScrollTop = function (container, index) {\r\n          if (index > -1 && index < container.children.length) {\r\n            var active = container.children[index];\r\n            var clientTop = active.offsetTop;\r\n            var clientBottom = active.offsetTop + active.clientHeight;\r\n            var highWatermark = container.scrollTop;\r\n            var lowWatermark = container.scrollTop + container.clientHeight;\r\n\r\n            // active entry overlaps top border\r\n            if (clientBottom >= highWatermark && clientTop < highWatermark) {\r\n              container.scrollTop = Math.max(0, container.scrollTop - container.clientHeight);\r\n            } else if (clientBottom > lowWatermark) {\r\n              // top of active element is invisible because it's below the bottom of the visible container window\r\n              container.scrollTop = clientTop;\r\n            }\r\n          }\r\n        };\r\n\r\n        $typeahead.$onKeyDown = function (evt) {\r\n          if (!/(38|40|13)/.test(evt.keyCode)) return;\r\n\r\n          // Let ngSubmit pass if the typeahead tip is hidden or no option is selected\r\n          if ($typeahead.$isVisible() && !(evt.keyCode === 13 && scope.$activeIndex === -1)) {\r\n            evt.preventDefault();\r\n            evt.stopPropagation();\r\n          }\r\n\r\n          // Select with enter\r\n          if (evt.keyCode === 13 && scope.$matches.length) {\r\n            $typeahead.select(scope.$activeIndex);\r\n          // Navigate with keyboard\r\n          } else if (evt.keyCode === 38 && scope.$activeIndex > 0) {\r\n            scope.$activeIndex--;\r\n          } else if (evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) {\r\n            scope.$activeIndex++;\r\n          } else if (angular.isUndefined(scope.$activeIndex)) {\r\n            scope.$activeIndex = 0;\r\n          }\r\n\r\n          // update scrollTop property on $typeahead when scope.$activeIndex is not in visible area\r\n          $typeahead.$$updateScrollTop($typeahead.$element[0], scope.$activeIndex);\r\n          scope.$digest();\r\n        };\r\n\r\n        // Overrides\r\n\r\n        var show = $typeahead.show;\r\n        $typeahead.show = function () {\r\n          show();\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed immediately.\r\n          $timeout(function () {\r\n            if ($typeahead.$element) {\r\n              $typeahead.$element.on('mousedown', $typeahead.$onMouseDown);\r\n              if (options.keyboard) {\r\n                if (element) element.on('keydown', $typeahead.$onKeyDown);\r\n              }\r\n            }\r\n          }, 0, false);\r\n        };\r\n\r\n        var hide = $typeahead.hide;\r\n        $typeahead.hide = function () {\r\n          if ($typeahead.$element) $typeahead.$element.off('mousedown', $typeahead.$onMouseDown);\r\n          if (options.keyboard) {\r\n            if (element) element.off('keydown', $typeahead.$onKeyDown);\r\n          }\r\n          if (!options.autoSelect) {\r\n            $typeahead.activate(-1);\r\n          }\r\n          hide();\r\n        };\r\n\r\n        return $typeahead;\r\n\r\n      }\r\n\r\n      // Helper functions\r\n\r\n      function safeDigest (scope) {\r\n        /* eslint-disable no-unused-expressions */\r\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\r\n        /* eslint-enable no-unused-expressions */\r\n      }\r\n\r\n      TypeaheadFactory.defaults = defaults;\r\n      return TypeaheadFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .filter('bsAsyncFilter', function ($filter) {\r\n    return function (array, expression, comparator) {\r\n      if (array && angular.isFunction(array.then)) {\r\n        return array.then(function (results) {\r\n          return $filter('filter')(results, expression, comparator);\r\n        });\r\n      }\r\n      return $filter('filter')(array, expression, comparator);\r\n    };\r\n  })\r\n\r\n  .directive('bsTypeahead', function ($window, $parse, $q, $typeahead, $parseOptions) {\r\n\r\n    var defaults = $typeahead.defaults;\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        // Fixes firefox bug when using objects in model with typeahead\r\n        // Yes this breaks any other directive using a 'change' event on this input,\r\n        // but if it is using the 'change' event why is it used with typeahead?\r\n        element.off('change');\r\n\r\n        // Directive options\r\n        var options = {\r\n          scope: scope\r\n        };\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'filter', 'limit', 'minLength', 'watchOptions', 'selectMode', 'autoSelect', 'comparator', 'id', 'prefixEvent', 'prefixClass'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container', 'trimValue', 'filter'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n        });\r\n\r\n        // bind functions from the attrs to the show, hide and select events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide', 'onSelect'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Disable browser autocompletion\r\n        if (!element.attr('autocomplete')) element.attr('autocomplete', 'off');\r\n\r\n        // Build proper bsOptions\r\n        var filter = angular.isDefined(options.filter) ? options.filter : defaults.filter;\r\n        var limit = options.limit || defaults.limit;\r\n        var comparator = options.comparator || defaults.comparator;\r\n\r\n        var bsOptions = attr.bsOptions;\r\n        if (filter) {\r\n          bsOptions += ' | ' + filter + ':$viewValue';\r\n          if (comparator) bsOptions += ':' + comparator;\r\n        }\r\n        if (limit) bsOptions += ' | limitTo:' + limit;\r\n        var parsedOptions = $parseOptions(bsOptions);\r\n\r\n        // Initialize typeahead\r\n        var typeahead = $typeahead(element, controller, options);\r\n\r\n        // Watch options on demand\r\n        if (options.watchOptions) {\r\n          // Watch bsOptions values before filtering for changes, drop function calls\r\n          var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').replace(/\\(.*\\)/g, '').trim();\r\n          scope.$watchCollection(watchedOptions, function (newValue, oldValue) {\r\n            // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\r\n            parsedOptions.valuesFn(scope, controller).then(function (values) {\r\n              typeahead.update(values);\r\n              controller.$render();\r\n            });\r\n          });\r\n        }\r\n\r\n        // Watch model for changes\r\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\r\n          // console.warn('$watch', element.attr('ng-model'), newValue);\r\n          scope.$modelValue = newValue; // Publish modelValue on scope for custom templates\r\n          parsedOptions.valuesFn(scope, controller)\r\n            .then(function (values) {\r\n              // Prevent input with no future prospect if selectMode is truthy\r\n              // @TODO test selectMode\r\n              if (options.selectMode && !values.length && newValue.length > 0) {\r\n                controller.$setViewValue(controller.$viewValue.substring(0, controller.$viewValue.length - 1));\r\n                return;\r\n              }\r\n              if (values.length > limit) values = values.slice(0, limit);\r\n              typeahead.update(values);\r\n              // Queue a new rendering that will leverage collection loading\r\n              controller.$render();\r\n            });\r\n        });\r\n\r\n        // modelValue -> $formatters -> viewValue\r\n        controller.$formatters.push(function (modelValue) {\r\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n          var displayValue = parsedOptions.displayValue(modelValue);\r\n\r\n          // If we can determine the displayValue, use that\r\n          if (displayValue) {\r\n            return displayValue;\r\n          }\r\n\r\n          // If there's no display value, attempt to use the modelValue.\r\n          // If the model is an object not much we can do\r\n          if (angular.isDefined(modelValue) && typeof modelValue !== 'object') {\r\n            return modelValue;\r\n          }\r\n          return '';\r\n        });\r\n\r\n        // Model rendering in view\r\n        controller.$render = function () {\r\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\r\n          if (controller.$isEmpty(controller.$viewValue)) {\r\n            return element.val('');\r\n          }\r\n          var index = typeahead.$getIndex(controller.$modelValue);\r\n          var selected = index !== -1 ? typeahead.$scope.$matches[index].label : controller.$viewValue;\r\n          selected = angular.isObject(selected) ? parsedOptions.displayValue(selected) : selected;\r\n          var value = selected ? selected.toString().replace(/<(?:.|\\n)*?>/gm, '') : '';\r\n          var ss = element[0].selectionStart;\r\n          var sd = element[0].selectionEnd;\r\n          element.val(options.trimValue === false ? value : value.trim());\r\n          element[0].setSelectionRange(ss, sd);\r\n        };\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (typeahead) typeahead.destroy();\r\n          options = null;\r\n          typeahead = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n\r\n// Source: tooltip\\tooltip.js\r\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\r\n\r\n  .provider('$tooltip', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      customClass: '',\r\n      prefixClass: 'tooltip',\r\n      prefixEvent: 'tooltip',\r\n      container: false,\r\n      target: false,\r\n      placement: 'top',\r\n      templateUrl: 'tooltip/tooltip.tpl.html',\r\n      template: '',\r\n      titleTemplate: false,\r\n      trigger: 'hover focus',\r\n      keyboard: false,\r\n      html: false,\r\n      show: false,\r\n      title: '',\r\n      type: '',\r\n      delay: 0,\r\n      autoClose: false,\r\n      bsEnabled: true,\r\n      mouseDownPreventDefault: true,\r\n      mouseDownStopPropagation: true,\r\n      viewport: {\r\n        selector: 'body',\r\n        padding: 0\r\n      }\r\n    };\r\n\r\n    this.$get = function ($window, $rootScope, $bsCompiler, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\r\n\r\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n      var isTouch = ('createTouch' in $window.document) && isNative;\r\n      var $body = angular.element($window.document);\r\n\r\n      function TooltipFactory (element, config) {\r\n\r\n        var $tooltip = {};\r\n\r\n        // Common vars\r\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\r\n        var promise = $tooltip.$promise = $bsCompiler.compile(options);\r\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\r\n\r\n        var nodeName = element[0].nodeName.toLowerCase();\r\n        if (options.delay && angular.isString(options.delay)) {\r\n          var split = options.delay.split(',').map(parseFloat);\r\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\r\n        }\r\n\r\n        // Store $id to identify the triggering element in events\r\n        // give priority to options.id, otherwise, try to use\r\n        // element id if defined\r\n        $tooltip.$id = options.id || element.attr('id') || '';\r\n\r\n        // Support scope as string options\r\n        if (options.title) {\r\n          scope.title = $sce.trustAsHtml(options.title);\r\n        }\r\n\r\n        // Provide scope helpers\r\n        scope.$setEnabled = function (isEnabled) {\r\n          scope.$$postDigest(function () {\r\n            $tooltip.setEnabled(isEnabled);\r\n          });\r\n        };\r\n        scope.$hide = function () {\r\n          scope.$$postDigest(function () {\r\n            $tooltip.hide();\r\n          });\r\n        };\r\n        scope.$show = function () {\r\n          scope.$$postDigest(function () {\r\n            $tooltip.show();\r\n          });\r\n        };\r\n        scope.$toggle = function () {\r\n          scope.$$postDigest(function () {\r\n            $tooltip.toggle();\r\n          });\r\n        };\r\n        // Publish isShown as a protected var on scope\r\n        $tooltip.$isShown = scope.$isShown = false;\r\n\r\n        // Private vars\r\n        var timeout;\r\n        var hoverState;\r\n\r\n        // Fetch, compile then initialize tooltip\r\n        var compileData;\r\n        var tipElement;\r\n        var tipContainer;\r\n        var tipScope;\r\n        promise.then(function (data) {\r\n          compileData = data;\r\n          $tooltip.init();\r\n        });\r\n\r\n        $tooltip.init = function () {\r\n\r\n          // Options: delay\r\n          if (options.delay && angular.isNumber(options.delay)) {\r\n            options.delay = {\r\n              show: options.delay,\r\n              hide: options.delay\r\n            };\r\n          }\r\n\r\n          // Replace trigger on touch devices ?\r\n          // if(isTouch && options.trigger === defaults.trigger) {\r\n          //   options.trigger.replace(/hover/g, 'click');\r\n          // }\r\n\r\n          // Options : container\r\n          if (options.container === 'self') {\r\n            tipContainer = element;\r\n          } else if (angular.isElement(options.container)) {\r\n            tipContainer = options.container;\r\n          } else if (options.container) {\r\n            tipContainer = findElement(options.container);\r\n          }\r\n\r\n          // Options: trigger\r\n          bindTriggerEvents();\r\n\r\n          // Options: target\r\n          if (options.target) {\r\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\r\n          }\r\n\r\n          // Options: show\r\n          if (options.show) {\r\n            scope.$$postDigest(function () {\r\n              if (options.trigger === 'focus') {\r\n                element[0].focus();\r\n              } else {\r\n                $tooltip.show();\r\n              }\r\n            });\r\n          }\r\n\r\n        };\r\n\r\n        $tooltip.destroy = function () {\r\n\r\n          // Unbind events\r\n          unbindTriggerEvents();\r\n\r\n          // Remove element\r\n          destroyTipElement();\r\n\r\n          // Destroy scope\r\n          scope.$destroy();\r\n\r\n        };\r\n\r\n        $tooltip.enter = function () {\r\n\r\n          clearTimeout(timeout);\r\n          hoverState = 'in';\r\n          if (!options.delay || !options.delay.show) {\r\n            return $tooltip.show();\r\n          }\r\n\r\n          timeout = setTimeout(function () {\r\n            if (hoverState === 'in') $tooltip.show();\r\n          }, options.delay.show);\r\n\r\n        };\r\n\r\n        $tooltip.show = function () {\r\n          if (!options.bsEnabled || $tooltip.$isShown) return;\r\n\r\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\r\n          if (angular.isDefined(options.onBeforeShow) && angular.isFunction(options.onBeforeShow)) {\r\n            options.onBeforeShow($tooltip);\r\n          }\r\n          var parent;\r\n          var after;\r\n          if (options.container) {\r\n            parent = tipContainer;\r\n            if (tipContainer[0].lastChild) {\r\n              after = angular.element(tipContainer[0].lastChild);\r\n            } else {\r\n              after = null;\r\n            }\r\n          } else {\r\n            parent = null;\r\n            after = element;\r\n          }\r\n\r\n\r\n          // Hide any existing tipElement\r\n          if (tipElement) destroyTipElement();\r\n          // Fetch a cloned element linked from template\r\n          tipScope = $tooltip.$scope.$new();\r\n          tipElement = $tooltip.$element = compileData.link(tipScope, function (clonedElement, scope) {});\r\n\r\n          // Set the initial positioning.  Make the tooltip invisible\r\n          // so IE doesn't try to focus on it off screen.\r\n          tipElement.css({top: '-9999px', left: '-9999px', right: 'auto', display: 'block', visibility: 'hidden'});\r\n\r\n          // Options: animation\r\n          if (options.animation) tipElement.addClass(options.animation);\r\n          // Options: type\r\n          if (options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\r\n          // Options: custom classes\r\n          if (options.customClass) tipElement.addClass(options.customClass);\r\n\r\n          // Append the element, without any animations.  If we append\r\n          // using $animate.enter, some of the animations cause the placement\r\n          // to be off due to the transforms.\r\n          if (after) {\r\n            after.after(tipElement);\r\n          } else {\r\n            parent.prepend(tipElement);\r\n          }\r\n\r\n          $tooltip.$isShown = scope.$isShown = true;\r\n          safeDigest(scope);\r\n\r\n          // Now, apply placement\r\n          $tooltip.$applyPlacement();\r\n\r\n          // Once placed, animate it.\r\n          // Support v1.2+ $animate\r\n          // https://github.com/angular/angular.js/issues/11713\r\n          if (angular.version.minor <= 2) {\r\n            $animate.enter(tipElement, parent, after, enterAnimateCallback);\r\n          } else {\r\n            $animate.enter(tipElement, parent, after).then(enterAnimateCallback);\r\n          }\r\n          safeDigest(scope);\r\n\r\n          $$rAF(function () {\r\n            // Once the tooltip is placed and the animation starts, make the tooltip visible\r\n            if (tipElement) tipElement.css({visibility: 'visible'});\r\n\r\n            // Bind events\r\n            if (options.keyboard) {\r\n              if (options.trigger !== 'focus') {\r\n                $tooltip.focus();\r\n              }\r\n              bindKeyboardEvents();\r\n            }\r\n          });\r\n\r\n          if (options.autoClose) {\r\n            bindAutoCloseEvents();\r\n          }\r\n\r\n        };\r\n\r\n        function enterAnimateCallback () {\r\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\r\n          if (angular.isDefined(options.onShow) && angular.isFunction(options.onShow)) {\r\n            options.onShow($tooltip);\r\n          }\r\n        }\r\n\r\n        $tooltip.leave = function () {\r\n\r\n          clearTimeout(timeout);\r\n          hoverState = 'out';\r\n          if (!options.delay || !options.delay.hide) {\r\n            return $tooltip.hide();\r\n          }\r\n          timeout = setTimeout(function () {\r\n            if (hoverState === 'out') {\r\n              $tooltip.hide();\r\n            }\r\n          }, options.delay.hide);\r\n\r\n        };\r\n\r\n        var _blur;\r\n        var _tipToHide;\r\n        $tooltip.hide = function (blur) {\r\n\r\n          if (!$tooltip.$isShown) return;\r\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\r\n          if (angular.isDefined(options.onBeforeHide) && angular.isFunction(options.onBeforeHide)) {\r\n            options.onBeforeHide($tooltip);\r\n          }\r\n\r\n          // store blur value for leaveAnimateCallback to use\r\n          _blur = blur;\r\n\r\n          // store current tipElement reference to use\r\n          // in leaveAnimateCallback\r\n          _tipToHide = tipElement;\r\n\r\n          if (tipElement !== null) {\r\n            // Support v1.2+ $animate\r\n            // https://github.com/angular/angular.js/issues/11713\r\n            if (angular.version.minor <= 2) {\r\n              $animate.leave(tipElement, leaveAnimateCallback);\r\n            } else {\r\n              $animate.leave(tipElement).then(leaveAnimateCallback);\r\n            }\r\n          }\r\n\r\n          $tooltip.$isShown = scope.$isShown = false;\r\n          safeDigest(scope);\r\n\r\n          // Unbind events\r\n          if (options.keyboard && tipElement !== null) {\r\n            unbindKeyboardEvents();\r\n          }\r\n\r\n          if (options.autoClose && tipElement !== null) {\r\n            unbindAutoCloseEvents();\r\n          }\r\n        };\r\n\r\n        function leaveAnimateCallback () {\r\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\r\n          if (angular.isDefined(options.onHide) && angular.isFunction(options.onHide)) {\r\n            options.onHide($tooltip);\r\n          }\r\n\r\n          // check if current tipElement still references\r\n          // the same element when hide was called\r\n          if (tipElement === _tipToHide) {\r\n            // Allow to blur the input when hidden, like when pressing enter key\r\n            if (_blur && options.trigger === 'focus') {\r\n              return element[0].blur();\r\n            }\r\n\r\n            // clean up child scopes\r\n            destroyTipElement();\r\n          }\r\n        }\r\n\r\n        $tooltip.toggle = function (evt) {\r\n          if (evt) { evt.preventDefault(); }\r\n          if ($tooltip.$isShown) {\r\n            $tooltip.leave();\r\n          } else {\r\n            $tooltip.enter();\r\n          }\r\n        };\r\n\r\n        $tooltip.focus = function () {\r\n          tipElement[0].focus();\r\n        };\r\n\r\n        $tooltip.setEnabled = function (isEnabled) {\r\n          options.bsEnabled = isEnabled;\r\n        };\r\n\r\n        $tooltip.setViewport = function (viewport) {\r\n          options.viewport = viewport;\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $tooltip.$applyPlacement = function () {\r\n          if (!tipElement) return;\r\n\r\n          // Determine if we're doing an auto or normal placement\r\n          var placement = options.placement;\r\n          var autoToken = /\\s?auto?\\s?/i;\r\n          var autoPlace = autoToken.test(placement);\r\n\r\n          if (autoPlace) {\r\n            placement = placement.replace(autoToken, '') || defaults.placement;\r\n          }\r\n\r\n          // Need to add the position class before we get\r\n          // the offsets\r\n          tipElement.addClass(options.placement);\r\n\r\n          // Get the position of the target element\r\n          // and the height and width of the tooltip so we can center it.\r\n          var elementPosition = getPosition();\r\n          var tipWidth = tipElement.prop('offsetWidth');\r\n          var tipHeight = tipElement.prop('offsetHeight');\r\n\r\n          // Refresh viewport position\r\n          $tooltip.$viewport = options.viewport && findElement(options.viewport.selector || options.viewport);\r\n\r\n          // If we're auto placing, we need to check the positioning\r\n          if (autoPlace) {\r\n            var originalPlacement = placement;\r\n            var viewportPosition = getPosition($tooltip.$viewport);\r\n\r\n            if (/bottom/.test(originalPlacement) && elementPosition.bottom + tipHeight > viewportPosition.bottom) {\r\n              placement = originalPlacement.replace('bottom', 'top');\r\n            } else if (/top/.test(originalPlacement) && elementPosition.top - tipHeight < viewportPosition.top) {\r\n              placement = originalPlacement.replace('top', 'bottom');\r\n            }\r\n\r\n            if (/left/.test(originalPlacement) && elementPosition.left - tipWidth < viewportPosition.left) {\r\n              placement = placement.replace('left', 'right');\r\n            } else if (/right/.test(originalPlacement) && elementPosition.right + tipWidth > viewportPosition.width) {\r\n              placement = placement.replace('right', 'left');\r\n            }\r\n\r\n            tipElement.removeClass(originalPlacement).addClass(placement);\r\n          }\r\n\r\n          // Get the tooltip's top and left coordinates to center it with this directive.\r\n          var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\r\n          applyPlacement(tipPosition, placement);\r\n        };\r\n\r\n        $tooltip.$onKeyUp = function (evt) {\r\n          if (evt.which === 27 && $tooltip.$isShown) {\r\n            $tooltip.hide();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        $tooltip.$onFocusKeyUp = function (evt) {\r\n          if (evt.which === 27) {\r\n            element[0].blur();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        $tooltip.$onFocusElementMouseDown = function (evt) {\r\n          if (options.mouseDownPreventDefault) { evt.preventDefault(); }\r\n          if (options.mouseDownStopPropagation) { evt.stopPropagation(); }\r\n          // Some browsers do not auto-focus buttons (eg. Safari)\r\n          if ($tooltip.$isShown) {\r\n            element[0].blur();\r\n          } else {\r\n            element[0].focus();\r\n          }\r\n        };\r\n\r\n        // bind/unbind events\r\n        function bindTriggerEvents () {\r\n          var triggers = options.trigger.split(' ');\r\n          angular.forEach(triggers, function (trigger) {\r\n            if (trigger === 'click' || trigger === 'contextmenu') {\r\n              element.on(trigger, $tooltip.toggle);\r\n              // element.on('blur', $tooltip.leave);\r\n            } else if (trigger !== 'manual') {\r\n              element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\r\n              element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\r\n              if (nodeName === 'button' && trigger !== 'hover') {\r\n                element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\r\n              }\r\n            }\r\n          });\r\n        }\r\n\r\n        function unbindTriggerEvents () {\r\n          var triggers = options.trigger.split(' ');\r\n          for (var i = triggers.length; i--;) {\r\n            var trigger = triggers[i];\r\n            if (trigger === 'click' || trigger === 'contextmenu') {\r\n              element.off(trigger, $tooltip.toggle);\r\n            } else if (trigger !== 'manual') {\r\n              element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\r\n              element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\r\n              if (nodeName === 'button' && trigger !== 'hover') {\r\n                element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        function bindKeyboardEvents () {\r\n          if (options.trigger !== 'focus') {\r\n            tipElement.on('keyup', $tooltip.$onKeyUp);\r\n          } else {\r\n            element.on('keyup', $tooltip.$onFocusKeyUp);\r\n          }\r\n        }\r\n\r\n        function unbindKeyboardEvents () {\r\n          if (options.trigger !== 'focus') {\r\n            tipElement.off('keyup', $tooltip.$onKeyUp);\r\n          } else {\r\n            element.off('keyup', $tooltip.$onFocusKeyUp);\r\n          }\r\n        }\r\n\r\n        var _autoCloseEventsBinded = false;\r\n        function bindAutoCloseEvents () {\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed imediately.\r\n          $timeout(function () {\r\n            // Stop propagation when clicking inside tooltip\r\n            tipElement.on('click', stopEventPropagation);\r\n\r\n            // Hide when clicking outside tooltip\r\n            $body.on('click', $tooltip.hide);\r\n\r\n            _autoCloseEventsBinded = true;\r\n          }, 0, false);\r\n        }\r\n\r\n        function unbindAutoCloseEvents () {\r\n          if (_autoCloseEventsBinded) {\r\n            tipElement.off('click', stopEventPropagation);\r\n            $body.off('click', $tooltip.hide);\r\n            _autoCloseEventsBinded = false;\r\n          }\r\n        }\r\n\r\n        function stopEventPropagation (event) {\r\n          event.stopPropagation();\r\n        }\r\n\r\n        // Private methods\r\n\r\n        function getPosition ($element) {\r\n          $element = $element || (options.target || element);\r\n\r\n          var el = $element[0];\r\n          var isBody = el.tagName === 'BODY';\r\n\r\n          var elRect = el.getBoundingClientRect();\r\n          var rect = {};\r\n\r\n          // IE8 has issues with angular.extend and using elRect directly.\r\n          // By coping the values of elRect into a new object, we can continue to use extend\r\n          /* eslint-disable guard-for-in */\r\n          for (var p in elRect) { // eslint-disable-line\r\n            // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.\r\n            rect[p] = elRect[p];\r\n          }\r\n          /* eslint-enable guard-for-in */\r\n\r\n          if (rect.width === null) {\r\n            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\r\n            rect = angular.extend({}, rect, {width: elRect.right - elRect.left, height: elRect.bottom - elRect.top});\r\n          }\r\n          var elOffset = isBody ? {top: 0, left: 0} : dimensions.offset(el);\r\n          var scroll = {scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0};\r\n          var outerDims = isBody ? {width: document.documentElement.clientWidth, height: $window.innerHeight} : null;\r\n\r\n          return angular.extend({}, rect, scroll, outerDims, elOffset);\r\n        }\r\n\r\n        function getCalculatedOffset (placement, position, actualWidth, actualHeight) {\r\n          var offset;\r\n          var split = placement.split('-');\r\n\r\n          switch (split[0]) {\r\n            case 'right':\r\n              offset = {\r\n                top: position.top + position.height / 2 - actualHeight / 2,\r\n                left: position.left + position.width\r\n              };\r\n              break;\r\n            case 'bottom':\r\n              offset = {\r\n                top: position.top + position.height,\r\n                left: position.left + position.width / 2 - actualWidth / 2\r\n              };\r\n              break;\r\n            case 'left':\r\n              offset = {\r\n                top: position.top + position.height / 2 - actualHeight / 2,\r\n                left: position.left - actualWidth\r\n              };\r\n              break;\r\n            default:\r\n              offset = {\r\n                top: position.top - actualHeight,\r\n                left: position.left + position.width / 2 - actualWidth / 2\r\n              };\r\n              break;\r\n          }\r\n\r\n          if (!split[1]) {\r\n            return offset;\r\n          }\r\n\r\n          // Add support for corners @todo css\r\n          if (split[0] === 'top' || split[0] === 'bottom') {\r\n            switch (split[1]) {\r\n              case 'left':\r\n                offset.left = position.left;\r\n                break;\r\n              case 'right':\r\n                offset.left = position.left + position.width - actualWidth;\r\n                break;\r\n              default:\r\n                break;\r\n            }\r\n          } else if (split[0] === 'left' || split[0] === 'right') {\r\n            switch (split[1]) {\r\n              case 'top':\r\n                offset.top = position.top - actualHeight + position.height;\r\n                break;\r\n              case 'bottom':\r\n                offset.top = position.top;\r\n                break;\r\n              default:\r\n                break;\r\n            }\r\n          }\r\n\r\n          return offset;\r\n        }\r\n\r\n        function applyPlacement (offset, placement) {\r\n          var tip = tipElement[0];\r\n          var width = tip.offsetWidth;\r\n          var height = tip.offsetHeight;\r\n\r\n          // manually read margins because getBoundingClientRect includes difference\r\n          var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10);\r\n          var marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);\r\n\r\n          // we must check for NaN for ie 8/9\r\n          if (isNaN(marginTop)) marginTop = 0;\r\n          if (isNaN(marginLeft)) marginLeft = 0;\r\n\r\n          offset.top = offset.top + marginTop;\r\n          offset.left = offset.left + marginLeft;\r\n\r\n          // dimensions setOffset doesn't round pixel values\r\n          // so we use setOffset directly with our own function\r\n          dimensions.setOffset(tip, angular.extend({\r\n            using: function (props) {\r\n              tipElement.css({\r\n                top: Math.round(props.top) + 'px',\r\n                left: Math.round(props.left) + 'px',\r\n                right: ''\r\n              });\r\n            }\r\n          }, offset), 0);\r\n\r\n          // check to see if placing tip in new offset caused the tip to resize itself\r\n          var actualWidth = tip.offsetWidth;\r\n          var actualHeight = tip.offsetHeight;\r\n\r\n          if (placement === 'top' && actualHeight !== height) {\r\n            offset.top = offset.top + height - actualHeight;\r\n          }\r\n\r\n          // If it's an exotic placement, exit now instead of\r\n          // applying a delta and changing the arrow\r\n          if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;\r\n\r\n          var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\r\n\r\n          if (delta.left) {\r\n            offset.left += delta.left;\r\n          } else {\r\n            offset.top += delta.top;\r\n          }\r\n\r\n          dimensions.setOffset(tip, offset);\r\n\r\n          if (/top|right|bottom|left/.test(placement)) {\r\n            var isVertical = /top|bottom/.test(placement);\r\n            var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;\r\n            var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';\r\n\r\n            replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);\r\n          }\r\n        }\r\n\r\n        // @source https://github.com/twbs/bootstrap/blob/v3.3.5/js/tooltip.js#L380\r\n        function getViewportAdjustedDelta (placement, position, actualWidth, actualHeight) {\r\n          var delta = {top: 0, left: 0};\r\n          if (!$tooltip.$viewport) return delta;\r\n\r\n          var viewportPadding = options.viewport && options.viewport.padding || 0;\r\n          var viewportDimensions = getPosition($tooltip.$viewport);\r\n\r\n          if (/right|left/.test(placement)) {\r\n            var topEdgeOffset = position.top - viewportPadding - viewportDimensions.scroll;\r\n            var bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;\r\n            if (topEdgeOffset < viewportDimensions.top) { // top overflow\r\n              delta.top = viewportDimensions.top - topEdgeOffset;\r\n            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\r\n              delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\r\n            }\r\n          } else {\r\n            var leftEdgeOffset = position.left - viewportPadding;\r\n            var rightEdgeOffset = position.left + viewportPadding + actualWidth;\r\n            if (leftEdgeOffset < viewportDimensions.left) { // left overflow\r\n              delta.left = viewportDimensions.left - leftEdgeOffset;\r\n            } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow\r\n              delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\r\n            }\r\n          }\r\n\r\n          return delta;\r\n        }\r\n\r\n        function replaceArrow (delta, dimension, isHorizontal) {\r\n          var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);\r\n\r\n          $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\r\n                .css(isHorizontal ? 'top' : 'left', '');\r\n        }\r\n\r\n        function destroyTipElement () {\r\n          // Cancel pending callbacks\r\n          clearTimeout(timeout);\r\n\r\n          if ($tooltip.$isShown && tipElement !== null) {\r\n            if (options.autoClose) {\r\n              unbindAutoCloseEvents();\r\n            }\r\n\r\n            if (options.keyboard) {\r\n              unbindKeyboardEvents();\r\n            }\r\n          }\r\n\r\n          if (tipScope) {\r\n            tipScope.$destroy();\r\n            tipScope = null;\r\n          }\r\n\r\n          if (tipElement) {\r\n            tipElement.remove();\r\n            tipElement = $tooltip.$element = null;\r\n          }\r\n        }\r\n\r\n        return $tooltip;\r\n\r\n      }\r\n\r\n      // Helper functions\r\n\r\n      function safeDigest (scope) {\r\n        /* eslint-disable no-unused-expressions */\r\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\r\n        /* eslint-enable no-unused-expressions */\r\n      }\r\n\r\n      function findElement (query, element) {\r\n        return angular.element((element || document).querySelectorAll(query));\r\n      }\r\n\r\n      return TooltipFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsTooltip', function ($window, $location, $sce, $parse, $tooltip, $$rAF) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink (scope, element, attr, transclusion) {\r\n\r\n        var tooltip;\r\n        // Directive options\r\n        var options = {scope: scope};\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'titleTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\r\n            options[key] = false;\r\n          }\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // should not parse target attribute (anchor tag), only data-target #1454\r\n        var dataTarget = element.attr('data-target');\r\n        if (angular.isDefined(dataTarget)) {\r\n          if (falseValueRegExp.test(dataTarget)) {\r\n            options.target = false;\r\n          } else {\r\n            options.target = dataTarget;\r\n          }\r\n        }\r\n\r\n        // overwrite inherited title value when no value specified\r\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\r\n        if (!scope.hasOwnProperty('title')) {\r\n          scope.title = '';\r\n        }\r\n\r\n        // Observe scope attributes for change\r\n        attr.$observe('title', function (newValue) {\r\n          if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {\r\n            var oldValue = scope.title;\r\n            scope.title = $sce.trustAsHtml(newValue);\r\n            if (angular.isDefined(oldValue)) {\r\n              $$rAF(function () {\r\n                if (tooltip) tooltip.$applyPlacement();\r\n              });\r\n            }\r\n          }\r\n        });\r\n\r\n        attr.$observe('disabled', function (newValue) {\r\n          if (newValue && tooltip.$isShown) {\r\n            tooltip.hide();\r\n          }\r\n        });\r\n\r\n        // Support scope as an object\r\n        if (attr.bsTooltip) {\r\n          scope.$watch(attr.bsTooltip, function (newValue, oldValue) {\r\n            if (angular.isObject(newValue)) {\r\n              angular.extend(scope, newValue);\r\n            } else {\r\n              scope.title = newValue;\r\n            }\r\n            if (angular.isDefined(oldValue)) {\r\n              $$rAF(function () {\r\n                if (tooltip) tooltip.$applyPlacement();\r\n              });\r\n            }\r\n          }, true);\r\n        }\r\n\r\n        // Visibility binding support\r\n        if (attr.bsShow) {\r\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\r\n            if (!tooltip || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\r\n            if (newValue === true) {\r\n              tooltip.show();\r\n            } else {\r\n              tooltip.hide();\r\n            }\r\n          });\r\n        }\r\n\r\n        // Enabled binding support\r\n        if (attr.bsEnabled) {\r\n          scope.$watch(attr.bsEnabled, function (newValue, oldValue) {\r\n            // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\r\n            if (!tooltip || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\r\n            if (newValue === false) {\r\n              tooltip.setEnabled(false);\r\n            } else {\r\n              tooltip.setEnabled(true);\r\n            }\r\n          });\r\n        }\r\n\r\n        // Viewport support\r\n        if (attr.viewport) {\r\n          scope.$watch(attr.viewport, function (newValue) {\r\n            if (!tooltip || !angular.isDefined(newValue)) return;\r\n            tooltip.setViewport(newValue);\r\n          });\r\n        }\r\n\r\n        // Initialize popover\r\n        tooltip = $tooltip(element, options);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (tooltip) tooltip.destroy();\r\n          options = null;\r\n          tooltip = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n\r\n// Source: tab\\tab.js\r\nangular.module('mgcrea.ngStrap.tab', [])\r\n\r\n  .provider('$tab', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      template: 'tab/tab.tpl.html',\r\n      navClass: 'nav-tabs',\r\n      activeClass: 'active'\r\n    };\r\n    var _tabsHash = {};\r\n\r\n    var _addTabControl = function (key, control) {\r\n      if (!_tabsHash[key]) _tabsHash[key] = control;\r\n    };\r\n\r\n    var controller = this.controller = function ($scope, $element, $attrs, $timeout) {\r\n      var self = this;\r\n\r\n      // Attributes options\r\n      self.$options = angular.copy(defaults);\r\n      angular.forEach(['animation', 'navClass', 'activeClass', 'id'], function (key) {\r\n        if (angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\r\n      });\r\n\r\n      // Publish options on scope\r\n      $scope.$navClass = self.$options.navClass;\r\n      $scope.$activeClass = self.$options.activeClass;\r\n\r\n      $scope.$onClick = function $onClick (evt, pane, index) {\r\n        if (!pane.disabled) {\r\n          self.$setActive(pane.name || index);\r\n          focusCurrentTab();\r\n        }\r\n\r\n        evt.preventDefault();\r\n        evt.stopPropagation();\r\n      };\r\n\r\n      function navigatePane (index, toLeft) {\r\n        var newIndex = 0;\r\n\r\n        if (toLeft) {\r\n          // Moving to the left\r\n          newIndex = index - 1 < 0 ? (self.$panes.length - 1) : (index - 1);\r\n        } else {\r\n          // Moving to the right\r\n          newIndex = (index + 1) >= self.$panes.length ? 0 : (index + 1);\r\n        }\r\n\r\n        if (self.$panes[newIndex].disabled) {\r\n          navigatePane(newIndex, toLeft);\r\n        } else {\r\n          self.$setActive(self.$panes[newIndex].name || newIndex);\r\n          focusCurrentTab();\r\n        }\r\n      }\r\n\r\n      function focusCurrentTab () {\r\n        $timeout(function () {\r\n          var activeAs = angular.element($element[0].querySelectorAll('li.' + self.$options.activeClass));\r\n\r\n          if (activeAs.length > 0 && activeAs[0]) {\r\n            activeAs[0].focus();\r\n          }\r\n        }, 100);\r\n      }\r\n\r\n      self.$panes = $scope.$panes = [];\r\n\r\n      // Please use $activePaneChangeListeners if you use `bsActivePane`\r\n      // Because we removed `ngModel` as default, we rename viewChangeListeners to\r\n      // activePaneChangeListeners to make more sense.\r\n      self.$activePaneChangeListeners = self.$viewChangeListeners = [];\r\n\r\n      self.$push = function (pane) {\r\n        if (angular.isUndefined(self.$panes.$active)) {\r\n          $scope.$setActive(pane.name || 0);\r\n        }\r\n\r\n        self.$panes.push(pane);\r\n\r\n        self.$panes.forEach(function (tabPane, index) {\r\n          // Set an id value for the pane so that it can be used in the template\r\n          tabPane.$describedBy = self.$options.id === undefined ? undefined : self.$options.id + '_$tab_' + index;\r\n          tabPane.$labeledBy = self.$options.id === undefined ? undefined : self.$options.id + '_$tab_' + index + '_a';\r\n        });\r\n      };\r\n\r\n      self.$remove = function (pane) {\r\n        var index = self.$panes.indexOf(pane);\r\n        var active = self.$panes.$active;\r\n        var activeIndex;\r\n        if (angular.isString(active)) {\r\n          activeIndex = self.$panes.map(function (pane) {\r\n            return pane.name;\r\n          }).indexOf(active);\r\n        } else {\r\n          activeIndex = self.$panes.$active;\r\n        }\r\n\r\n        // remove pane from $panes array\r\n        self.$panes.splice(index, 1);\r\n\r\n        if (index < activeIndex) {\r\n          // we removed a pane before the active pane, so we need to\r\n          // decrement the active pane index\r\n          activeIndex--;\r\n        } else if (index === activeIndex && activeIndex === self.$panes.length) {\r\n          // we remove the active pane and it was the one at the end,\r\n          // so select the previous one\r\n          activeIndex--;\r\n        }\r\n        if (activeIndex >= 0 && activeIndex < self.$panes.length) {\r\n          self.$setActive(self.$panes[activeIndex].name || activeIndex);\r\n        } else {\r\n          self.$setActive();\r\n        }\r\n      };\r\n\r\n      self.$setActive = $scope.$setActive = function (value) {\r\n        self.$panes.$active = value;\r\n        self.$activePaneChangeListeners.forEach(function (fn) {\r\n          fn();\r\n        });\r\n      };\r\n\r\n      self.$isActive = $scope.$isActive = function ($pane, $index) {\r\n        return self.$panes.$active === $pane.name || self.$panes.$active === $index;\r\n      };\r\n\r\n      self.$onKeyPress = $scope.$onKeyPress = function (e, name, index) {\r\n        if (e.keyCode === 32 || e.charCode === 32 || e.keyCode === 13 || e.charCode === 13) {\r\n          // If space or enter was pressed\r\n          self.$setActive(name);\r\n\r\n          e.preventDefault();\r\n          e.stopPropagation();\r\n\r\n        } else if (e.keyCode === 37 || e.charCode === 37 || e.keyCode === 39 || e.charCode === 39) {\r\n          // If the left of right arrow key was pressed.\r\n          navigatePane(index, (e.keyCode === 37 || e.charCode === 37));\r\n        }\r\n      };\r\n    };\r\n\r\n    this.$get = function () {\r\n      var $tab = {};\r\n      $tab.defaults = defaults;\r\n      $tab.controller = controller;\r\n      $tab.addTabControl = _addTabControl;\r\n      $tab.tabsHash = _tabsHash;\r\n      return $tab;\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsTabs', function ($window, $animate, $tab, $parse, $timeout) {\r\n\r\n    var defaults = $tab.defaults;\r\n\r\n    return {\r\n      require: ['?ngModel', 'bsTabs'],\r\n      transclude: true,\r\n      scope: true,\r\n      controller: ['$scope', '$element', '$attrs', '$timeout', $tab.controller],\r\n      templateUrl: function (element, attr) {\r\n        return attr.template || defaults.template;\r\n      },\r\n      link: function postLink (scope, element, attrs, controllers) {\r\n\r\n        var ngModelCtrl = controllers[0];\r\n        var bsTabsCtrl = controllers[1];\r\n\r\n        // Add a way for developers to access tab scope if needed.  This allows for more fine grained control over what\r\n        // tabs are available in the tab component\r\n        if (attrs.tabKey !== '' && attrs.tabKey !== undefined) {\r\n          $tab.addTabControl(attrs.tabKey, bsTabsCtrl);\r\n        }\r\n\r\n        // 'ngModel' does interfere with form validation\r\n        // and status, use `bsActivePane` instead to avoid it\r\n        if (ngModelCtrl) {\r\n\r\n          // Update the modelValue following\r\n          bsTabsCtrl.$activePaneChangeListeners.push(function () {\r\n            ngModelCtrl.$setViewValue(bsTabsCtrl.$panes.$active);\r\n          });\r\n\r\n          // modelValue -> $formatters -> viewValue\r\n          ngModelCtrl.$formatters.push(function (modelValue) {\r\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n            bsTabsCtrl.$setActive(modelValue);\r\n            return modelValue;\r\n          });\r\n        }\r\n\r\n        bsTabsCtrl.$activePaneChangeListeners.push(function () {\r\n          $timeout(function () {\r\n            // get li elements\r\n            var liElements = element.find('li');\r\n            for (var i = 0; i < liElements.length; i++) {\r\n              var iElement = angular.element(liElements[i]);\r\n              if (iElement.hasClass(bsTabsCtrl.$options.activeClass)) {\r\n                // if li is active, set focus to it.\r\n                iElement.find('a')[0].focus();\r\n              }\r\n            }\r\n            // delay, for the class (.active) change to reflect in DOM.\r\n          }, 100);\r\n        });\r\n\r\n        if (attrs.bsActivePane) {\r\n          // adapted from angularjs ngModelController bindings\r\n          // https://github.com/angular/angular.js/blob/v1.3.1/src%2Fng%2Fdirective%2Finput.js#L1730\r\n          var parsedBsActivePane = $parse(attrs.bsActivePane);\r\n\r\n          // Update bsActivePane value with change\r\n          bsTabsCtrl.$activePaneChangeListeners.push(function () {\r\n            parsedBsActivePane.assign(scope, bsTabsCtrl.$panes.$active);\r\n          });\r\n\r\n          // watch bsActivePane for value changes\r\n          scope.$watch(attrs.bsActivePane, function (newValue, oldValue) {\r\n            bsTabsCtrl.$setActive(newValue);\r\n          }, true);\r\n        }\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsPane', function ($window, $animate, $sce) {\r\n\r\n    return {\r\n      require: ['^?ngModel', '^bsTabs'],\r\n      scope: true,\r\n      link: function postLink (scope, element, attrs, controllers) {\r\n\r\n        // var ngModelCtrl = controllers[0];\r\n        var bsTabsCtrl = controllers[1];\r\n\r\n        // Add base class\r\n        element.addClass('tab-pane');\r\n\r\n        // Set up the assistive attributes\r\n        element.attr('role', 'tabpanel');\r\n\r\n        // Observe title attribute for change\r\n        attrs.$observe('title', function (newValue, oldValue) {\r\n          scope.title = $sce.trustAsHtml(newValue);\r\n        });\r\n\r\n        // Save tab name into scope\r\n        scope.name = attrs.name;\r\n        // Save tab id into scope\r\n        scope.id = attrs.id;\r\n\r\n        scope.name = scope.name || scope.id;\r\n\r\n        // Add animation class\r\n        if (bsTabsCtrl.$options.animation) {\r\n          element.addClass(bsTabsCtrl.$options.animation);\r\n        }\r\n\r\n        attrs.$observe('disabled', function (newValue, oldValue) {\r\n          scope.disabled = scope.$eval(newValue);\r\n        });\r\n\r\n        // Push pane to parent bsTabs controller\r\n        bsTabsCtrl.$push(scope);\r\n\r\n        // Once the push has occured when can then update the element with some properties.\r\n        // Update the aria-describedby attribute\r\n        if (scope.$describedBy !== undefined) {\r\n          element.attr('aria-describedby', scope.$describedBy);\r\n        }\r\n\r\n        // remove pane from tab controller when pane is destroyed\r\n        scope.$on('$destroy', function () {\r\n          bsTabsCtrl.$remove(scope);\r\n        });\r\n\r\n        function render () {\r\n          var index = bsTabsCtrl.$panes.indexOf(scope);\r\n\r\n          $animate[bsTabsCtrl.$isActive(scope, index) ? 'addClass' : 'removeClass'](element, bsTabsCtrl.$options.activeClass);\r\n        }\r\n\r\n        bsTabsCtrl.$activePaneChangeListeners.push(function () {\r\n          render();\r\n        });\r\n        render();\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n\r\n// Source: timepicker\\timepicker.js\r\nangular.module('mgcrea.ngStrap.timepicker', ['mgcrea.ngStrap.helpers.dateParser', 'mgcrea.ngStrap.helpers.dateFormatter', 'mgcrea.ngStrap.tooltip'])\r\n\r\n  .provider('$timepicker', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      defaultDate: 'auto',\r\n      // uncommenting the following line will break backwards compatability\r\n      // prefixEvent: 'timepicker',\r\n      prefixClass: 'timepicker',\r\n      placement: 'bottom-left',\r\n      templateUrl: 'timepicker/timepicker.tpl.html',\r\n      trigger: 'focus',\r\n      container: false,\r\n      keyboard: true,\r\n      html: false,\r\n      delay: 0,\r\n      // lang: $locale.id,\r\n      useNative: true,\r\n      timeType: 'date',\r\n      timeFormat: 'shortTime',\r\n      timezone: null,\r\n      modelTimeFormat: null,\r\n      autoclose: false,\r\n      minTime: -Infinity,\r\n      maxTime: +Infinity,\r\n      length: 5,\r\n      hourStep: 1,\r\n      minuteStep: 5,\r\n      secondStep: 5,\r\n      roundDisplay: false,\r\n      iconUp: 'glyphicon glyphicon-chevron-up',\r\n      iconDown: 'glyphicon glyphicon-chevron-down',\r\n      arrowBehavior: 'pager'\r\n    };\r\n\r\n    this.$get = function ($window, $document, $rootScope, $sce, $dateFormatter, $tooltip, $timeout) {\r\n\r\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n      var isTouch = ('createTouch' in $window.document) && isNative;\r\n      if (!defaults.lang) {\r\n        defaults.lang = $dateFormatter.getDefaultLocale();\r\n      }\r\n\r\n      function timepickerFactory (element, controller, config) {\r\n\r\n        var $timepicker = $tooltip(element, angular.extend({}, defaults, config));\r\n        var parentScope = config.scope;\r\n        var options = $timepicker.$options;\r\n        var scope = $timepicker.$scope;\r\n\r\n        var lang = options.lang;\r\n        var formatDate = function (date, format, timezone) {\r\n          return $dateFormatter.formatDate(date, format, lang, timezone);\r\n        };\r\n\r\n        function floorMinutes (time) {\r\n          // coeff used to floor current time to nearest minuteStep interval\r\n          var coeff = 1000 * 60 * options.minuteStep;\r\n          return new Date(Math.floor(time.getTime() / coeff) * coeff);\r\n        }\r\n\r\n        // View vars\r\n\r\n        var selectedIndex = 0;\r\n        var defaultDate = options.roundDisplay ? floorMinutes(new Date()) : new Date();\r\n        var startDate = controller.$dateValue || defaultDate;\r\n        var viewDate = {\r\n          hour: startDate.getHours(),\r\n          meridian: startDate.getHours() < 12,\r\n          minute: startDate.getMinutes(),\r\n          second: startDate.getSeconds(),\r\n          millisecond: startDate.getMilliseconds()\r\n        };\r\n\r\n        var format = $dateFormatter.getDatetimeFormat(options.timeFormat, lang);\r\n\r\n        var hoursFormat = $dateFormatter.hoursFormat(format);\r\n        var timeSeparator = $dateFormatter.timeSeparator(format);\r\n        var minutesFormat = $dateFormatter.minutesFormat(format);\r\n        var secondsFormat = $dateFormatter.secondsFormat(format);\r\n        var showSeconds = $dateFormatter.showSeconds(format);\r\n        var showAM = $dateFormatter.showAM(format);\r\n\r\n        scope.$iconUp = options.iconUp;\r\n        scope.$iconDown = options.iconDown;\r\n\r\n        // Scope methods\r\n\r\n        scope.$select = function (date, index) {\r\n          $timepicker.select(date, index);\r\n        };\r\n        scope.$moveIndex = function (value, index) {\r\n          $timepicker.$moveIndex(value, index);\r\n        };\r\n        scope.$switchMeridian = function (date) {\r\n          $timepicker.switchMeridian(date);\r\n        };\r\n\r\n        // Public methods\r\n\r\n        $timepicker.update = function (date) {\r\n          // console.warn('$timepicker.update() newValue=%o', date);\r\n          if (angular.isDate(date) && !isNaN(date.getTime())) {\r\n            $timepicker.$date = date;\r\n            angular.extend(viewDate, {\r\n              hour: date.getHours(),\r\n              minute: date.getMinutes(),\r\n              second: date.getSeconds(),\r\n              millisecond: date.getMilliseconds()\r\n            });\r\n            $timepicker.$build();\r\n          } else if (!$timepicker.$isBuilt) {\r\n            $timepicker.$build();\r\n          }\r\n        };\r\n\r\n        $timepicker.select = function (date, index, keep) {\r\n          // console.warn('$timepicker.select', date, scope.$mode);\r\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\r\n            controller.$dateValue = options.defaultDate === 'today' ? new Date() : new Date(1970, 0, 1);\r\n          }\r\n\r\n          if (!angular.isDate(date)) date = new Date(date);\r\n          if (index === 0) controller.$dateValue.setHours(date.getHours());\r\n          else if (index === 1) controller.$dateValue.setMinutes(date.getMinutes());\r\n          else if (index === 2) controller.$dateValue.setSeconds(date.getSeconds());\r\n          controller.$setViewValue(angular.copy(controller.$dateValue));\r\n          controller.$render();\r\n          if (options.autoclose && !keep) {\r\n            $timeout(function () {\r\n              $timepicker.hide(true);\r\n            });\r\n          }\r\n        };\r\n\r\n        $timepicker.switchMeridian = function (date) {\r\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\r\n            return;\r\n          }\r\n          var hours = (date || controller.$dateValue).getHours();\r\n          controller.$dateValue.setHours(hours < 12 ? hours + 12 : hours - 12);\r\n          controller.$setViewValue(angular.copy(controller.$dateValue));\r\n          controller.$render();\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $timepicker.$build = function () {\r\n          // console.warn('$timepicker.$build() viewDate=%o', viewDate);\r\n          var i;\r\n          var midIndex = scope.midIndex = parseInt(options.length / 2, 10);\r\n          var hours = [];\r\n          var hour;\r\n          for (i = 0; i < options.length; i++) {\r\n            hour = new Date(1970, 0, 1, viewDate.hour - (midIndex - i) * options.hourStep);\r\n            hours.push({\r\n              date: hour,\r\n              label: formatDate(hour, hoursFormat),\r\n              selected: $timepicker.$date && $timepicker.$isSelected(hour, 0),\r\n              disabled: $timepicker.$isDisabled(hour, 0)\r\n            });\r\n          }\r\n          var minutes = [];\r\n          var minute;\r\n          for (i = 0; i < options.length; i++) {\r\n            minute = new Date(1970, 0, 1, 0, viewDate.minute - (midIndex - i) * options.minuteStep);\r\n            minutes.push({\r\n              date: minute,\r\n              label: formatDate(minute, minutesFormat),\r\n              selected: $timepicker.$date && $timepicker.$isSelected(minute, 1),\r\n              disabled: $timepicker.$isDisabled(minute, 1)\r\n            });\r\n          }\r\n          var seconds = [];\r\n          var second;\r\n          for (i = 0; i < options.length; i++) {\r\n            second = new Date(1970, 0, 1, 0, 0, viewDate.second - (midIndex - i) * options.secondStep);\r\n            seconds.push({\r\n              date: second,\r\n              label: formatDate(second, secondsFormat),\r\n              selected: $timepicker.$date && $timepicker.$isSelected(second, 2),\r\n              disabled: $timepicker.$isDisabled(second, 2)\r\n            });\r\n          }\r\n\r\n          var rows = [];\r\n          for (i = 0; i < options.length; i++) {\r\n            if (showSeconds) {\r\n              rows.push([hours[i], minutes[i], seconds[i]]);\r\n            } else {\r\n              rows.push([hours[i], minutes[i]]);\r\n            }\r\n          }\r\n          scope.rows = rows;\r\n          scope.showSeconds = showSeconds;\r\n          scope.showAM = showAM;\r\n          scope.isAM = ($timepicker.$date || hours[midIndex].date).getHours() < 12;\r\n          scope.timeSeparator = timeSeparator;\r\n          $timepicker.$isBuilt = true;\r\n        };\r\n\r\n        $timepicker.$isSelected = function (date, index) {\r\n          if (!$timepicker.$date) return false;\r\n          else if (index === 0) {\r\n            return date.getHours() === $timepicker.$date.getHours();\r\n          } else if (index === 1) {\r\n            return date.getMinutes() === $timepicker.$date.getMinutes();\r\n          } else if (index === 2) {\r\n            return date.getSeconds() === $timepicker.$date.getSeconds();\r\n          }\r\n        };\r\n\r\n        $timepicker.$isDisabled = function (date, index) {\r\n          var selectedTime;\r\n          if (index === 0) {\r\n            selectedTime = date.getTime() + viewDate.minute * 6e4 + viewDate.second * 1e3;\r\n          } else if (index === 1) {\r\n            selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.second * 1e3;\r\n          } else if (index === 2) {\r\n            selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.minute * 6e4;\r\n          }\r\n          return selectedTime < options.minTime * 1 || selectedTime > options.maxTime * 1;\r\n        };\r\n\r\n        scope.$arrowAction = function (value, index) {\r\n          if (options.arrowBehavior === 'picker') {\r\n            $timepicker.$setTimeByStep(value, index);\r\n          } else {\r\n            $timepicker.$moveIndex(value, index);\r\n          }\r\n        };\r\n\r\n        $timepicker.$setTimeByStep = function (value, index) {\r\n          var newDate = new Date($timepicker.$date || startDate);\r\n          var hours = newDate.getHours();\r\n          var minutes = newDate.getMinutes();\r\n          var seconds = newDate.getSeconds();\r\n          if (index === 0) {\r\n            newDate.setHours(hours - (parseInt(options.hourStep, 10) * value));\r\n          } else if (index === 1) {\r\n            newDate.setMinutes(minutes - (parseInt(options.minuteStep, 10) * value));\r\n          } else if (index === 2) {\r\n            newDate.setSeconds(seconds - (parseInt(options.secondStep, 10) * value));\r\n          }\r\n          $timepicker.select(newDate, index, true);\r\n        };\r\n\r\n        $timepicker.$moveIndex = function (value, index) {\r\n          var targetDate;\r\n          if (index === 0) {\r\n            targetDate = new Date(1970, 0, 1, viewDate.hour + (value * options.length), viewDate.minute, viewDate.second);\r\n            angular.extend(viewDate, {\r\n              hour: targetDate.getHours()\r\n            });\r\n          } else if (index === 1) {\r\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute + (value * options.length * options.minuteStep), viewDate.second);\r\n            angular.extend(viewDate, {\r\n              minute: targetDate.getMinutes()\r\n            });\r\n          } else if (index === 2) {\r\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute, viewDate.second + (value * options.length * options.secondStep));\r\n            angular.extend(viewDate, {\r\n              second: targetDate.getSeconds()\r\n            });\r\n          }\r\n          $timepicker.$build();\r\n        };\r\n\r\n        $timepicker.$onMouseDown = function (evt) {\r\n          // Prevent blur on mousedown on .dropdown-menu\r\n          if (evt.target.nodeName.toLowerCase() !== 'input') evt.preventDefault();\r\n          evt.stopPropagation();\r\n          // Emulate click for mobile devices\r\n          if (isTouch) {\r\n            var targetEl = angular.element(evt.target);\r\n            if (targetEl[0].nodeName.toLowerCase() !== 'button') {\r\n              targetEl = targetEl.parent();\r\n            }\r\n            targetEl.triggerHandler('click');\r\n          }\r\n        };\r\n\r\n        $timepicker.$onKeyDown = function (evt) {\r\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n\r\n          // Close on enter\r\n          if (evt.keyCode === 13) {\r\n            $timepicker.hide(true);\r\n            return;\r\n          }\r\n\r\n          // Navigate with keyboard\r\n          var newDate = new Date($timepicker.$date);\r\n          var hours = newDate.getHours();\r\n          var hoursLength = formatDate(newDate, hoursFormat).length;\r\n          var minutes = newDate.getMinutes();\r\n          var minutesLength = formatDate(newDate, minutesFormat).length;\r\n          var seconds = newDate.getSeconds();\r\n          var secondsLength = formatDate(newDate, secondsFormat).length;\r\n          var sepLength = 1;\r\n          var lateralMove = /(37|39)/.test(evt.keyCode);\r\n          var count = 2 + showSeconds * 1 + showAM * 1;\r\n\r\n          // Navigate indexes (left, right)\r\n          if (lateralMove) {\r\n            if (evt.keyCode === 37) selectedIndex = selectedIndex < 1 ? count - 1 : selectedIndex - 1;\r\n            else if (evt.keyCode === 39) selectedIndex = selectedIndex < count - 1 ? selectedIndex + 1 : 0;\r\n          }\r\n\r\n          // Update values (up, down)\r\n          var selectRange = [0, hoursLength];\r\n          var incr = 0;\r\n          if (evt.keyCode === 38) incr = -1;\r\n          if (evt.keyCode === 40) incr = +1;\r\n          var isSeconds = selectedIndex === 2 && showSeconds;\r\n          var isMeridian = selectedIndex === 2 && !showSeconds || selectedIndex === 3 && showSeconds;\r\n          if (selectedIndex === 0) {\r\n            newDate.setHours(hours + incr * parseInt(options.hourStep, 10));\r\n            // re-calculate hours length because we have changed hours value\r\n            hoursLength = formatDate(newDate, hoursFormat).length;\r\n            selectRange = [0, hoursLength];\r\n          } else if (selectedIndex === 1) {\r\n            newDate.setMinutes(minutes + incr * parseInt(options.minuteStep, 10));\r\n            // re-calculate minutes length because we have changes minutes value\r\n            minutesLength = formatDate(newDate, minutesFormat).length;\r\n            selectRange = [hoursLength + sepLength, minutesLength];\r\n          } else if (isSeconds) {\r\n            newDate.setSeconds(seconds + incr * parseInt(options.secondStep, 10));\r\n            // re-calculate seconds length because we have changes seconds value\r\n            secondsLength = formatDate(newDate, secondsFormat).length;\r\n            selectRange = [hoursLength + sepLength + minutesLength + sepLength, secondsLength];\r\n          } else if (isMeridian) {\r\n            if (!lateralMove) $timepicker.switchMeridian();\r\n            selectRange = [hoursLength + sepLength + minutesLength + sepLength + (secondsLength + sepLength) * showSeconds, 2];\r\n          }\r\n          $timepicker.select(newDate, selectedIndex, true);\r\n          createSelection(selectRange[0], selectRange[1]);\r\n          parentScope.$digest();\r\n        };\r\n\r\n        // Private\r\n\r\n        function createSelection (start, length) {\r\n          var end = start + length;\r\n          if (element[0].createTextRange) {\r\n            var selRange = element[0].createTextRange();\r\n            selRange.collapse(true);\r\n            selRange.moveStart('character', start);\r\n            selRange.moveEnd('character', end);\r\n            selRange.select();\r\n          } else if (element[0].setSelectionRange) {\r\n            element[0].setSelectionRange(start, end);\r\n          } else if (angular.isUndefined(element[0].selectionStart)) {\r\n            element[0].selectionStart = start;\r\n            element[0].selectionEnd = end;\r\n          }\r\n        }\r\n\r\n        function focusElement () {\r\n          element[0].focus();\r\n        }\r\n\r\n        // Overrides\r\n\r\n        var _init = $timepicker.init;\r\n        $timepicker.init = function () {\r\n          if (isNative && options.useNative) {\r\n            element.prop('type', 'time');\r\n            element.css('-webkit-appearance', 'textfield');\r\n            return;\r\n          } else if (isTouch) {\r\n            element.prop('type', 'text');\r\n            element.attr('readonly', 'true');\r\n            element.on('click', focusElement);\r\n          }\r\n          _init();\r\n        };\r\n\r\n        var _destroy = $timepicker.destroy;\r\n        $timepicker.destroy = function () {\r\n          if (isNative && options.useNative) {\r\n            element.off('click', focusElement);\r\n          }\r\n          _destroy();\r\n        };\r\n\r\n        var _show = $timepicker.show;\r\n        $timepicker.show = function () {\r\n          if ((!isTouch && element.attr('readonly')) || element.attr('disabled')) return;\r\n          _show();\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed imediately.\r\n          $timeout(function () {\r\n            if ($timepicker.$element) $timepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\r\n            if (options.keyboard) {\r\n              if (element) element.on('keydown', $timepicker.$onKeyDown);\r\n            }\r\n          }, 0, false);\r\n        };\r\n\r\n        var _hide = $timepicker.hide;\r\n        $timepicker.hide = function (blur) {\r\n          if (!$timepicker.$isShown) return;\r\n          if ($timepicker.$element) $timepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\r\n          if (options.keyboard) {\r\n            if (element) element.off('keydown', $timepicker.$onKeyDown);\r\n          }\r\n          _hide(blur);\r\n        };\r\n\r\n        return $timepicker;\r\n\r\n      }\r\n\r\n      timepickerFactory.defaults = defaults;\r\n      return timepickerFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n\r\n  .directive('bsTimepicker', function ($window, $parse, $q, $dateFormatter, $dateParser, $timepicker) {\r\n\r\n    var defaults = $timepicker.defaults;\r\n    var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        // Directive options\r\n        var options = {\r\n          scope: scope\r\n        };\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'autoclose', 'timeType', 'timeFormat', 'timezone', 'modelTimeFormat', 'useNative', 'hourStep', 'minuteStep', 'secondStep', 'length', 'arrowBehavior', 'iconUp', 'iconDown', 'roundDisplay', 'id', 'prefixClass', 'prefixEvent', 'defaultDate'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container', 'autoclose', 'useNative', 'roundDisplay'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\r\n            options[key] = false;\r\n          }\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Initialize timepicker\r\n        if (isNative && (options.useNative || defaults.useNative)) options.timeFormat = 'HH:mm';\r\n        var timepicker = $timepicker(element, controller, options);\r\n        options = timepicker.$options;\r\n\r\n        var lang = options.lang;\r\n        var formatDate = function (date, format, timezone) {\r\n          return $dateFormatter.formatDate(date, format, lang, timezone);\r\n        };\r\n\r\n        // Visibility binding support\r\n        if (attr.bsShow) {\r\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\r\n            if (!timepicker || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(timepicker),?/i);\r\n            if (newValue === true) {\r\n              timepicker.show();\r\n            } else {\r\n              timepicker.hide();\r\n            }\r\n          });\r\n        }\r\n\r\n        // Initialize parser\r\n        var dateParser = $dateParser({\r\n          format: options.timeFormat,\r\n          lang: lang\r\n        });\r\n\r\n        // Observe attributes for changes\r\n        angular.forEach(['minTime', 'maxTime'], function (key) {\r\n          // console.warn('attr.$observe(%s)', key, attr[key]);\r\n          if (angular.isDefined(attr[key])) {\r\n            attr.$observe(key, function (newValue) {\r\n              timepicker.$options[key] = dateParser.getTimeForAttribute(key, newValue);\r\n              if (!isNaN(timepicker.$options[key])) timepicker.$build();\r\n              validateAgainstMinMaxTime(controller.$dateValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Watch model for changes\r\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\r\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue, controller.$dateValue);\r\n          timepicker.update(controller.$dateValue);\r\n        }, true);\r\n\r\n        function validateAgainstMinMaxTime (parsedTime) {\r\n          if (!angular.isDate(parsedTime)) return;\r\n          var isMinValid = isNaN(options.minTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) >= options.minTime;\r\n          var isMaxValid = isNaN(options.maxTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) <= options.maxTime;\r\n          var isValid = isMinValid && isMaxValid;\r\n          controller.$setValidity('date', isValid);\r\n          controller.$setValidity('min', isMinValid);\r\n          controller.$setValidity('max', isMaxValid);\r\n          // Only update the model when we have a valid date\r\n          if (!isValid) {\r\n            return;\r\n          }\r\n          controller.$dateValue = parsedTime;\r\n        }\r\n\r\n        // viewValue -> $parsers -> modelValue\r\n        controller.$parsers.unshift(function (viewValue) {\r\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\r\n          var date;\r\n          // Null values should correctly reset the model value & validity\r\n          if (!viewValue) {\r\n            // BREAKING CHANGE:\r\n            // return null (not undefined) when input value is empty, so angularjs 1.3\r\n            // ngModelController can go ahead and run validators, like ngRequired\r\n            controller.$setValidity('date', true);\r\n            return null;\r\n          }\r\n          var parsedTime = angular.isDate(viewValue) ? viewValue : dateParser.parse(viewValue, controller.$dateValue);\r\n          if (!parsedTime || isNaN(parsedTime.getTime())) {\r\n            controller.$setValidity('date', false);\r\n            // Return undefined, causes ngModelController to\r\n            // invalidate model value\r\n            return undefined;\r\n          }\r\n          validateAgainstMinMaxTime(parsedTime);\r\n\r\n          if (options.timeType === 'string') {\r\n            date = dateParser.timezoneOffsetAdjust(parsedTime, options.timezone, true);\r\n            return formatDate(date, options.modelTimeFormat || options.timeFormat);\r\n          }\r\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\r\n          if (options.timeType === 'number') {\r\n            return date.getTime();\r\n          } else if (options.timeType === 'unix') {\r\n            return date.getTime() / 1000;\r\n          } else if (options.timeType === 'iso') {\r\n            return date.toISOString();\r\n          }\r\n          return new Date(date);\r\n        });\r\n\r\n        // modelValue -> $formatters -> viewValue\r\n        controller.$formatters.push(function (modelValue) {\r\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n          var date;\r\n          if (angular.isUndefined(modelValue) || modelValue === null) {\r\n            date = NaN;\r\n          } else if (angular.isDate(modelValue)) {\r\n            date = modelValue;\r\n          } else if (options.timeType === 'string') {\r\n            date = dateParser.parse(modelValue, null, options.modelTimeFormat);\r\n          } else if (options.timeType === 'unix') {\r\n            date = new Date(modelValue * 1000);\r\n          } else {\r\n            date = new Date(modelValue);\r\n          }\r\n          // Setup default value?\r\n          // if(isNaN(date.getTime())) date = new Date(new Date().setMinutes(0) + 36e5);\r\n          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\r\n          return getTimeFormattedString();\r\n        });\r\n\r\n        // viewValue -> element\r\n        controller.$render = function () {\r\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\r\n          element.val(getTimeFormattedString());\r\n        };\r\n\r\n        function getTimeFormattedString () {\r\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.timeFormat);\r\n        }\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (timepicker) timepicker.destroy();\r\n          options = null;\r\n          timepicker = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n\r\n// Source: select\\select.js\r\nangular.module('mgcrea.ngStrap.select', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\r\n\r\n  .provider('$select', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      prefixClass: 'select',\r\n      prefixEvent: '$select',\r\n      placement: 'bottom-left',\r\n      templateUrl: 'select/select.tpl.html',\r\n      trigger: 'focus',\r\n      container: false,\r\n      keyboard: true,\r\n      html: false,\r\n      delay: 0,\r\n      multiple: false,\r\n      allNoneButtons: false,\r\n      sort: true,\r\n      caretHtml: '&nbsp;<span class=\"caret\"></span>',\r\n      placeholder: 'Choose among the following...',\r\n      allText: 'All',\r\n      noneText: 'None',\r\n      maxLength: 3,\r\n      maxLengthHtml: 'selected',\r\n      iconCheckmark: 'glyphicon glyphicon-ok',\r\n      toggle: false\r\n    };\r\n\r\n    this.$get = function ($window, $document, $rootScope, $tooltip, $timeout) {\r\n\r\n      // var bodyEl = angular.element($window.document.body);\r\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n      var isTouch = ('createTouch' in $window.document) && isNative;\r\n\r\n      function SelectFactory (element, controller, config) {\r\n\r\n        var $select = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n\r\n        $select = $tooltip(element, options);\r\n        var scope = $select.$scope;\r\n\r\n        scope.$matches = [];\r\n        if (options.multiple) {\r\n          scope.$activeIndex = [];\r\n        } else {\r\n          scope.$activeIndex = -1;\r\n        }\r\n        scope.$isMultiple = options.multiple;\r\n        scope.$showAllNoneButtons = options.allNoneButtons && options.multiple;\r\n        scope.$iconCheckmark = options.iconCheckmark;\r\n        scope.$allText = options.allText;\r\n        scope.$noneText = options.noneText;\r\n\r\n        scope.$activate = function (index) {\r\n          scope.$$postDigest(function () {\r\n            $select.activate(index);\r\n          });\r\n        };\r\n\r\n        scope.$select = function (index, evt) {\r\n          scope.$$postDigest(function () {\r\n            $select.select(index);\r\n          });\r\n        };\r\n\r\n        scope.$isVisible = function () {\r\n          return $select.$isVisible();\r\n        };\r\n\r\n        scope.$isActive = function (index) {\r\n          return $select.$isActive(index);\r\n        };\r\n\r\n        scope.$selectAll = function () {\r\n          for (var i = 0; i < scope.$matches.length; i++) {\r\n            if (!scope.$isActive(i)) {\r\n              scope.$select(i);\r\n            }\r\n          }\r\n        };\r\n\r\n        scope.$selectNone = function () {\r\n          for (var i = 0; i < scope.$matches.length; i++) {\r\n            if (scope.$isActive(i)) {\r\n              scope.$select(i);\r\n            }\r\n          }\r\n        };\r\n\r\n        // Public methods\r\n\r\n        $select.update = function (matches) {\r\n          scope.$matches = matches;\r\n          $select.$updateActiveIndex();\r\n        };\r\n\r\n        $select.activate = function (index) {\r\n          if (options.multiple) {\r\n            if ($select.$isActive(index)) {\r\n              scope.$activeIndex.splice(scope.$activeIndex.indexOf(index), 1);\r\n            } else {\r\n              scope.$activeIndex.push(index);\r\n            }\r\n            if (options.sort) scope.$activeIndex.sort(function (a, b) { return a - b; }); // use numeric sort instead of default sort\r\n          } else {\r\n            scope.$activeIndex = index;\r\n          }\r\n          return scope.$activeIndex;\r\n        };\r\n\r\n        $select.select = function (index) {\r\n          if (angular.isUndefined(index) || index < 0 || index >= scope.$matches.length) { return; }\r\n          var value = scope.$matches[index].value;\r\n          scope.$apply(function () {\r\n            $select.activate(index);\r\n            if (options.multiple) {\r\n              controller.$setViewValue(scope.$activeIndex.map(function (index) {\r\n                if (angular.isUndefined(scope.$matches[index])) {\r\n                  return null;\r\n                }\r\n                return scope.$matches[index].value;\r\n              }));\r\n            } else {\r\n              if (options.toggle) {\r\n                controller.$setViewValue((value === controller.$modelValue) ? undefined : value);\r\n              } else {\r\n                controller.$setViewValue(value);\r\n              }\r\n              // Hide if single select\r\n              $select.hide();\r\n            }\r\n          });\r\n          // Emit event\r\n          scope.$emit(options.prefixEvent + '.select', value, index, $select);\r\n          if (angular.isDefined(options.onSelect) && angular.isFunction(options.onSelect)) {\r\n            options.onSelect(value, index, $select);\r\n          }\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $select.$updateActiveIndex = function () {\r\n          if (options.multiple) {\r\n            if (angular.isArray(controller.$modelValue)) {\r\n              scope.$activeIndex = controller.$modelValue.map(function (value) {\r\n                return $select.$getIndex(value);\r\n              });\r\n            } else {\r\n              scope.$activeIndex = [];\r\n            }\r\n          } else {\r\n            if (angular.isDefined(controller.$modelValue) && scope.$matches.length) {\r\n              scope.$activeIndex = $select.$getIndex(controller.$modelValue);\r\n            } else {\r\n              scope.$activeIndex = -1;\r\n            }\r\n          }\r\n        };\r\n\r\n        $select.$isVisible = function () {\r\n          if (!options.minLength || !controller) {\r\n            return scope.$matches.length;\r\n          }\r\n          // minLength support\r\n          return scope.$matches.length && controller.$viewValue.length >= options.minLength;\r\n        };\r\n\r\n        $select.$isActive = function (index) {\r\n          if (options.multiple) {\r\n            return scope.$activeIndex.indexOf(index) !== -1;\r\n          }\r\n          return scope.$activeIndex === index;\r\n        };\r\n\r\n        $select.$getIndex = function (value) {\r\n          var index;\r\n          for (index = scope.$matches.length; index--;) {\r\n            if (angular.equals(scope.$matches[index].value, value)) break;\r\n          }\r\n          return index;\r\n        };\r\n\r\n        $select.$onMouseDown = function (evt) {\r\n          // Prevent blur on mousedown on .dropdown-menu\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n          // Emulate click for mobile devices\r\n          if (isTouch) {\r\n            var targetEl = angular.element(evt.target);\r\n            var anchor;\r\n\r\n            if (evt.target.nodeName !== 'A') {\r\n              var anchorCandidate = targetEl.parent();\r\n              while (!anchor && anchorCandidate.length > 0) {\r\n                if (anchorCandidate[0].nodeName === 'A') {\r\n                  anchor = anchorCandidate;\r\n                }\r\n                anchorCandidate = anchorCandidate.parent();\r\n              }\r\n            }\r\n\r\n            if (anchor) {\r\n              angular.element(anchor).triggerHandler('click');\r\n            } else {\r\n              targetEl.triggerHandler('click');\r\n            }\r\n          }\r\n        };\r\n\r\n        $select.$onKeyDown = function (evt) {\r\n          if (!/(9|13|38|40)/.test(evt.keyCode)) return;\r\n          // Let tab propagate\r\n          if (evt.keyCode !== 9) {\r\n            evt.preventDefault();\r\n            evt.stopPropagation();\r\n          }\r\n\r\n          // release focus on tab\r\n          if (options.multiple && evt.keyCode === 9) {\r\n            return $select.hide();\r\n          }\r\n\r\n          // Select with enter\r\n          if (!options.multiple && (evt.keyCode === 13 || evt.keyCode === 9)) {\r\n            return $select.select(scope.$activeIndex);\r\n          }\r\n\r\n          if (!options.multiple) {\r\n            // Navigate with keyboard\r\n            if (evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;\r\n            else if (evt.keyCode === 38 && scope.$activeIndex < 0) scope.$activeIndex = scope.$matches.length - 1;\r\n            else if (evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;\r\n            else if (angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;\r\n            scope.$digest();\r\n          }\r\n        };\r\n\r\n        $select.$isIE = function () {\r\n          var ua = $window.navigator.userAgent;\r\n          return ua.indexOf('MSIE ') > 0 || ua.indexOf('Trident/') > 0 || ua.indexOf('Edge/') > 0;\r\n        };\r\n\r\n        $select.$selectScrollFix = function (e) {\r\n          if ($document[0].activeElement.tagName === 'UL') {\r\n            e.preventDefault();\r\n            e.stopImmediatePropagation();\r\n            e.target.focus();\r\n          }\r\n        };\r\n\r\n        // Overrides\r\n\r\n        var _show = $select.show;\r\n        $select.show = function () {\r\n          _show();\r\n          if (options.multiple) {\r\n            $select.$element.addClass('select-multiple');\r\n          }\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed imediately.\r\n          $timeout(function () {\r\n            $select.$element.on(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\r\n            if (options.keyboard) {\r\n              element.on('keydown', $select.$onKeyDown);\r\n            }\r\n          }, 0, false);\r\n        };\r\n\r\n        var _hide = $select.hide;\r\n        $select.hide = function () {\r\n          if (!options.multiple && angular.isUndefined(controller.$modelValue)) {\r\n            scope.$activeIndex = -1;\r\n          }\r\n          $select.$element.off(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\r\n          if (options.keyboard) {\r\n            element.off('keydown', $select.$onKeyDown);\r\n          }\r\n          _hide(true);\r\n        };\r\n\r\n        return $select;\r\n\r\n      }\r\n\r\n      SelectFactory.defaults = defaults;\r\n      return SelectFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsSelect', function ($window, $parse, $q, $select, $parseOptions) {\r\n\r\n    var defaults = $select.defaults;\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        // Directive options\r\n        var options = {scope: scope, placeholder: defaults.placeholder};\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'placeholder', 'allNoneButtons', 'maxLength', 'maxLengthHtml', 'allText', 'noneText', 'iconCheckmark', 'autoClose', 'id', 'sort', 'caretHtml', 'prefixClass', 'prefixEvent', 'toggle'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container', 'allNoneButtons', 'sort'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\r\n            options[key] = false;\r\n          }\r\n        });\r\n\r\n        // bind functions from the attrs to the show, hide and select events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide', 'onSelect'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Only parse data-multiple. Angular sets existence attributes to true (multiple/required/etc), they apply this\r\n        // to data-multiple as well for some reason, so we'll parse this ourselves and disregard multiple\r\n        var dataMultiple = element.attr('data-multiple');\r\n        if (angular.isDefined(dataMultiple)) {\r\n          if (falseValueRegExp.test(dataMultiple)) {\r\n            options.multiple = false;\r\n          } else {\r\n            options.multiple = dataMultiple;\r\n          }\r\n        }\r\n\r\n        // Add support for select markup\r\n        if (element[0].nodeName.toLowerCase() === 'select') {\r\n          var inputEl = element;\r\n          inputEl.css('display', 'none');\r\n          element = angular.element('<button type=\"button\" class=\"btn btn-default\" aria-haspopup=\"true\"></button>');\r\n          inputEl.after(element);\r\n        }\r\n\r\n        // Build proper bsOptions\r\n        var parsedOptions = $parseOptions(attr.bsOptions);\r\n\r\n        // Initialize select\r\n        var select = $select(element, controller, options);\r\n\r\n        if (select.$isIE()) {\r\n          element[0].addEventListener('blur', select.$selectScrollFix);\r\n        }\r\n\r\n        // Watch bsOptions values before filtering for changes\r\n        var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').trim();\r\n        scope.$watch(watchedOptions, function (newValue, oldValue) {\r\n          // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\r\n          parsedOptions.valuesFn(scope, controller)\r\n          .then(function (values) {\r\n            select.update(values);\r\n            controller.$render();\r\n          });\r\n        }, true);\r\n\r\n        // Watch model for changes\r\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\r\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue);\r\n          select.$updateActiveIndex();\r\n          controller.$render();\r\n        }, true);\r\n\r\n        // Model rendering in view\r\n        controller.$render = function () {\r\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\r\n          var selected;\r\n          var index;\r\n          if (options.multiple && angular.isArray(controller.$modelValue)) {\r\n            selected = controller.$modelValue.map(function (value) {\r\n              index = select.$getIndex(value);\r\n              return index !== -1 ? select.$scope.$matches[index].label : false;\r\n            }).filter(angular.isDefined);\r\n            if (selected.length > (options.maxLength || defaults.maxLength)) {\r\n              selected = selected.length + ' ' + (options.maxLengthHtml || defaults.maxLengthHtml);\r\n            } else {\r\n              selected = selected.join(', ');\r\n            }\r\n          } else {\r\n            index = select.$getIndex(controller.$modelValue);\r\n            selected = index !== -1 ? select.$scope.$matches[index].label : false;\r\n          }\r\n          element.html((selected || options.placeholder) + (options.caretHtml || defaults.caretHtml));\r\n        };\r\n\r\n        if (options.multiple) {\r\n          controller.$isEmpty = function (value) {\r\n            return !value || value.length === 0;\r\n          };\r\n        }\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (select) select.destroy();\r\n          options = null;\r\n          select = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n\r\n// Source: scrollspy\\scrollspy.js\r\nangular.module('mgcrea.ngStrap.scrollspy', ['mgcrea.ngStrap.helpers.debounce', 'mgcrea.ngStrap.helpers.dimensions'])\r\n\r\n  .provider('$scrollspy', function () {\r\n\r\n    // Pool of registered spies\r\n    var spies = this.$$spies = {};\r\n\r\n    var defaults = this.defaults = {\r\n      debounce: 150,\r\n      throttle: 100,\r\n      offset: 100\r\n    };\r\n\r\n    this.$get = function ($window, $document, $rootScope, dimensions, debounce, throttle) {\r\n\r\n      var windowEl = angular.element($window);\r\n      var docEl = angular.element($document.prop('documentElement'));\r\n      var bodyEl = angular.element($window.document.body);\r\n\r\n      // Helper functions\r\n\r\n      function nodeName (element, name) {\r\n        return element[0].nodeName && element[0].nodeName.toLowerCase() === name.toLowerCase();\r\n      }\r\n\r\n      function ScrollSpyFactory (config) {\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n        if (!options.element) options.element = bodyEl;\r\n        var isWindowSpy = nodeName(options.element, 'body');\r\n        var scrollEl = isWindowSpy ? windowEl : options.element;\r\n        var scrollId = isWindowSpy ? 'window' : options.id;\r\n\r\n        // Use existing spy\r\n        if (spies[scrollId]) {\r\n          spies[scrollId].$$count++;\r\n          return spies[scrollId];\r\n        }\r\n\r\n        var $scrollspy = {};\r\n\r\n        // Private vars\r\n        var unbindViewContentLoaded;\r\n        var unbindIncludeContentLoaded;\r\n        var trackedElements = $scrollspy.$trackedElements = [];\r\n        var sortedElements = [];\r\n        var activeTarget;\r\n        var debouncedCheckPosition;\r\n        var throttledCheckPosition;\r\n        var debouncedCheckOffsets;\r\n        /* eslint-disable no-unused-vars */\r\n        var viewportHeight;\r\n        /* eslint-enable no-unused-vars */\r\n        var scrollTop;\r\n\r\n        $scrollspy.init = function () {\r\n\r\n          // Setup internal ref counter\r\n          this.$$count = 1;\r\n\r\n          // Bind events\r\n          debouncedCheckPosition = debounce(this.checkPosition, options.debounce);\r\n          throttledCheckPosition = throttle(this.checkPosition, options.throttle);\r\n          scrollEl.on('click', this.checkPositionWithEventLoop);\r\n          windowEl.on('resize', debouncedCheckPosition);\r\n          scrollEl.on('scroll', throttledCheckPosition);\r\n\r\n          debouncedCheckOffsets = debounce(this.checkOffsets, options.debounce);\r\n          unbindViewContentLoaded = $rootScope.$on('$viewContentLoaded', debouncedCheckOffsets);\r\n          unbindIncludeContentLoaded = $rootScope.$on('$includeContentLoaded', debouncedCheckOffsets);\r\n          debouncedCheckOffsets();\r\n\r\n          // Register spy for reuse\r\n          if (scrollId) {\r\n            spies[scrollId] = $scrollspy;\r\n          }\r\n\r\n        };\r\n\r\n        $scrollspy.destroy = function () {\r\n\r\n          // Check internal ref counter\r\n          this.$$count--;\r\n          if (this.$$count > 0) {\r\n            return;\r\n          }\r\n\r\n          // Unbind events\r\n          scrollEl.off('click', this.checkPositionWithEventLoop);\r\n          windowEl.off('resize', debouncedCheckPosition);\r\n          scrollEl.off('scroll', throttledCheckPosition);\r\n          unbindViewContentLoaded();\r\n          unbindIncludeContentLoaded();\r\n          if (scrollId) {\r\n            delete spies[scrollId];\r\n          }\r\n        };\r\n\r\n        $scrollspy.checkPosition = function () {\r\n\r\n          // Not ready yet\r\n          if (!sortedElements.length) return;\r\n\r\n          // Calculate the scroll position\r\n          scrollTop = (isWindowSpy ? $window.pageYOffset : scrollEl.prop('scrollTop')) || 0;\r\n\r\n          // Calculate the viewport height for use by the components\r\n          viewportHeight = Math.max($window.innerHeight, docEl.prop('clientHeight'));\r\n\r\n          // Activate first element if scroll is smaller\r\n          if (scrollTop < sortedElements[0].offsetTop && activeTarget !== sortedElements[0].target) {\r\n            return $scrollspy.$activateElement(sortedElements[0]);\r\n          }\r\n\r\n          // Activate proper element\r\n          for (var i = sortedElements.length; i--;) {\r\n            if (angular.isUndefined(sortedElements[i].offsetTop) || sortedElements[i].offsetTop === null) continue;\r\n            if (activeTarget === sortedElements[i].target) continue;\r\n            if (scrollTop < sortedElements[i].offsetTop) continue;\r\n            if (sortedElements[i + 1] && scrollTop > sortedElements[i + 1].offsetTop) continue;\r\n            return $scrollspy.$activateElement(sortedElements[i]);\r\n          }\r\n\r\n        };\r\n\r\n        $scrollspy.checkPositionWithEventLoop = function () {\r\n          // IE 9 throws an error if we use 'this' instead of '$scrollspy'\r\n          // in this setTimeout call\r\n          setTimeout($scrollspy.checkPosition, 1);\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $scrollspy.$activateElement = function (element) {\r\n          if (activeTarget) {\r\n            var activeElement = $scrollspy.$getTrackedElement(activeTarget);\r\n            if (activeElement) {\r\n              activeElement.source.removeClass('active');\r\n              if (nodeName(activeElement.source, 'li') && nodeName(activeElement.source.parent().parent(), 'li')) {\r\n                activeElement.source.parent().parent().removeClass('active');\r\n              }\r\n            }\r\n          }\r\n          activeTarget = element.target;\r\n          element.source.addClass('active');\r\n          if (nodeName(element.source, 'li') && nodeName(element.source.parent().parent(), 'li')) {\r\n            element.source.parent().parent().addClass('active');\r\n          }\r\n        };\r\n\r\n        $scrollspy.$getTrackedElement = function (target) {\r\n          return trackedElements.filter(function (obj) {\r\n            return obj.target === target;\r\n          })[0];\r\n        };\r\n\r\n        // Track offsets behavior\r\n\r\n        $scrollspy.checkOffsets = function () {\r\n\r\n          angular.forEach(trackedElements, function (trackedElement) {\r\n            var targetElement = document.querySelector(trackedElement.target);\r\n            trackedElement.offsetTop = targetElement ? dimensions.offset(targetElement).top : null;\r\n            if (options.offset && trackedElement.offsetTop !== null) trackedElement.offsetTop -= options.offset * 1;\r\n          });\r\n\r\n          sortedElements = trackedElements\r\n          .filter(function (el) {\r\n            return el.offsetTop !== null;\r\n          })\r\n          .sort(function (a, b) {\r\n            return a.offsetTop - b.offsetTop;\r\n          });\r\n\r\n          debouncedCheckPosition();\r\n\r\n        };\r\n\r\n        $scrollspy.trackElement = function (target, source) {\r\n          trackedElements.push({target: target, source: source});\r\n        };\r\n\r\n        $scrollspy.untrackElement = function (target, source) {\r\n          var toDelete;\r\n          for (var i = trackedElements.length; i--;) {\r\n            if (trackedElements[i].target === target && trackedElements[i].source === source) {\r\n              toDelete = i;\r\n              break;\r\n            }\r\n          }\r\n          trackedElements.splice(toDelete, 1);\r\n        };\r\n\r\n        $scrollspy.activate = function (i) {\r\n          trackedElements[i].addClass('active');\r\n        };\r\n\r\n        // Initialize plugin\r\n\r\n        $scrollspy.init();\r\n        return $scrollspy;\r\n\r\n      }\r\n\r\n      return ScrollSpyFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsScrollspy', function ($rootScope, debounce, dimensions, $scrollspy) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      link: function postLink (scope, element, attr) {\r\n\r\n        var options = {scope: scope};\r\n        angular.forEach(['offset', 'target'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        var scrollspy = $scrollspy(options);\r\n        scrollspy.trackElement(options.target, element);\r\n\r\n        scope.$on('$destroy', function () {\r\n          if (scrollspy) {\r\n            scrollspy.untrackElement(options.target, element);\r\n            scrollspy.destroy();\r\n          }\r\n          options = null;\r\n          scrollspy = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n\r\n  .directive('bsScrollspyList', function ($rootScope, debounce, dimensions, $scrollspy) {\r\n\r\n    return {\r\n      restrict: 'A',\r\n      compile: function postLink (element, attr) {\r\n        var children = element[0].querySelectorAll('li > a[href]');\r\n        angular.forEach(children, function (child) {\r\n          var childEl = angular.element(child);\r\n          childEl.parent().attr('bs-scrollspy', '').attr('data-target', childEl.attr('href'));\r\n        });\r\n      }\r\n\r\n    };\r\n\r\n  });\r\n\r\n// Source: popover\\popover.js\r\nangular.module('mgcrea.ngStrap.popover', ['mgcrea.ngStrap.tooltip'])\r\n\r\n  .provider('$popover', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      customClass: '',\r\n      // uncommenting the next two lines will break backwards compatability\r\n      // prefixClass: 'popover',\r\n      // prefixEvent: 'popover',\r\n      container: false,\r\n      target: false,\r\n      placement: 'right',\r\n      templateUrl: 'popover/popover.tpl.html',\r\n      contentTemplate: false,\r\n      trigger: 'click',\r\n      keyboard: true,\r\n      html: false,\r\n      title: '',\r\n      content: '',\r\n      delay: 0,\r\n      autoClose: false\r\n    };\r\n\r\n    this.$get = function ($tooltip) {\r\n\r\n      function PopoverFactory (element, config) {\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n\r\n        var $popover = $tooltip(element, options);\r\n\r\n        // Support scope as string options [/*title, */content]\r\n        if (options.content) {\r\n          $popover.$scope.content = options.content;\r\n        }\r\n\r\n        return $popover;\r\n\r\n      }\r\n\r\n      return PopoverFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsPopover', function ($window, $sce, $popover) {\r\n\r\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink (scope, element, attr) {\r\n\r\n        var popover;\r\n        // Directive options\r\n        var options = {scope: scope};\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'customClass', 'autoClose', 'id', 'prefixClass', 'prefixEvent', 'bsEnabled'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container', 'autoClose'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // should not parse target attribute (anchor tag), only data-target #1454\r\n        var dataTarget = element.attr('data-target');\r\n        if (angular.isDefined(dataTarget)) {\r\n          if (falseValueRegExp.test(dataTarget)) {\r\n            options.target = false;\r\n          } else {\r\n            options.target = dataTarget;\r\n          }\r\n        }\r\n\r\n        // Support scope as data-attrs\r\n        angular.forEach(['title', 'content'], function (key) {\r\n          if (attr[key]) {\r\n            attr.$observe(key, function (newValue, oldValue) {\r\n              scope[key] = $sce.trustAsHtml(newValue);\r\n              if (angular.isDefined(oldValue)) {\r\n                requestAnimationFrame(function () {\r\n                  if (popover) popover.$applyPlacement();\r\n                });\r\n              }\r\n            });\r\n          }\r\n        });\r\n\r\n        // Support scope as an object\r\n        if (attr.bsPopover) {\r\n          scope.$watch(attr.bsPopover, function (newValue, oldValue) {\r\n            if (angular.isObject(newValue)) {\r\n              angular.extend(scope, newValue);\r\n            } else {\r\n              scope.content = newValue;\r\n            }\r\n            if (angular.isDefined(oldValue)) {\r\n              requestAnimationFrame(function () {\r\n                if (popover) popover.$applyPlacement();\r\n              });\r\n            }\r\n          }, true);\r\n        }\r\n\r\n        // Visibility binding support\r\n        if (attr.bsShow) {\r\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\r\n            if (!popover || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(popover),?/i);\r\n            if (newValue === true) {\r\n              popover.show();\r\n            } else {\r\n              popover.hide();\r\n            }\r\n          });\r\n        }\r\n\r\n        // Enabled binding support\r\n        if (attr.bsEnabled) {\r\n          scope.$watch(attr.bsEnabled, function (newValue) {\r\n            if (!popover || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(popover),?/i);\r\n            if (newValue === false) {\r\n              popover.setEnabled(false);\r\n            } else {\r\n              popover.setEnabled(true);\r\n            }\r\n          });\r\n        }\r\n\r\n        // Viewport support\r\n        if (attr.viewport) {\r\n          scope.$watch(attr.viewport, function (newValue) {\r\n            if (!popover || !angular.isDefined(newValue)) return;\r\n            popover.setViewport(newValue);\r\n          });\r\n        }\r\n\r\n        // Initialize popover\r\n        popover = $popover(element, options);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (popover) popover.destroy();\r\n          options = null;\r\n          popover = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n\r\n// Source: navbar\\navbar.js\r\nangular.module('mgcrea.ngStrap.navbar', [])\r\n\r\n  .provider('$navbar', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      activeClass: 'active',\r\n      routeAttr: 'data-match-route',\r\n      strict: false\r\n    };\r\n\r\n    this.$get = function () {\r\n      return {defaults: defaults};\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsNavbar', function ($window, $location, $navbar) {\r\n\r\n    var defaults = $navbar.defaults;\r\n\r\n    return {\r\n      restrict: 'A',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        // Directive options\r\n        var options = angular.copy(defaults);\r\n        angular.forEach(Object.keys(defaults), function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // Watch for the $location\r\n        scope.$watch(function () {\r\n\r\n          return $location.path();\r\n\r\n        }, function (newValue, oldValue) {\r\n\r\n          var liElements = element[0].querySelectorAll('li[' + options.routeAttr + ']');\r\n\r\n          angular.forEach(liElements, function (li) {\r\n\r\n            var liElement = angular.element(li);\r\n            var pattern = liElement.attr(options.routeAttr).replace('/', '\\\\/');\r\n            if (options.strict) {\r\n              pattern = '^' + pattern + '$';\r\n            }\r\n            var regexp = new RegExp(pattern, 'i');\r\n\r\n            if (regexp.test(newValue)) {\r\n              liElement.addClass(options.activeClass);\r\n            } else {\r\n              liElement.removeClass(options.activeClass);\r\n            }\r\n\r\n          });\r\n\r\n        });\r\n\r\n      }\r\n\r\n    };\r\n\r\n  });\r\n\r\n// Source: modal\\modal.js\r\nangular.module('mgcrea.ngStrap.modal', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\r\n\r\n  .provider('$modal', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      backdropAnimation: 'am-fade',\r\n      customClass: '',\r\n      prefixClass: 'modal',\r\n      prefixEvent: 'modal',\r\n      placement: 'top',\r\n      templateUrl: 'modal/modal.tpl.html',\r\n      template: '',\r\n      contentTemplate: false,\r\n      container: false,\r\n      element: null,\r\n      backdrop: true,\r\n      keyboard: true,\r\n      html: false,\r\n      show: true,\r\n      size: null,\r\n      zIndex: null,\r\n      containerElement: null\r\n    };\r\n\r\n    this.$get = function ($window, $rootScope, $bsCompiler, $animate, $timeout, $sce, dimensions) {\r\n\r\n      var forEach = angular.forEach;\r\n      var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\r\n      var bodyElement = angular.element($window.document.body);\r\n\r\n      var defaultContainerElement = \"#layoutContainer\";\r\n\r\n      var layoutHideElement = angular.element(defaultContainerElement);\r\n\r\n      var backdropCount = 0;\r\n      var dialogBaseZindex = 1050;\r\n      var backdropBaseZindex = 1040;\r\n\r\n      var validSizes = {\r\n        lg: 'modal-lg',\r\n        sm: 'modal-sm'\r\n      };\r\n\r\n      function ModalFactory(config) {\r\n\r\n        var $modal = {};\r\n\r\n        // Common vars\r\n        var options = $modal.$options = angular.extend({}, defaults, config);\r\n\r\n        var promise = $modal.$promise = $bsCompiler.compile(options);\r\n        var scope = $modal.$scope = options.scope && options.scope.$new() || $rootScope.$new();\r\n\r\n        if (options.containerElement) {\r\n          layoutHideElement = angular.element(options.containerElement);\r\n        }\r\n        if (!options.element && !options.container) {\r\n          options.container = 'body';\r\n        }\r\n\r\n        if (options.zIndex) {\r\n          dialogBaseZindex = parseInt(options.zIndex, 10);\r\n          backdropBaseZindex = dialogBaseZindex - 10;\r\n        }\r\n\r\n        // Store $id to identify the triggering element in events\r\n        // give priority to options.id, otherwise, try to use\r\n        // element id if defined\r\n        $modal.$id = options.id || options.element && options.element.attr('id') || '';\r\n\r\n        $modal.returnFocus = function () {\r\n\r\n        };\r\n\r\n        // Support scope as string options\r\n        forEach(['title', 'content'], function (key) {\r\n          if (options[key]) scope[key] = $sce.trustAsHtml(options[key]);\r\n        });\r\n\r\n        // Provide scope helpers\r\n        scope.$hide = function () {\r\n          scope.$$postDigest(function () {\r\n            $modal.hide();\r\n          });\r\n        };\r\n        scope.$show = function () {\r\n          scope.$$postDigest(function () {\r\n            $modal.show();\r\n          });\r\n        };\r\n        scope.$toggle = function () {\r\n          scope.$$postDigest(function () {\r\n            $modal.toggle();\r\n          });\r\n        };\r\n        // Publish isShown as a protected var on scope\r\n        $modal.$isShown = scope.$isShown = false;\r\n\r\n        // Fetch, compile then initialize modal\r\n        var compileData;\r\n        var modalElement;\r\n        var modalScope;\r\n        var backdropElement = angular.element('<div class=\"' + options.prefixClass + '-backdrop\"/>');\r\n        backdropElement.css({ position: 'fixed', top: '0px', left: '0px', bottom: '0px', right: '0px' });\r\n        promise.then(function (data) {\r\n          compileData = data;\r\n          $modal.init();\r\n        });\r\n\r\n        $modal.init = function () {\r\n\r\n          // Options: show\r\n          if (options.show) {\r\n            scope.$$postDigest(function () {\r\n              $modal.show();\r\n            });\r\n          }\r\n\r\n        };\r\n\r\n        $modal.destroy = function () {\r\n\r\n          // Remove element\r\n          destroyModalElement();\r\n\r\n          // remove backdrop element\r\n          if (backdropElement) {\r\n            backdropElement.remove();\r\n            backdropElement = null;\r\n          }\r\n\r\n          // Destroy scope\r\n          scope.$destroy();\r\n        };\r\n\r\n        $modal.show = function () {\r\n          if ($modal.$isShown) return;\r\n\r\n          var parent;\r\n          var after;\r\n          if (angular.isElement(options.container)) {\r\n            parent = options.container;\r\n            after = options.container[0].lastChild ? angular.element(options.container[0].lastChild) : null;\r\n          } else {\r\n            if (options.container) {\r\n              parent = findElement(options.container);\r\n              after = parent[0] && parent[0].lastChild ? angular.element(parent[0].lastChild) : null;\r\n            } else {\r\n              parent = null;\r\n              after = options.element;\r\n            }\r\n          }\r\n\r\n          // destroy any existing modal elements\r\n          if (modalElement) destroyModalElement();\r\n\r\n          // create a new scope, so we can destroy it and all child scopes\r\n          // when destroying the modal element\r\n          modalScope = $modal.$scope.$new();\r\n          // Fetch a cloned element linked from template (noop callback is required)\r\n          modalElement = $modal.$element = compileData.link(modalScope, function (clonedElement, scope) { });\r\n\r\n          if (options.backdrop) {\r\n            // set z-index\r\n            modalElement.css({ 'z-index': dialogBaseZindex + (backdropCount * 20) });\r\n            backdropElement.css({ 'z-index': backdropBaseZindex + (backdropCount * 20) });\r\n\r\n            // increment number of backdrops\r\n            backdropCount++;\r\n          }\r\n\r\n          if (scope.$emit(options.prefixEvent + '.show.before', $modal).defaultPrevented) {\r\n            return;\r\n          }\r\n          if (angular.isDefined(options.onBeforeShow) && angular.isFunction(options.onBeforeShow)) {\r\n            options.onBeforeShow($modal);\r\n          }\r\n\r\n          // Set the initial positioning.\r\n          modalElement.css({ display: 'block' }).addClass(options.placement);\r\n\r\n          // Options: customClass\r\n          if (options.customClass) {\r\n            modalElement.addClass(options.customClass);\r\n          }\r\n\r\n          // Options: size\r\n          if (options.size && validSizes[options.size]) {\r\n            angular.element(findElement('.modal-dialog', modalElement[0])).addClass(validSizes[options.size]);\r\n          }\r\n\r\n          // Options: animation\r\n          if (options.animation) {\r\n            if (options.backdrop) {\r\n              backdropElement.addClass(options.backdropAnimation);\r\n            }\r\n            modalElement.addClass(options.animation);\r\n          }\r\n\r\n          if (options.backdrop) {\r\n            $animate.enter(backdropElement, bodyElement, null);\r\n          }\r\n\r\n          // Support v1.2+ $animate\r\n          // https://github.com/angular/angular.js/issues/11713\r\n          if (angular.version.minor <= 2) {\r\n            $animate.enter(modalElement, parent, after, enterAnimateCallback);\r\n          } else {\r\n            $animate.enter(modalElement, parent, after).then(enterAnimateCallback);\r\n          }\r\n\r\n          $modal.$isShown = scope.$isShown = true;\r\n          safeDigest(scope);\r\n          // Focus once the enter-animation has started\r\n          // Weird PhantomJS bug hack\r\n          var el = modalElement[0];\r\n          requestAnimationFrame(function () {\r\n            el.focus();\r\n          });\r\n\r\n          bodyElement.addClass(options.prefixClass + '-open');\r\n\r\n          layoutHideElement.attr('aria-hidden', 'true');\r\n\r\n          if (options.animation) {\r\n            bodyElement.addClass(options.prefixClass + '-with-' + options.animation);\r\n          }\r\n\r\n          // Bind events\r\n          bindBackdropEvents();\r\n          bindKeyboardEvents();\r\n        };\r\n\r\n        function enterAnimateCallback() {\r\n          scope.$emit(options.prefixEvent + '.show', $modal);\r\n          if (angular.isDefined(options.onShow) && angular.isFunction(options.onShow)) {\r\n            options.onShow($modal);\r\n          }\r\n\r\n          modalElement.attr('aria-hidden', 'false');\r\n\r\n\t\t  var focusableElement = angular.element(findElement('.modal'));\r\n\t\t  \r\n\t\t  if (focusableElement.length > 0)\r\n\t\t  {\r\n\t\t\tfocusableElement.attr('tabindex', '0');\r\n            setTimeout(function () {\r\n              focusableElement.focus();\r\n            }, 500);\r\n\t\t  }\r\n        }\r\n\r\n        $modal.hide = function () {\r\n          if (!$modal.$isShown) return;\r\n\r\n          if (scope.$emit(options.prefixEvent + '.hide.before', $modal).defaultPrevented) {\r\n            return;\r\n          }\r\n          if (angular.isDefined(options.onBeforeHide) && angular.isFunction(options.onBeforeHide)) {\r\n            options.onBeforeHide($modal);\r\n          }\r\n\r\n          modalElement.attr('aria-hidden', 'true');\r\n\r\n          if ($modal.returnFocus && typeof $modal.returnFocus === 'function') $modal.returnFocus();\r\n\r\n          // Support v1.2+ $animate\r\n          // https://github.com/angular/angular.js/issues/11713\r\n          if (angular.version.minor <= 2) {\r\n            $animate.leave(modalElement, leaveAnimateCallback);\r\n          } else {\r\n            $animate.leave(modalElement).then(leaveAnimateCallback);\r\n          }\r\n\r\n          if (options.backdrop) {\r\n            // decrement number of backdrops\r\n            backdropCount--;\r\n            $animate.leave(backdropElement);\r\n          }\r\n          $modal.$isShown = scope.$isShown = false;\r\n          safeDigest(scope);\r\n\r\n          // Unbind events\r\n          unbindBackdropEvents();\r\n          unbindKeyboardEvents();\r\n        };\r\n\r\n        function leaveAnimateCallback() {\r\n          scope.$emit(options.prefixEvent + '.hide', $modal);\r\n          if (angular.isDefined(options.onHide) && angular.isFunction(options.onHide)) {\r\n            options.onHide($modal);\r\n          }\r\n          if (findElement('.modal').length <= 0) {\r\n            bodyElement.removeClass(options.prefixClass + '-open');\r\n            layoutHideElement.attr('aria-hidden', 'false');\r\n          }\r\n          if (options.animation) {\r\n            bodyElement.removeClass(options.prefixClass + '-with-' + options.animation);\r\n          }\r\n        }\r\n\r\n        function findFocusableElements() {\r\n          // Add all elements we want to include in our selection\r\n          var focusableElements = 'a:not([disabled]), button:not([disabled]), input:not([disabled]), [tabindex]:not([disabled]):not([tabindex=\"-1\"])';\r\n          if (document.activeElement) {\r\n            var focusable = Array.prototype.filter.call(modalElement[0].querySelectorAll(focusableElements),\r\n              function (element) {\r\n                // Check for visibility while always include the current activeElement\r\n                return element.offsetWidth > 0 || element.offsetHeight > 0 || element === document.activeElement;\r\n              });\r\n\r\n            return focusable;\r\n          }\r\n        }\r\n\r\n        function findNextFocusableElement(inReverse) {\r\n          if (document.activeElement) {\r\n            var focusable = findFocusableElements();\r\n            if (focusable === undefined) return;\r\n            if (inReverse) {\r\n              focusable = Array.prototype.reverse.call(focusable);\r\n            }\r\n\r\n            var index = focusable.indexOf(document.activeElement);\r\n            return focusable[index + 1];\r\n          }\r\n        }\r\n\r\n        $modal.toggle = function () {\r\n          if ($modal.$isShown) {\r\n            $modal.hide();\r\n          } else {\r\n            $modal.show();\r\n          }\r\n        };\r\n\r\n        $modal.focus = function () {\r\n          modalElement[0].focus();\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $modal.$onKeyUp = function (evt) {\r\n\r\n          // Escape was pressed on an open modal. Hide it.\r\n          if (evt.which === 27 && $modal.$isShown) {\r\n            $modal.hide();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        $modal.$onKeyDown = function (evt) {\r\n          if (options.keyboard) {\r\n            if (evt.keyCode === 9) {\r\n\r\n              var nextFocusable = findNextFocusableElement(evt.shiftKey);\r\n              if (nextFocusable === undefined) {\r\n                if (evt.preventDefault) evt.preventDefault();\r\n                if (evt.stopPropagation) evt.stopPropagation();\r\n\r\n                var focusable = findFocusableElements();\r\n                if (evt.shiftKey) {\r\n                  focusable[focusable.length - 1].focus();\r\n                } else {\r\n                  focusable[0].focus();\r\n                }\r\n              }\r\n            }\r\n          }\r\n        };\r\n\r\n        function bindBackdropEvents() {\r\n          if (options.backdrop) {\r\n            modalElement.on('click', hideOnBackdropClick);\r\n            backdropElement.on('click', hideOnBackdropClick);\r\n            backdropElement.on('wheel', preventEventDefault);\r\n          }\r\n        }\r\n\r\n        function unbindBackdropEvents() {\r\n          if (options.backdrop) {\r\n            modalElement.off('click', hideOnBackdropClick);\r\n            backdropElement.off('click', hideOnBackdropClick);\r\n            backdropElement.off('wheel', preventEventDefault);\r\n          }\r\n        }\r\n\r\n        function bindKeyboardEvents() {\r\n          if (options.keyboard) {\r\n            modalElement.on('keyup', $modal.$onKeyUp);\r\n            modalElement.on('keydown', $modal.$onKeyDown);\r\n          }\r\n        }\r\n\r\n        function unbindKeyboardEvents() {\r\n          if (options.keyboard) {\r\n            modalElement.off('keyup', $modal.$onKeyUp);\r\n            modalElement.off('keydown', $modal.$onKeyDown);\r\n          }\r\n        }\r\n\r\n        // Private helpers\r\n\r\n        function hideOnBackdropClick(evt) {\r\n          if (evt.target !== evt.currentTarget) return;\r\n          if (options.backdrop === 'static') {\r\n            $modal.focus();\r\n          } else {\r\n            $modal.hide();\r\n          }\r\n        }\r\n\r\n        function preventEventDefault(evt) {\r\n          evt.preventDefault();\r\n        }\r\n\r\n        function destroyModalElement() {\r\n          if ($modal.$isShown && modalElement !== null) {\r\n            // un-bind events\r\n            unbindBackdropEvents();\r\n            unbindKeyboardEvents();\r\n          }\r\n\r\n          if (modalScope) {\r\n            modalScope.$destroy();\r\n            modalScope = null;\r\n          }\r\n\r\n          if (modalElement) {\r\n            modalElement.remove();\r\n            modalElement = $modal.$element = null;\r\n          }\r\n        }\r\n\r\n        return $modal;\r\n\r\n      }\r\n\r\n      // Helper functions\r\n\r\n      function safeDigest(scope) {\r\n        /* eslint-disable no-unused-expressions */\r\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\r\n        /* eslint-enable no-unused-expressions */\r\n      }\r\n\r\n      function findElement(query, element) {\r\n        return angular.element((element || document).querySelectorAll(query));\r\n      }\r\n\r\n      return ModalFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsModal', function ($window, $sce, $parse, $modal) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink(scope, element, attr, transclusion) {\r\n\r\n        // Directive options\r\n        var options = { scope: scope, element: element, show: false };\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation', 'backdropAnimation', 'id', 'prefixEvent', 'prefixClass', 'customClass', 'modalClass', 'size', 'zIndex'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // Options: alias modalClass to customClass\r\n        if (options.modalClass) {\r\n          options.customClass = options.modalClass;\r\n        }\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['backdrop', 'keyboard', 'html', 'container'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Support scope as data-attrs\r\n        angular.forEach(['title', 'content'], function (key) {\r\n          if (attr[key]) {\r\n            attr.$observe(key, function (newValue, oldValue) {\r\n              scope[key] = $sce.trustAsHtml(newValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Support scope as an object\r\n        if (attr.bsModal) {\r\n          scope.$watch(attr.bsModal, function (newValue, oldValue) {\r\n            if (angular.isObject(newValue)) {\r\n              angular.extend(scope, newValue);\r\n            } else {\r\n              scope.content = newValue;\r\n            }\r\n          }, true);\r\n        }\r\n\r\n        // Initialize modal\r\n        var modal = $modal(options);\r\n\r\n        if (options.keyboard) {\r\n          modal.returnFocus = function () {\r\n            element[0].focus();\r\n          };\r\n        }\r\n\r\n        // Trigger\r\n        element.on(attr.trigger || 'click', modal.toggle);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (modal) modal.destroy();\r\n          options = null;\r\n          modal = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n\r\n// Source: dropdown\\dropdown.js\r\nangular.module('mgcrea.ngStrap.dropdown', ['mgcrea.ngStrap.tooltip'])\r\n\r\n  .provider('$dropdown', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      prefixClass: 'dropdown',\r\n      prefixEvent: 'dropdown',\r\n      placement: 'bottom-left',\r\n      templateUrl: 'dropdown/dropdown.tpl.html',\r\n      trigger: 'click',\r\n      container: false,\r\n      keyboard: true,\r\n      html: false,\r\n      delay: 0\r\n    };\r\n\r\n    this.$get = function ($window, $rootScope, $tooltip, $timeout) {\r\n\r\n      var bodyEl = angular.element($window.document.body);\r\n      var matchesSelector = Element.prototype.matchesSelector || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector;\r\n\r\n      function DropdownFactory (element, config) {\r\n\r\n        var $dropdown = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n        /* var scope = */\r\n        $dropdown.$scope = options.scope && options.scope.$new() || $rootScope.$new();\r\n\r\n        $dropdown = $tooltip(element, options);\r\n        var parentEl = element.parent();\r\n\r\n        if (element && element[0] && element[0].tagName.toUpperCase() === 'BUTTON') {\r\n          element.attr('aria-haspopup', 'true');\r\n          element.attr('data-toggle', 'dropdown');\r\n          element.attr('aria-expanded', 'false');\r\n          element.attr('role', 'button');\r\n        }\r\n\r\n        // Protected methods\r\n\r\n        $dropdown.$onKeyDown = function (evt) {\r\n          if ((/(9)/.test(evt.keyCode) && !options.keyboard) || /27/.test(evt.keyCode)) {\r\n            $dropdown.hide(/27/.test(evt.keyCode));\r\n            return;\r\n          }\r\n          if (!/(38|40)/.test(evt.keyCode)) return;\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n\r\n          // Retrieve focused index\r\n          var items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider) a'));\r\n          if (!items.length) return;\r\n          var index;\r\n          angular.forEach(items, function (el, i) {\r\n            if (matchesSelector && matchesSelector.call(el, ':focus')) index = i;\r\n          });\r\n\r\n          // Navigate with keyboard\r\n          if (evt.keyCode === 38 && index > 0) index--;\r\n          else if (evt.keyCode === 40 && index < items.length - 1) index++;\r\n          else if (angular.isUndefined(index)) index = 0;\r\n          items.eq(index)[0].focus();\r\n\r\n        };\r\n\r\n        $dropdown.$onFocusOut = function (evt) {\r\n          // find out if the related target's parents contain the datepicker's $element\r\n          var inMenu = false;\r\n          var parent = angular.element(evt.relatedTarget);\r\n          while (parent !== undefined && parent.length && parent[0] !== $window.document.body) {\r\n            parent = parent.parent();\r\n            if (parent !== undefined && parent[0] === $dropdown.$element[0]) {\r\n              inMenu = true;\r\n              break;\r\n            } else {\r\n              inMenu = false;\r\n            }\r\n          }\r\n\r\n          if (!inMenu) {\r\n            $dropdown.hide();\r\n          } else {\r\n            evt.preventDefault();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        // Overrides\r\n\r\n        var show = $dropdown.show;\r\n        $dropdown.show = function () {\r\n          show();\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed imediately.\r\n          $timeout(function () {\r\n            // Set assistive technology properties\r\n            element.attr('aria-expanded', 'true');\r\n            if ($dropdown.$element) {\r\n              $dropdown.$element.attr('aria-hidden', 'false');\r\n              $dropdown.$element.attr('role', 'menu');\r\n              $dropdown.$element.attr('tabindex', '-1');\r\n            }\r\n            if (options.keyboard && $dropdown.$element) {\r\n              $dropdown.$element.on('keydown', $dropdown.$onKeyDown);\r\n              $dropdown.$element.on('focusout', $dropdown.$onFocusOut);\r\n            }\r\n\r\n            bodyEl.on('click', onBodyClick);\r\n\r\n            if ($dropdown.$element) {\r\n              var items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider)'));\r\n              items.attr('role', 'presentation');\r\n\r\n              angular.element($dropdown.$element[0].querySelectorAll('li.divider')).attr('role', 'seperator');\r\n\r\n              items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider) a'));\r\n              items.attr('role', 'menuitem');\r\n              if (items.length && options.keyboard) {\r\n                items[0].focus();\r\n              }\r\n            }\r\n          }, 0, false);\r\n          if (parentEl.hasClass('dropdown')) parentEl.addClass('open');\r\n        };\r\n\r\n        var hide = $dropdown.hide;\r\n                $dropdown.hide = function (returnFocus) {\r\n          if (!$dropdown.$isShown) return;\r\n\r\n          element.attr('aria-expanded', 'true');\r\n          $dropdown.$element.attr('aria-hidden', 'true');\r\n\r\n          if (options.keyboard && $dropdown.$element) {\r\n            $dropdown.$element.off('keydown', $dropdown.$onKeyDown);\r\n            $dropdown.$element.off('focusout', $dropdown.$onFocusOut);\r\n          }\r\n\r\n          bodyEl.off('click', onBodyClick);\r\n          if (parentEl.hasClass('dropdown')) parentEl.removeClass('open');\r\n          $timeout(function () {\r\n            hide();\r\n            if (returnFocus) {\r\n              $timeout(function () {\r\n                if (element && element[0]) {\r\n                  element[0].focus();\r\n                }\r\n              }, 0, false);\r\n            }\r\n          }, 200);\r\n        };\r\n\r\n        var destroy = $dropdown.destroy;\r\n        $dropdown.destroy = function () {\r\n          bodyEl.off('click', onBodyClick);\r\n          destroy();\r\n        };\r\n\r\n        // Private functions\r\n\r\n        function onBodyClick (evt) {\r\n          if (evt.target === element[0]) return;\r\n          return evt.target !== element[0] && $dropdown.hide();\r\n        }\r\n\r\n        return $dropdown;\r\n\r\n      }\r\n\r\n      return DropdownFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsDropdown', function ($window, $sce, $dropdown) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      compile: function (tElement, tAttrs) {\r\n\r\n        // Support for inlined template (next sibling)\r\n        // It must be fetched before compilation\r\n        if (!tAttrs.bsDropdown) {\r\n          var nextSibling = tElement[0].nextSibling;\r\n          while (nextSibling && nextSibling.nodeType !== 1) {\r\n            nextSibling = nextSibling.nextSibling;\r\n          }\r\n          if (nextSibling && nextSibling.className.split(' ').indexOf('dropdown-menu') >= 0) {\r\n            tAttrs.template = nextSibling.outerHTML;\r\n            tAttrs.templateUrl = undefined;\r\n            nextSibling.parentNode.removeChild(nextSibling);\r\n          }\r\n        }\r\n\r\n        return function postLink (scope, element, attr) {\r\n\r\n          // Directive options\r\n          var options = {\r\n            scope: scope\r\n          };\r\n          angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'id', 'autoClose'], function (key) {\r\n            if (angular.isDefined(tAttrs[key])) options[key] = tAttrs[key];\r\n          });\r\n\r\n          // use string regex match boolean attr falsy values, leave truthy values be\r\n          var falseValueRegExp = /^(false|0|)$/i;\r\n          angular.forEach(['html', 'container'], function (key) {\r\n            if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n          });\r\n\r\n          // bind functions from the attrs to the show and hide events\r\n          angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n            var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n            if (angular.isDefined(attr[bsKey])) {\r\n              options[key] = scope.$eval(attr[bsKey]);\r\n            }\r\n          });\r\n\r\n          // Support scope as an object\r\n          if (attr.bsDropdown) {\r\n            scope.$watch(attr.bsDropdown, function (newValue, oldValue) {\r\n              scope.content = newValue;\r\n            }, true);\r\n          }\r\n\r\n          // Initialize dropdown\r\n          var dropdown = $dropdown(element, options);\r\n\r\n          // Visibility binding support\r\n          if (attr.bsShow) {\r\n            scope.$watch(attr.bsShow, function (newValue, oldValue) {\r\n              if (!dropdown || !angular.isDefined(newValue)) return;\r\n              if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(dropdown),?/i);\r\n              if (newValue === true) {\r\n                dropdown.show();\r\n              } else {\r\n                dropdown.hide();\r\n              }\r\n            });\r\n          }\r\n\r\n          // Garbage collection\r\n          scope.$on('$destroy', function () {\r\n            if (dropdown) dropdown.destroy();\r\n            options = null;\r\n            dropdown = null;\r\n          });\r\n\r\n        };\r\n      }\r\n    };\r\n\r\n  });\r\n\r\n// Source: datepicker\\datepicker.js\r\nangular.module('mgcrea.ngStrap.datepicker', [\r\n  'mgcrea.ngStrap.helpers.dateParser',\r\n  'mgcrea.ngStrap.helpers.dateFormatter',\r\n  'mgcrea.ngStrap.helpers.focusElement',\r\n  'mgcrea.ngStrap.helpers.ngFocusOut',\r\n  'mgcrea.ngStrap.tooltip'])\r\n  .provider('$datepicker', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      // Uncommenting the following line will break backwards compatability\r\n      // prefixEvent: 'datepicker',\r\n      prefixClass: 'datepicker',\r\n      placement: 'bottom-left',\r\n      templateUrl: 'datepicker/datepicker.tpl.html',\r\n      trigger: 'focus',\r\n      container: false,\r\n      keyboard: true,\r\n      html: false,\r\n      delay: 0,\r\n      // lang: $locale.id,\r\n      useNative: false,\r\n      dateType: 'date',\r\n      dateFormat: 'shortDate',\r\n      timezone: null,\r\n      modelDateFormat: null,\r\n      dayFormat: 'dd',\r\n      monthFormat: 'MMM',\r\n      yearFormat: 'yyyy',\r\n      monthTitleFormat: 'MMMM yyyy',\r\n      yearTitleFormat: 'yyyy',\r\n      strictFormat: false,\r\n      autoclose: false,\r\n      minDate: -Infinity,\r\n      maxDate: +Infinity,\r\n      startView: 0,\r\n      minView: 0,\r\n      startWeek: 0,\r\n      daysOfWeekDisabled: '',\r\n      hasToday: false,\r\n      hasClear: false,\r\n      iconLeft: 'glyphicon glyphicon-chevron-left',\r\n      iconRight: 'glyphicon glyphicon-chevron-right',\r\n      // The format that will be given to the screen reader values placed in the DOM.\r\n      screenReaderDateFormat: 'fullDate',\r\n      // Focuses the table element in the dropdown upon display of the picker.\r\n      // Used mainly in 508 situations when a button is pressed via a keyboard to show the calendar.\r\n      focusOnOpen: false\r\n    };\r\n\r\n    this.$get = function ($window, $document, $rootScope, $sce, $dateFormatter, datepickerViews, $tooltip, $timeout) {\r\n\r\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n      var isTouch = ('createTouch' in $window.document) && isNative;\r\n      if (!defaults.lang) defaults.lang = $dateFormatter.getDefaultLocale();\r\n\r\n      function DatepickerFactory (element, controller, config) {\r\n\r\n        // The datepicker is based on the tooltip control. Build a basic tooltip from the\r\n        // defaults and the configuration passed.\r\n        var $datepicker = $tooltip(element, angular.extend({}, defaults, config));\r\n        var parentScope = config.scope;\r\n        var options = $datepicker.$options;\r\n        var scope = $datepicker.$scope;\r\n        if (options.startView) options.startView -= options.minView;\r\n\r\n        // Add assistive technology helper attributes.\r\n        element.attr('aria-expanded', 'false').attr('aria-haspopup', 'true');\r\n\r\n        // View vars\r\n\r\n        // Initialize the datepicker view collection by passing a reference to the base object.\r\n        var pickerViews = datepickerViews($datepicker);\r\n        $datepicker.$views = pickerViews.views;\r\n        var viewDate = pickerViews.viewDate;\r\n        /*\r\n         * View mode for the date picker.\r\n         * 0: days\r\n         * 1: months\r\n         * 2: years\r\n         */\r\n        scope.$mode = options.startView;\r\n        // icon class override\r\n        scope.$iconLeft = options.iconLeft;\r\n        scope.$iconRight = options.iconRight;\r\n        // Show buttons at the bottom of the picker.\r\n        scope.$hasToday = options.hasToday;\r\n        scope.$hasClear = options.hasClear;\r\n        /*\r\n         * An id on the element is necessary when working with assistive technologies. The view will use the id to build out the\r\n         * aria attributes which are linked via ids.\r\n         */\r\n        scope.id = options.id !== null && options.id !== undefined ? options.id : undefined;\r\n        scope.dropdownId = options.id !== null && options.id !== undefined ? (options.id + '_dropdown') : undefined;\r\n        scope.keyboard = options.keyboard;\r\n        scope.focusOnOpen = options.focusOnOpen;\r\n\r\n        // labels\r\n        scope.$nextLabel = options.labelNext;\r\n        scope.$previousLabel = options.labelPrevious;\r\n\r\n        // This is the actual current picker view.\r\n        var $picker = $datepicker.$views[scope.$mode];\r\n\r\n        // Internal handlers\r\n\r\n        function handleOnKeyDown (evt, apply) {\r\n          if (!/(33|34|38|37|39|40|13)/.test(evt.keyCode) &&\r\n            !(/(33|34|38|37|39|40|13)/.test(evt.keyCode) && evt.shiftKey) &&\r\n            !(/(33|34|38|37|39|40|13)/.test(evt.keyCode) && evt.altKey)) {\r\n            return false;\r\n          }\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n\r\n          if (evt.keyCode === 13) {\r\n            if (!scope.$mode) {\r\n              $datepicker.hide(true);\r\n              if (options.focusOnOpen) return true;\r\n            } else {\r\n              if (apply === undefined || apply) {\r\n                scope.$apply(function () {\r\n                  $datepicker.setMode(scope.$mode - 1);\r\n                });\r\n              } else {\r\n                $datepicker.setMode(scope.$mode - 1);\r\n              }\r\n            }\r\n            return false;\r\n          }\r\n\r\n          return true;\r\n        }\r\n\r\n        // Scope methods\r\n\r\n        /**\r\n         * Pass through from the scope to the provider for the selection of a date.\r\n         */\r\n        scope.$select = function (date, disabled) {\r\n          if (disabled) return;\r\n          $datepicker.select(date);\r\n        };\r\n        scope.$selectPane = function (value) {\r\n          $datepicker.$selectPane(value);\r\n        };\r\n        scope.$toggleMode = function () {\r\n          $datepicker.setMode((scope.$mode + 1) % $datepicker.$views.length);\r\n        };\r\n        scope.$setToday = function () {\r\n          if (options.autoclose) {\r\n            $datepicker.setMode(0);\r\n            $datepicker.select(new Date());\r\n          } else {\r\n            $datepicker.select(new Date(), true);\r\n          }\r\n        };\r\n        scope.$clear = function () {\r\n          if (options.autoclose) {\r\n            $datepicker.setMode(0);\r\n            $datepicker.select(null);\r\n          } else {\r\n            $datepicker.select(null, true);\r\n          }\r\n        };\r\n        scope.$focused = function (dayInfo) {\r\n          scope.selectedDayId = dayInfo.id;\r\n          if (dayInfo.isNext && !scope.selected) {\r\n            if (scope.$mode) {\r\n              $datepicker.update(dayInfo.date);\r\n            } else {\r\n              scope.$select(dayInfo.date);\r\n            }\r\n          }\r\n        };\r\n        scope.$onKeyDown = function (evt, day) {\r\n          var continueHandling = handleOnKeyDown(evt, false);\r\n\r\n          if (continueHandling) {\r\n            // Navigate with keyboard\r\n            $picker.onKeyDown(evt);\r\n          }\r\n        };\r\n        scope.$onFocusOut = function (evt) {\r\n          // find out if the related target's parents contain the datepicker's $element\r\n          var inTable = false;\r\n          var parent = angular.element(evt.relatedTarget);\r\n          while (parent !== undefined && parent.length && parent[0] !== $window.document.body) {\r\n            parent = parent.parent();\r\n            if (parent !== undefined && parent[0] === $datepicker.$element[0]) {\r\n              inTable = true;\r\n              break;\r\n            } else {\r\n              inTable = false;\r\n            }\r\n          }\r\n\r\n          // In Chrome there is an issue when moving from month to month, year to year, etc.\r\n          //\r\n\r\n          if (!inTable && !evt.relatedTarget) {\r\n            // hmm\r\n          } else if (!inTable) {\r\n            $datepicker.hide();\r\n          } else {\r\n            evt.stopPropagation();\r\n            evt.preventDefault();\r\n          }\r\n        };\r\n\r\n        // Public methods\r\n\r\n        $datepicker.update = function (date) {\r\n          // console.warn('$datepicker.update() newValue=%o', date);\r\n          if (angular.isDate(date) && !isNaN(date.getTime())) {\r\n            $datepicker.$date = date;\r\n            $picker.update.call($picker, date);\r\n          }\r\n          // Build only if pristine\r\n          $datepicker.$build(true);\r\n        };\r\n\r\n        $datepicker.updateDisabledDates = function (dateRanges) {\r\n          options.disabledDateRanges = dateRanges;\r\n          for (var i = 0, l = scope.rows.length; i < l; i++) {\r\n            angular.forEach(scope.rows[i], $datepicker.$setDisabledEl);\r\n          }\r\n        };\r\n\r\n        $datepicker.select = function (date, keep) {\r\n          // console.warn('$datepicker.select', date, scope.$mode);\r\n          if (angular.isDate(date)) {\r\n            if (!angular.isDate(controller.$dateValue) || isNaN(controller.$dateValue.getTime())) {\r\n              controller.$dateValue = new Date(date);\r\n            }\r\n          } else {\r\n            controller.$dateValue = null;\r\n          }\r\n          if (!scope.$mode || keep) {\r\n            controller.$setViewValue(angular.copy(date));\r\n            controller.$render();\r\n            if (options.autoclose && !keep) {\r\n              $timeout(function () {\r\n                $datepicker.hide(true);\r\n              });\r\n            }\r\n          } else {\r\n            angular.extend(viewDate, {\r\n              year: date.getFullYear(),\r\n              month: date.getMonth(),\r\n              date: date.getDate()\r\n            });\r\n            $datepicker.setMode(scope.$mode - 1);\r\n            $datepicker.$build();\r\n          }\r\n        };\r\n\r\n        /**\r\n         * This changes the mode of the picker. By setting the mode the view for the picker will be\r\n         * rebuilt. The views are days, months, and years.\r\n         * @param {int} mode View mode for the datepicker. 0: day view, 1: month view, 2: year view.\r\n         */\r\n        $datepicker.setMode = function setMode (mode) {\r\n          scope.$mode = mode;\r\n          $picker = $datepicker.$views[scope.$mode];\r\n          // The picker has been changed so the view needs to be built.\r\n          $datepicker.$build();\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        /**\r\n         * Builds the datepicker's view based on the picker that is currently set.\r\n         */\r\n        $datepicker.$build = function $build (pristine) {\r\n          // console.warn('$datepicker.$build() viewDate=%o', viewDate);\r\n          if (pristine === true && $picker.built) return;\r\n          if (pristine === false && !$picker.built) return;\r\n          $picker.build.call($picker);\r\n        };\r\n\r\n        $datepicker.$updateSelected = function () {\r\n          for (var i = 0, l = scope.rows.length; i < l; i++) {\r\n            angular.forEach(scope.rows[i], function (day) {\r\n              updateSelected(day);\r\n              if (day.selected) scope.selected = day;\r\n            });\r\n          }\r\n        };\r\n\r\n        $datepicker.$isSelected = function (date) {\r\n          return $picker.isSelected(date);\r\n        };\r\n\r\n        $datepicker.$setDisabledEl = function (el) {\r\n          el.disabled = $picker.isDisabled(el.date);\r\n        };\r\n\r\n        $datepicker.$selectPane = function (value) {\r\n          var steps = $picker.steps;\r\n          // set targetDate to first day of month to avoid problems with\r\n          // date values rollover. This assumes the viewDate does not\r\n          // depend on the day of the month\r\n          var targetDate = new Date(Date.UTC(viewDate.year + ((steps.year || 0) * value), viewDate.month + ((steps.month || 0) * value), 1));\r\n          angular.extend(viewDate, {\r\n            year: targetDate.getUTCFullYear(),\r\n            month: targetDate.getUTCMonth(),\r\n            date: targetDate.getUTCDate()\r\n          });\r\n          $datepicker.$build();\r\n        };\r\n\r\n        $datepicker.$onMouseDown = function (evt) {\r\n          // Prevent blur on mousedown on .dropdown-menu\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n          // Emulate click for mobile devices\r\n          if (isTouch) {\r\n            var targetEl = angular.element(evt.target);\r\n            if (targetEl[0].nodeName.toLowerCase() !== 'button') {\r\n              targetEl = targetEl.parent();\r\n            }\r\n            targetEl.triggerHandler('click');\r\n          }\r\n        };\r\n\r\n        /**\r\n         * Handles the onKeyDown event from the element that this datepicker is bound.\r\n         * In the standard case this will be an input element. If the trigger is set\r\n         * to click and is bound to a button then it is likely we're servicing a 508\r\n         * type situation where the implementation will no longer uses. Focus will be\r\n         * given to the table.\r\n         */\r\n        $datepicker.$onKeyDown = function (evt) {\r\n          var continueHandling = handleOnKeyDown(evt);\r\n\r\n          if (continueHandling) {\r\n            // Navigate with keyboard\r\n            $picker.onKeyDown(evt);\r\n            parentScope.$digest();\r\n          }\r\n        };\r\n\r\n        // $datepicker.$onFocusOut = function (evt) {\r\n        //   // find out if the related target's parents contain the datepicker's $element\r\n        //   var inTable = false;\r\n        //   var parent = angular.element(evt.relatedTarget);\r\n        //   while (parent !== undefined && parent.length && parent[0] !== $window.document.body) {\r\n        //     parent = parent.parent();\r\n        //     if (parent !== undefined && parent[0] === $datepicker.$element[0]) {\r\n        //       inTable = true;\r\n        //       break;\r\n        //     } else {\r\n        //       inTable = false;\r\n        //     }\r\n        //   }\r\n\r\n        //   // In Chrome there is an issue when moving from month to month, year to year, etc.\r\n        //   //\r\n\r\n        //   if (!inTable && !evt.relatedTarget) {\r\n        //     // hmm\r\n        //   } else if (!inTable) {\r\n        //     $datepicker.hide();\r\n        //   } else {\r\n        //     evt.stopPropagation();\r\n        //     evt.preventDefault();\r\n        //   }\r\n        // };\r\n\r\n        // Private\r\n\r\n        function updateSelected (el) {\r\n          el.selected = $datepicker.$isSelected(el.date);\r\n          el.focused = el.selected;\r\n        }\r\n\r\n        function focusElement () {\r\n          element[0].focus();\r\n        }\r\n\r\n        // Overrides\r\n\r\n        // The datepicker will override the init functionality of the tool\r\n        var _init = $datepicker.init;\r\n        /**\r\n         * Initialize the datepicker.\r\n         */\r\n        $datepicker.init = function () {\r\n          if (isNative && options.useNative) {\r\n            element.prop('type', 'date');\r\n            element.css('-webkit-appearance', 'textfield');\r\n            return;\r\n          } else if (isTouch) {\r\n            element.prop('type', 'text');\r\n            element.attr('readonly', 'true');\r\n            element.on('click', focusElement);\r\n          }\r\n          _init();\r\n        };\r\n\r\n        // The datepicker will override the destroy functionalty of the tooltip. Storing a ref to the\r\n        // tooltip's destroy function so that it can be invoked when the datepicker needs to be destroyed.\r\n        var _destroy = $datepicker.destroy;\r\n\r\n        /**\r\n         * Destroys the datepicker by removing bound events. Calls the destroy function on the tooltip.\r\n         */\r\n        $datepicker.destroy = function () {\r\n          if (isNative && options.useNative) {\r\n            element.off('click', focusElement);\r\n          }\r\n          _destroy();\r\n        };\r\n\r\n        // The datepicker will override the show functionality of the tooltip. Store a ref to the\r\n        // tooltip's show function so that it can be invoked at the appropriate time when the picker\r\n        // is to be shown.\r\n        var _show = $datepicker.show;\r\n\r\n        /**\r\n         * Override for the tooltip's show function.\r\n         *\r\n         * Checks the element for readonly or disabled before showing the \"tooltip\".\r\n         * Once shown it sets up the appropriate events.\r\n         */\r\n        $datepicker.show = function show () {\r\n          // If the input the directive is bound to is readonly or disabled then do not show a picker.\r\n          if ((!isTouch && element.attr('readonly')) || element.attr('disabled')) return;\r\n\r\n          // Call the \"overriden base\" function on the tooltip.\r\n          _show();\r\n\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed imediately.\r\n          $timeout(function () {\r\n            // if $datepicker is no longer showing, don't setup events\r\n            if (!$datepicker.$isShown) return;\r\n\r\n            // Update assistive technologies for view changes:\r\n            $datepicker.$element.attr('aria-hidden', 'false');\r\n            element.attr('aria-expanded', 'true');\r\n\r\n            // Setup the event mouse click event. TODO: Can this be wired up in the view?\r\n            $datepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\r\n\r\n            // If keyboard navigation is enabled (true by default).\r\n            if (options.keyboard) {\r\n              // $datepicker.$element.on('keydown', $datepicker.$onKeyDown);\r\n              // Check to see if the table element should receive the focus when the picker is shown.\r\n              if (options.focusOnOpen) {\r\n                // Focus the table element.\r\n                // $datepicker.$element.find('table')[0].focus();\r\n                // $datepicker.$element.on('focusout', $datepicker.$onFocusOut);\r\n              } else {\r\n                element.on('keydown', $datepicker.$onKeyDown);\r\n              }\r\n            }\r\n          }, 0, false);\r\n        };\r\n\r\n        // The datepicker will override the hide functionality of the tooltip. Store a ref to the\r\n        // tooltip's show function so that it can be invoked at the appropriate time when the picker\r\n        // is to be hidden.\r\n        var _hide = $datepicker.hide;\r\n\r\n        /**\r\n         * Overrid efor the tooltip's hide function.\r\n         *\r\n         * Updates attributes for assistive technologies and unbinds events.\r\n         */\r\n        $datepicker.hide = function (blur) {\r\n          // If the picker is already hidden don't do anything.\r\n          if (!$datepicker.$isShown) return;\r\n\r\n          // Update the attributes used by assisteive technologies\r\n          $datepicker.$element.attr('aria-hidden', 'true');\r\n          element.attr('aria-expanded', 'false');\r\n\r\n          // Unbind the mouse and touch events\r\n          $datepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\r\n\r\n          // If keyboard events were bound then unbind them.\r\n          if (options.keyboard) {\r\n            element.off('keydown', $datepicker.$onKeyDown);\r\n            $datepicker.$element.off('keydown', $datepicker.$onKeyDown);\r\n          }\r\n          if (options.focusOnOpen) {\r\n            // $datepicker.$element.off('focusout', $datepicker.$onFocusOut);\r\n            element[0].focus();\r\n          }\r\n          // Call the tooltip's hide function.\r\n          _hide(blur);\r\n        };\r\n\r\n        return $datepicker;\r\n      }\r\n\r\n      DatepickerFactory.defaults = defaults;\r\n      return DatepickerFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsDatepicker', function ($window, $parse, $q, $dateFormatter, $dateParser, $datepicker) {\r\n\r\n    // var defaults = $datepicker.defaults;\r\n    var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        // Directive options\r\n        var options = {\r\n          scope: scope\r\n        };\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'autoclose', 'dateType', 'dateFormat', 'timezone', 'modelDateFormat', 'dayFormat', 'strictFormat', 'startWeek', 'startDate', 'useNative', 'lang', 'startView', 'minView', 'iconLeft', 'iconRight', 'daysOfWeekDisabled', 'id', 'prefixClass', 'prefixEvent', 'hasToday', 'hasClear', 'focusOnOpen', 'labelNext', 'labelPrevious', 'labelMonth', 'labelYear', 'labelDays'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container', 'autoclose', 'useNative', 'hasToday', 'hasClear', 'focusOnOpen'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\r\n            options[key] = false;\r\n          }\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Initialize datepicker\r\n        var datepicker = $datepicker(element, controller, options);\r\n        options = datepicker.$options;\r\n        // Set expected iOS format\r\n        if (isNative && options.useNative) options.dateFormat = 'yyyy-MM-dd';\r\n\r\n        var lang = options.lang;\r\n\r\n        var formatDate = function (date, format) {\r\n          return $dateFormatter.formatDate(date, format, lang);\r\n        };\r\n\r\n        var dateParser = $dateParser({\r\n          format: options.dateFormat,\r\n          lang: lang,\r\n          strict: options.strictFormat\r\n        });\r\n\r\n        // Visibility binding support\r\n        if (attr.bsShow) {\r\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\r\n            if (!datepicker || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(datepicker),?/i);\r\n            if (newValue === true) {\r\n              datepicker.show();\r\n            } else {\r\n              datepicker.hide();\r\n            }\r\n          });\r\n        }\r\n\r\n        // Observe attributes for changes\r\n        angular.forEach(['minDate', 'maxDate'], function (key) {\r\n          // console.warn('attr.$observe(%s)', key, attr[key]);\r\n          if (angular.isDefined(attr[key])) {\r\n            attr.$observe(key, function (newValue) {\r\n              // console.warn('attr.$observe(%s)=%o', key, newValue);\r\n              datepicker.$options[key] = dateParser.getDateForAttribute(key, newValue);\r\n              // Build only if dirty\r\n              if (!isNaN(datepicker.$options[key])) datepicker.$build(false);\r\n              validateAgainstMinMaxDate(controller.$dateValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Observe date format\r\n        if (angular.isDefined(attr.dateFormat)) {\r\n          attr.$observe('dateFormat', function (newValue) {\r\n            datepicker.$options.dateFormat = newValue;\r\n          });\r\n        }\r\n\r\n        // Watch model for changes\r\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\r\n          datepicker.update(controller.$dateValue);\r\n        }, true);\r\n\r\n        // Normalize undefined/null/empty array,\r\n        // so that we don't treat changing from undefined->null as a change.\r\n        function normalizeDateRanges (ranges) {\r\n          if (!ranges || !ranges.length) return null;\r\n          return ranges;\r\n        }\r\n\r\n        if (angular.isDefined(attr.disabledDates)) {\r\n          scope.$watch(attr.disabledDates, function (disabledRanges, previousValue) {\r\n            disabledRanges = normalizeDateRanges(disabledRanges);\r\n            previousValue = normalizeDateRanges(previousValue);\r\n\r\n            if (disabledRanges) {\r\n              datepicker.updateDisabledDates(disabledRanges);\r\n            }\r\n          });\r\n        }\r\n\r\n        function validateAgainstMinMaxDate (parsedDate) {\r\n          if (!angular.isDate(parsedDate)) return;\r\n          var isMinValid = isNaN(datepicker.$options.minDate) || parsedDate.getTime() >= datepicker.$options.minDate;\r\n          var isMaxValid = isNaN(datepicker.$options.maxDate) || parsedDate.getTime() <= datepicker.$options.maxDate;\r\n          var isValid = isMinValid && isMaxValid;\r\n          controller.$setValidity('date', isValid);\r\n          controller.$setValidity('min', isMinValid);\r\n          controller.$setValidity('max', isMaxValid);\r\n          // Only update the model when we have a valid date\r\n          if (isValid) controller.$dateValue = parsedDate;\r\n        }\r\n\r\n        // viewValue -> $parsers -> modelValue\r\n        controller.$parsers.unshift(function (viewValue) {\r\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\r\n          var date;\r\n          // Null values should correctly reset the model value & validity\r\n          if (!viewValue) {\r\n            controller.$setValidity('date', true);\r\n            // BREAKING CHANGE:\r\n            // return null (not undefined) when input value is empty, so angularjs 1.3\r\n            // ngModelController can go ahead and run validators, like ngRequired\r\n            return null;\r\n          }\r\n          var parsedDate = dateParser.parse(viewValue, controller.$dateValue);\r\n          if (!parsedDate || isNaN(parsedDate.getTime())) {\r\n            controller.$setValidity('date', false);\r\n            // return undefined, causes ngModelController to\r\n            // invalidate model value\r\n            return;\r\n          }\r\n          validateAgainstMinMaxDate(parsedDate);\r\n\r\n          if (options.dateType === 'string') {\r\n            date = dateParser.timezoneOffsetAdjust(parsedDate, options.timezone, true);\r\n            return formatDate(date, options.modelDateFormat || options.dateFormat);\r\n          }\r\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\r\n          if (options.dateType === 'number') {\r\n            return date.getTime();\r\n          } else if (options.dateType === 'unix') {\r\n            return date.getTime() / 1000;\r\n          } else if (options.dateType === 'iso') {\r\n            return date.toISOString();\r\n          }\r\n          return new Date(date);\r\n        });\r\n\r\n        // modelValue -> $formatters -> viewValue\r\n        controller.$formatters.push(function (modelValue) {\r\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n          var date;\r\n          if (angular.isUndefined(modelValue) || modelValue === null) {\r\n            date = NaN;\r\n          } else if (angular.isDate(modelValue)) {\r\n            date = modelValue;\r\n          } else if (options.dateType === 'string') {\r\n            date = dateParser.parse(modelValue, null, options.modelDateFormat);\r\n          } else if (options.dateType === 'unix') {\r\n            date = new Date(modelValue * 1000);\r\n          } else {\r\n            date = new Date(modelValue);\r\n          }\r\n          // Setup default value?\r\n          // if (isNaN(date.getTime())) {\r\n          //   var today = new Date();\r\n          //   date = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0);\r\n          // }\r\n          // do not adjust date if timezone is UTC\r\n          if (options.timezone === 'UTC') {\r\n            controller.$dateValue = date;\r\n          } else {\r\n            controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\r\n          }\r\n          return getDateFormattedString();\r\n        });\r\n\r\n        // viewValue -> element\r\n        controller.$render = function () {\r\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\r\n          element.val(getDateFormattedString());\r\n        };\r\n\r\n        function getDateFormattedString () {\r\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.dateFormat);\r\n        }\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (datepicker) datepicker.destroy();\r\n          options = null;\r\n          datepicker = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsDatepickerDisplay', function ($datepicker, $dateParser, $dateFormatter) {\r\n    return {\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n        // Directive options\r\n        var options = {\r\n          scope: scope\r\n        };\r\n        angular.forEach(['dateType', 'dateFormat', 'timezone', 'modelDateFormat', 'dayFormat', 'strictFormat', 'lang'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        options = angular.extend({}, $datepicker.defaults, options);\r\n\r\n        var lang = options.lang;\r\n\r\n        var formatDate = function (date, format) {\r\n          return $dateFormatter.formatDate(date, format, lang);\r\n        };\r\n\r\n        var dateParser = $dateParser({\r\n          format: options.dateFormat,\r\n          lang: lang,\r\n          strict: options.strictFormat\r\n        });\r\n\r\n        // Observe attributes for changes\r\n        angular.forEach(['minDate', 'maxDate'], function (key) {\r\n          if (angular.isDefined(attr[key])) {\r\n            attr.$observe(key, function (newValue) {\r\n              options[key] = dateParser.getDateForAttribute(key, newValue);\r\n              validateAgainstMinMaxDate(controller.$dateValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Observe date format\r\n        if (angular.isDefined(attr.dateFormat)) {\r\n          attr.$observe('dateFormat', function (newValue) {\r\n            options.dateFormat = newValue;\r\n          });\r\n        }\r\n\r\n        function validateAgainstMinMaxDate (parsedDate) {\r\n          if (!angular.isDate(parsedDate)) return;\r\n          var isMinValid = isNaN(options.minDate) || parsedDate.getTime() >= options.minDate;\r\n          var isMaxValid = isNaN(options.maxDate) || parsedDate.getTime() <= options.maxDate;\r\n          var isValid = isMinValid && isMaxValid;\r\n          controller.$setValidity('date', isValid);\r\n          controller.$setValidity('min', isMinValid);\r\n          controller.$setValidity('max', isMaxValid);\r\n          // Only update the model when we have a valid date\r\n          if (isValid) controller.$dateValue = parsedDate;\r\n        }\r\n\r\n        // viewValue -> $parsers -> modelValue\r\n        controller.$parsers.unshift(function (viewValue) {\r\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\r\n          var date;\r\n          // Null values should correctly reset the model value & validity\r\n          if (!viewValue) {\r\n            controller.$setValidity('date', true);\r\n            // BREAKING CHANGE:\r\n            // return null (not undefined) when input value is empty, so angularjs 1.3\r\n            // ngModelController can go ahead and run validators, like ngRequired\r\n            return null;\r\n          }\r\n          var parsedDate = dateParser.parse(viewValue, controller.$dateValue);\r\n          if (!parsedDate || isNaN(parsedDate.getTime())) {\r\n            controller.$setValidity('date', false);\r\n            // return undefined, causes ngModelController to\r\n            // invalidate model value\r\n            return;\r\n          }\r\n          validateAgainstMinMaxDate(parsedDate);\r\n\r\n          if (options.dateType === 'string') {\r\n            date = dateParser.timezoneOffsetAdjust(parsedDate, options.timezone, true);\r\n            return formatDate(date, options.modelDateFormat || options.dateFormat);\r\n          }\r\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\r\n          if (options.dateType === 'number') {\r\n            return date.getTime();\r\n          } else if (options.dateType === 'unix') {\r\n            return date.getTime() / 1000;\r\n          } else if (options.dateType === 'iso') {\r\n            return date.toISOString();\r\n          }\r\n\r\n          return date === null ? null : new Date(date);\r\n        });\r\n\r\n        // modelValue -> $formatters -> viewValue\r\n        controller.$formatters.push(function (modelValue) {\r\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n          var date;\r\n          if (angular.isUndefined(modelValue) || modelValue === null) {\r\n            date = NaN;\r\n          } else if (angular.isDate(modelValue)) {\r\n            date = modelValue;\r\n          } else if (options.dateType === 'string') {\r\n            date = dateParser.parse(modelValue, null, options.modelDateFormat);\r\n          } else if (options.dateType === 'unix') {\r\n            date = new Date(modelValue * 1000);\r\n          } else {\r\n            date = new Date(modelValue);\r\n          }\r\n          // Setup default value?\r\n          // if (isNaN(date.getTime())) {\r\n          //   var today = new Date();\r\n          //   date = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0);\r\n          // }\r\n          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\r\n          return getDateFormattedString();\r\n        });\r\n\r\n        function getDateFormattedString () {\r\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.dateFormat);\r\n        }\r\n      }\r\n    };\r\n  })\r\n\r\n  .provider('datepickerViews', function () {\r\n\r\n    // var defaults = this.defaults = {\r\n    //   dayFormat: 'dd',\r\n    //   daySplit: 7\r\n    // };\r\n\r\n    // Split array into smaller arrays\r\n    function split (arr, size) {\r\n      var arrays = [];\r\n      while (arr.length > 0) {\r\n        arrays.push(arr.splice(0, size));\r\n      }\r\n      return arrays;\r\n    }\r\n\r\n    // Modulus operator\r\n    function mod (n, m) {\r\n      return ((n % m) + m) % m;\r\n    }\r\n\r\n    this.$get = function ($dateFormatter, $dateParser, $sce) {\r\n\r\n      return function (picker) {\r\n\r\n        var scope = picker.$scope;\r\n        var options = picker.$options;\r\n\r\n        var lang = options.lang;\r\n        var formatDate = function (date, format) {\r\n          return $dateFormatter.formatDate(date, format, lang);\r\n        };\r\n        var dateParser = $dateParser({\r\n          format: options.dateFormat,\r\n          lang: lang,\r\n          strict: options.strictFormat\r\n        });\r\n\r\n        var weekDaysMin = $dateFormatter.weekdaysShort(lang);\r\n        var weekDaysLong = $dateFormatter.weekdays(lang);\r\n        var weekDaysShortLabels = weekDaysMin.slice(options.startWeek).concat(weekDaysMin.slice(0, options.startWeek));\r\n        var weekDaysLongLabels = weekDaysLong.slice(options.startWeek).concat(weekDaysMin.slice(0, options.startWeek));\r\n\r\n        var weekDaysLabelsHtml = '';\r\n        for (var i = 0; i < weekDaysShortLabels.length; i++) {\r\n          var weekDayShortLabel = weekDaysShortLabels[i];\r\n          var weekDayLabel = weekDaysLongLabels[i];\r\n          weekDaysLabelsHtml += '<th scope=\"col\" role=\"columnheader\" class=\"dow text-center\" aria-label=\"' + weekDayLabel + '\"><abbr title=\"' + weekDayLabel + '\">' + weekDayShortLabel + '</abbr></th>';\r\n        }\r\n        weekDaysLabelsHtml = $sce.trustAsHtml(weekDaysLabelsHtml);\r\n\r\n        var startDate = picker.$date || (options.startDate ? dateParser.getDateForAttribute('startDate', options.startDate) : new Date());\r\n        var viewDate = {\r\n          year: startDate.getFullYear(),\r\n          month: startDate.getMonth(),\r\n          date: startDate.getDate()\r\n        };\r\n\r\n        var views = [{\r\n          format: options.dayFormat,\r\n          split: 7,\r\n          steps: {\r\n            month: 1\r\n          },\r\n          update: function (date, force) {\r\n            if (!this.built || force || date.getFullYear() !== viewDate.year || date.getMonth() !== viewDate.month) {\r\n              angular.extend(viewDate, {\r\n                year: picker.$date.getFullYear(),\r\n                month: picker.$date.getMonth(),\r\n                date: picker.$date.getDate()\r\n              });\r\n              picker.$build();\r\n            } else if (date.getDate() !== viewDate.date || date.getDate() === 1) {\r\n                // chaging picker current month will cause viewDate.date to be set to first day of the month,\r\n                // in $datepicker.$selectPane, so picker would not update selected day display if\r\n                // user picks first day of the new month.\r\n                // As a workaround, we are always forcing update when picked date is first day of month.\r\n              viewDate.date = picker.$date.getDate();\r\n              picker.$updateSelected();\r\n            }\r\n          },\r\n          build: function () {\r\n            var firstDayOfMonth = new Date(viewDate.year, viewDate.month, 1);\r\n            var firstDayOfMonthOffset = firstDayOfMonth.getTimezoneOffset();\r\n            var firstDate = new Date(+firstDayOfMonth - mod(firstDayOfMonth.getDay() - options.startWeek, 7) * 864e5);\r\n            var firstDateOffset = firstDate.getTimezoneOffset();\r\n            var today = dateParser.timezoneOffsetAdjust(new Date(), options.timezone).toDateString();\r\n              // Handle daylight time switch\r\n            if (firstDateOffset !== firstDayOfMonthOffset) firstDate = new Date(+firstDate + (firstDateOffset - firstDayOfMonthOffset) * 60e3);\r\n            var days = [];\r\n            var day;\r\n            var selectedDay;\r\n            var todayDay;\r\n            for (var i = 0; i < 42; i++) { // < 7 * 6\r\n              day = dateParser.daylightSavingAdjust(new Date(firstDate.getFullYear(), firstDate.getMonth(), firstDate.getDate() + i));\r\n              // push the day information onto the collection\r\n              var dayItem = {\r\n                id: options.id !== null && options.id !== undefined ? (options.id + '_cell_' + i) : undefined,\r\n                date: day,\r\n                value: day.getDate(),\r\n                isToday: day.toDateString() === today,\r\n                label: formatDate(day, this.format),\r\n                screenReaderLabel: formatDate(day, $dateFormatter.getDatetimeFormat(options.screenReaderDateFormat)),\r\n                selected: picker.$date && this.isSelected(day),\r\n                muted: day.getMonth() !== viewDate.month,\r\n                disabled: this.isDisabled(day)\r\n              };\r\n\r\n              if (dayItem.selected) selectedDay = dayItem;\r\n              if (dayItem.isToday) todayDay = dayItem;\r\n\r\n              days.push(dayItem);\r\n            }\r\n\r\n            scope.selected = null;\r\n\r\n            var defaultFirstDayTabIndex = false;\r\n            // Setup the focusing\r\n            if (options.focusOnOpen) {\r\n              if (selectedDay) {\r\n                scope.selectedDayId = selectedDay.id;\r\n                if (todayDay) todayDay.focused = false;\r\n                // Needs to fire after the today focusing is unset in case the selected day is today.\r\n                selectedDay.focused = true;\r\n                scope.selected = selectedDay;\r\n              } else if (todayDay) {\r\n                todayDay.focused = true;\r\n              } else {\r\n                defaultFirstDayTabIndex = true;\r\n              }\r\n            }\r\n\r\n            scope.title = formatDate(firstDayOfMonth, options.monthTitleFormat);\r\n            scope.showLabels = true;\r\n            scope.labels = weekDaysLabelsHtml;\r\n            scope.rows = split(days, this.split);\r\n            if (defaultFirstDayTabIndex) {\r\n              scope.rows[0][0].isNext = true;\r\n            }\r\n            scope.isTodayDisabled = this.isDisabled(new Date());\r\n            scope.hasSelectedDate = picker.$date != null;\r\n            scope.$modeLabel = options.labelMonth;\r\n            this.built = true;\r\n          },\r\n          isSelected: function (date) {\r\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear() &&\r\n              date.getMonth() === picker.$date.getMonth() &&\r\n              date.getDate() === picker.$date.getDate();\r\n          },\r\n          isDisabled: function (date) {\r\n            var time = date.getTime();\r\n\r\n              // Disabled because of min/max date.\r\n            if (time < options.minDate || time > options.maxDate) return true;\r\n\r\n              // Disabled due to being a disabled day of the week\r\n            if (options.daysOfWeekDisabled.indexOf(date.getDay()) !== -1) return true;\r\n\r\n              // Disabled because of disabled date range.\r\n            if (options.disabledDateRanges) {\r\n              for (var i = 0; i < options.disabledDateRanges.length; i++) {\r\n                if (time >= options.disabledDateRanges[i].start && time <= options.disabledDateRanges[i].end) {\r\n                  return true;\r\n                }\r\n              }\r\n            }\r\n\r\n            return false;\r\n          },\r\n          onKeyDown: function (evt) {\r\n            var actualTime;\r\n\r\n            // If the picker doesn't have a date selected and the event comes from the today TD\r\n            // then set the picker's $date to today and set the actual time to its value.\r\n            if (options.keyboard &&\r\n              options.focusOnOpen &&\r\n              !picker.$date) {\r\n              if (angular.element(evt.target).find('span').hasClass('btn-today')) {\r\n                picker.$date = new Date();\r\n              } else {\r\n                picker.$date = dateParser.parse(angular.element(evt.target).attr('aria-label'), null, options.screenReaderDateFormat);\r\n              }\r\n            }\r\n\r\n            if (!picker.$date) {\r\n              return false;\r\n            }\r\n\r\n            actualTime = picker.$date.getTime();\r\n\r\n            var newDate;\r\n\r\n            switch (evt.keyCode) {\r\n              // enter\r\n              case 13:\r\n                if (options.focusOnOpen) {\r\n                  picker.select(new Date(actualTime), true);\r\n                  return false;\r\n                }\r\n                break;\r\n              // pageup\r\n              case 33:\r\n                if (evt.altKey) { // move back a year\r\n                  newDate = new Date(picker.$date.getFullYear() - 1, picker.$date.getMonth(), picker.$date.getDate());\r\n                } else { // move back a month\r\n                  newDate = new Date(picker.$date.getFullYear(), picker.$date.getMonth() - 1, picker.$date.getDate());\r\n                  if (newDate.getMonth() > (picker.$date.getMonth() - 1)) {\r\n                    newDate = new Date(picker.$date.getFullYear(), picker.$date.getMonth(), 0);\r\n                  }\r\n                }\r\n                break;\r\n\r\n              // pagedown\r\n              case 34:\r\n                if (evt.altKey) { // move forward a year\r\n                  newDate = new Date(picker.$date.getFullYear() + 1, picker.$date.getMonth(), picker.$date.getDate());\r\n                } else { // move forward a month\r\n                  newDate = new Date(picker.$date.getFullYear(), picker.$date.getMonth() + 1, picker.$date.getDate());\r\n                  if (newDate.getMonth() > (picker.$date.getMonth() + 1)) {\r\n                    newDate = new Date(picker.$date.getFullYear(), picker.$date.getMonth() + 1, 1);\r\n                  }\r\n                }\r\n\r\n                break;\r\n\r\n              // left arrow\r\n              case 37:\r\n                newDate = new Date(actualTime - 1 * 864e5);\r\n                break;\r\n\r\n              // up arrow\r\n              case 38:\r\n                newDate = new Date(actualTime - 7 * 864e5);\r\n                break;\r\n\r\n              // right arrow\r\n              case 39:\r\n                newDate = new Date(actualTime + 1 * 864e5);\r\n                break;\r\n\r\n              // down arrow\r\n              case 40:\r\n                newDate = new Date(actualTime + 7 * 864e5);\r\n                break;\r\n\r\n              default:\r\n                return false;\r\n            }\r\n\r\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\r\n\r\n            if (evt && evt.stopPropagation) evt.stopPropagation();\r\n\r\n            return false;\r\n          }\r\n        }, {\r\n          name: 'month',\r\n          format: options.monthFormat,\r\n          split: 4,\r\n          steps: {\r\n            year: 1\r\n          },\r\n          update: function (date, force) {\r\n            if (!this.built || date.getFullYear() !== viewDate.year) {\r\n              angular.extend(viewDate, {\r\n                year: picker.$date.getFullYear(),\r\n                month: picker.$date.getMonth(),\r\n                date: picker.$date.getDate()\r\n              });\r\n              picker.$build();\r\n            } else if (date.getMonth() !== viewDate.month) {\r\n              angular.extend(viewDate, {\r\n                month: picker.$date.getMonth(),\r\n                date: picker.$date.getDate()\r\n              });\r\n              picker.$updateSelected();\r\n            }\r\n          },\r\n          build: function () {\r\n            // var firstMonth = new Date(viewDate.year, 0, 1);\r\n            var months = [];\r\n            var month;\r\n            var thisMonthDate = new Date((new Date()).getFullYear(), (new Date()).getMonth(), 1);\r\n            var selectedMonth;\r\n            var thisMonth;\r\n            for (var i = 0; i < 12; i++) {\r\n              month = new Date(viewDate.year, i, 1);\r\n\r\n              var monthItem = {\r\n                date: month,\r\n                label: formatDate(month, this.format),\r\n                selected: picker.$isSelected(month),\r\n                isToday: month.getFullYear() === thisMonthDate.getFullYear() && month.getMonth() === thisMonthDate.getMonth(),\r\n                disabled: this.isDisabled(month)\r\n              };\r\n\r\n              if (monthItem.selected) selectedMonth = monthItem;\r\n              if (monthItem.isToday) thisMonth = monthItem;\r\n\r\n              months.push(monthItem);\r\n            }\r\n\r\n            scope.selected = null;\r\n\r\n            var defaultFirstDayTabIndex = false;\r\n            // Setup the focusing\r\n            if (options.focusOnOpen) {\r\n              if (selectedMonth) {\r\n                scope.selectedDayId = selectedMonth.id;\r\n                if (thisMonth) thisMonth.focused = false;\r\n                // Needs to fire after the today focusing is unset in case the selected day is today.\r\n                selectedMonth.focused = true;\r\n                scope.selected = selectedMonth;\r\n              } else if (thisMonth) {\r\n                thisMonth.focused = true;\r\n              } else {\r\n                defaultFirstDayTabIndex = true;\r\n              }\r\n            }\r\n\r\n            scope.title = formatDate(month, options.yearTitleFormat);\r\n            scope.showLabels = false;\r\n            scope.rows = split(months, this.split);\r\n            if (defaultFirstDayTabIndex) {\r\n              scope.rows[0][0].isNext = true;\r\n            }\r\n            scope.$modeLabel = options.labelYear;\r\n            this.built = true;\r\n          },\r\n          isSelected: function (date) {\r\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth();\r\n          },\r\n          isDisabled: function (date) {\r\n            var lastDate = +new Date(date.getFullYear(), date.getMonth() + 1, 0);\r\n            return lastDate < options.minDate || date.getTime() > options.maxDate;\r\n          },\r\n          onKeyDown: function (evt) {\r\n            // If the picker doesn't have a date selected and the event comes from the today TD\r\n            // then set the picker's $date to today and set the actual time to its value.\r\n            if (options.keyboard &&\r\n              options.focusOnOpen &&\r\n              !picker.$date &&\r\n              angular.element(evt.target).find('span').hasClass('btn-today')) {\r\n              picker.$date = new Date((new Date()).getFullYear(), (new Date()).getMonth(), 1);\r\n            }\r\n\r\n            if (!picker.$date) {\r\n              return;\r\n            }\r\n            var actualMonth = picker.$date.getMonth();\r\n            var newDate = new Date(picker.$date);\r\n\r\n            if (evt.keyCode === 37) newDate.setMonth(actualMonth - 1);\r\n            else if (evt.keyCode === 38) newDate.setMonth(actualMonth - 4);\r\n            else if (evt.keyCode === 39) newDate.setMonth(actualMonth + 1);\r\n            else if (evt.keyCode === 40) newDate.setMonth(actualMonth + 4);\r\n\r\n            if (options.focusOnOpen && evt.keyCode === 13) picker.select(new Date(picker.$date));\r\n            else if (!this.isDisabled(newDate)) picker.select(newDate, true);\r\n          }\r\n        }, {\r\n          name: 'year',\r\n          format: options.yearFormat,\r\n          split: 4,\r\n          steps: {\r\n            year: 12\r\n          },\r\n          update: function (date, force) {\r\n            if (!this.built || force || parseInt(date.getFullYear() / 20, 10) !== parseInt(viewDate.year / 20, 10)) {\r\n              angular.extend(viewDate, {\r\n                year: picker.$date.getFullYear(),\r\n                month: picker.$date.getMonth(),\r\n                date: picker.$date.getDate()\r\n              });\r\n              picker.$build();\r\n            } else if (date.getFullYear() !== viewDate.year) {\r\n              angular.extend(viewDate, {\r\n                year: picker.$date.getFullYear(),\r\n                month: picker.$date.getMonth(),\r\n                date: picker.$date.getDate()\r\n              });\r\n              picker.$updateSelected();\r\n            }\r\n          },\r\n          build: function () {\r\n            var firstYear = viewDate.year - viewDate.year % (this.split * 3);\r\n            var years = [];\r\n            var year;\r\n            var selectedYear;\r\n            var thisYear;\r\n            for (var i = 0; i < 12; i++) {\r\n              year = new Date(firstYear + i, 0, 1);\r\n\r\n              var yearItem = {\r\n                date: year,\r\n                label: formatDate(year, this.format),\r\n                selected: picker.$isSelected(year),\r\n                isToday: year.getFullYear() === (new Date()).getFullYear(),\r\n                disabled: this.isDisabled(year)\r\n              };\r\n\r\n              if (yearItem.selected) selectedYear = yearItem;\r\n              if (yearItem.isToday) thisYear = yearItem;\r\n\r\n              years.push(yearItem);\r\n            }\r\n\r\n            scope.selected = null;\r\n\r\n            var defaultFirstDayTabIndex = false;\r\n            // Setup the focusing\r\n            if (options.focusOnOpen) {\r\n              if (selectedYear) {\r\n                scope.selectedDayId = selectedYear.id;\r\n                if (thisYear) thisYear.focused = false;\r\n                // Needs to fire after the today focusing is unset in case the selected day is today.\r\n                selectedYear.focused = true;\r\n                scope.selected = selectedYear;\r\n              } else if (thisYear) {\r\n                thisYear.focused = true;\r\n              } else {\r\n                defaultFirstDayTabIndex = true;\r\n              }\r\n            }\r\n\r\n            scope.title = years[0].label + '-' + years[years.length - 1].label;\r\n            scope.showLabels = false;\r\n            scope.rows = split(years, this.split);\r\n            if (defaultFirstDayTabIndex) {\r\n              scope.rows[0][0].isNext = true;\r\n            }\r\n            scope.$modelLabel = options.labelDays;\r\n            this.built = true;\r\n          },\r\n          isSelected: function (date) {\r\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear();\r\n          },\r\n          isDisabled: function (date) {\r\n            var lastDate = +new Date(date.getFullYear() + 1, 0, 0);\r\n            return lastDate < options.minDate || date.getTime() > options.maxDate;\r\n          },\r\n          onKeyDown: function (evt) {\r\n            // If the picker doesn't have a date selected and the event comes from the today TD\r\n            // then set the picker's $date to today and set the actual time to its value.\r\n            if (options.keyboard &&\r\n              options.focusOnOpen &&\r\n              !picker.$date &&\r\n              angular.element(evt.target).find('span').hasClass('btn-today')) {\r\n              picker.$date = new Date((new Date()).getFullYear(), 0, 1);\r\n            }\r\n\r\n            if (!picker.$date) {\r\n              return;\r\n            }\r\n            var actualYear = picker.$date.getFullYear();\r\n            var newDate = new Date(picker.$date);\r\n\r\n            if (evt.keyCode === 37) newDate.setYear(actualYear - 1);\r\n            else if (evt.keyCode === 38) newDate.setYear(actualYear - 4);\r\n            else if (evt.keyCode === 39) newDate.setYear(actualYear + 1);\r\n            else if (evt.keyCode === 40) newDate.setYear(actualYear + 4);\r\n\r\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\r\n          }\r\n        }];\r\n\r\n        return {\r\n          views: options.minView ? Array.prototype.slice.call(views, options.minView) : views,\r\n          viewDate: viewDate\r\n        };\r\n\r\n      };\r\n\r\n    };\r\n\r\n  });\r\n\r\n// Source: collapse\\collapse.js\r\nangular.module('mgcrea.ngStrap.collapse', [])\r\n\r\n  .provider('$collapse', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-collapse',\r\n      disallowToggle: false,\r\n      activeClass: 'in',\r\n      startCollapsed: false,\r\n      allowMultiple: false\r\n    };\r\n\r\n    var controller = this.controller = function ($scope, $element, $attrs) {\r\n      var self = this;\r\n\r\n      // Attributes options\r\n      self.$options = angular.copy(defaults);\r\n      angular.forEach(['animation', 'disallowToggle', 'activeClass', 'startCollapsed', 'allowMultiple'], function (key) {\r\n        if (angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\r\n      });\r\n\r\n      // use string regex match boolean attr falsy values, leave truthy values be\r\n      var falseValueRegExp = /^(false|0|)$/i;\r\n      angular.forEach(['disallowToggle', 'startCollapsed', 'allowMultiple'], function (key) {\r\n        if (angular.isDefined($attrs[key]) && falseValueRegExp.test($attrs[key])) {\r\n          self.$options[key] = false;\r\n        }\r\n      });\r\n\r\n      self.$toggles = [];\r\n      self.$targets = [];\r\n\r\n      self.$viewChangeListeners = [];\r\n\r\n      self.$registerToggle = function (element) {\r\n        self.$toggles.push(element);\r\n        element.attr('aria-expanded', 'false');\r\n      };\r\n      self.$registerTarget = function (element) {\r\n        self.$targets.push(element);\r\n\r\n        var i = 0;\r\n        if (self.$targets) {\r\n          for (i = 0; i < self.$targets.length; i++) {\r\n            self.$targets[i].attr('aria-hidden', 'true');\r\n          }\r\n          for (i = 0; i < self.$targets.$active.length; i++) {\r\n            if (self.$targets[self.$targets.$active[i]]) {\r\n              self.$targets[self.$targets.$active[i]].attr('aria-hidden', 'false');\r\n            }\r\n            if (self.$toggles[self.$targets.$active[i]]) {\r\n              self.$toggles[self.$targets.$active[i]].attr('aria-expanded', 'true');\r\n            }\r\n          }\r\n        }\r\n      };\r\n\r\n      self.$unregisterToggle = function (element) {\r\n        var index = self.$toggles.indexOf(element);\r\n        // remove toggle from $toggles array\r\n        self.$toggles.splice(index, 1);\r\n      };\r\n      self.$unregisterTarget = function (element) {\r\n        var index = self.$targets.indexOf(element);\r\n\r\n        // remove element from $targets array\r\n        self.$targets.splice(index, 1);\r\n\r\n        if (self.$options.allowMultiple) {\r\n          // remove target index from $active array values\r\n          deactivateItem(element);\r\n        }\r\n\r\n        // fix active item indexes\r\n        fixActiveItemIndexes(index);\r\n\r\n        self.$viewChangeListeners.forEach(function (fn) {\r\n          fn();\r\n        });\r\n      };\r\n\r\n      // use array to store all the currently open panels\r\n      self.$targets.$active = !self.$options.startCollapsed ? [0] : [];\r\n      self.$setActive = $scope.$setActive = function (value) {\r\n        if (angular.isArray(value)) {\r\n          self.$targets.$active = value;\r\n        } else if (!self.$options.disallowToggle && isActive(value)) {\r\n          deactivateItem(value);\r\n        } else {\r\n          activateItem(value);\r\n        }\r\n\r\n        self.$viewChangeListeners.forEach(function (fn) {\r\n          fn();\r\n        });\r\n      };\r\n\r\n      self.$activeIndexes = function () {\r\n        if (self.$options.allowMultiple) {\r\n          return self.$targets.$active;\r\n        }\r\n        return self.$targets.$active.length === 1 ? self.$targets.$active[0] : -1;\r\n      };\r\n\r\n      function fixActiveItemIndexes (index) {\r\n        // item with index was removed, so we\r\n        // need to adjust other items index values\r\n        var activeIndexes = self.$targets.$active;\r\n        for (var i = 0; i < activeIndexes.length; i++) {\r\n          if (index < activeIndexes[i]) {\r\n            activeIndexes[i] = activeIndexes[i] - 1;\r\n          }\r\n\r\n          // the last item is active, so we need to\r\n          // adjust its index\r\n          if (activeIndexes[i] === self.$targets.length) {\r\n            activeIndexes[i] = self.$targets.length - 1;\r\n          }\r\n        }\r\n      }\r\n\r\n      function isActive (value) {\r\n        var activeItems = self.$targets.$active;\r\n        return activeItems.indexOf(value) !== -1;\r\n      }\r\n\r\n      function deactivateItem (value) {\r\n        var index = self.$targets.$active.indexOf(value);\r\n        if (index !== -1) {\r\n          self.$targets[self.$targets.$active[index]].attr('aria-hidden', 'true');\r\n          self.$toggles[self.$targets.$active[index]].attr('aria-expanded', 'false');\r\n          self.$targets.$active.splice(index, 1);\r\n        }\r\n      }\r\n\r\n      function activateItem (value) {\r\n        if (!self.$options.allowMultiple) {\r\n          // remove current selected item\r\n          if (self.$targets[self.$targets.$active[0]] !== undefined) {\r\n            self.$targets[self.$targets.$active[0]].attr('aria-hidden', 'true');\r\n          }\r\n          if (self.$toggles[self.$targets.$active[0]]) {\r\n            self.$toggles[self.$targets.$active[0]].attr('aria-expanded', 'false');\r\n          }\r\n          self.$targets.$active.splice(0, 1);\r\n        }\r\n\r\n        if (self.$targets.$active.indexOf(value) === -1) {\r\n          self.$targets.$active.push(value);\r\n\r\n          if (self.$targets[self.$targets.$active[self.$targets.$active.length - 1]] !== undefined) {\r\n            self.$targets[self.$targets.$active[self.$targets.$active.length - 1]].attr('aria-hidden', 'false');\r\n          }\r\n          if (self.$toggles[self.$targets.$active[self.$targets.$active.length - 1]] !== undefined) {\r\n            self.$toggles[self.$targets.$active[self.$targets.$active.length - 1]].attr('aria-expanded', 'true');\r\n          }\r\n        }\r\n      }\r\n\r\n    };\r\n\r\n    this.$get = function () {\r\n      var $collapse = {};\r\n      $collapse.defaults = defaults;\r\n      $collapse.controller = controller;\r\n      return $collapse;\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsCollapse', function ($window, $animate, $collapse) {\r\n\r\n    return {\r\n      require: ['?ngModel', 'bsCollapse'],\r\n      controller: ['$scope', '$element', '$attrs', $collapse.controller],\r\n      link: function postLink (scope, element, attrs, controllers) {\r\n\r\n        var ngModelCtrl = controllers[0];\r\n        var bsCollapseCtrl = controllers[1];\r\n\r\n        if (ngModelCtrl) {\r\n\r\n          // Update the modelValue following\r\n          bsCollapseCtrl.$viewChangeListeners.push(function () {\r\n            ngModelCtrl.$setViewValue(bsCollapseCtrl.$activeIndexes());\r\n          });\r\n\r\n          // modelValue -> $formatters -> viewValue\r\n          ngModelCtrl.$formatters.push(function (modelValue) {\r\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n            if (angular.isArray(modelValue)) {\r\n              // model value is an array, so just replace\r\n              // the active items directly\r\n              bsCollapseCtrl.$setActive(modelValue);\r\n            } else {\r\n              var activeIndexes = bsCollapseCtrl.$activeIndexes();\r\n\r\n              if (angular.isArray(activeIndexes)) {\r\n                // we have an array of selected indexes\r\n                if (activeIndexes.indexOf(modelValue * 1) === -1) {\r\n                  // item with modelValue index is not active\r\n                  bsCollapseCtrl.$setActive(modelValue * 1);\r\n                }\r\n              } else if (activeIndexes !== modelValue * 1) {\r\n                bsCollapseCtrl.$setActive(modelValue * 1);\r\n              }\r\n            }\r\n            return modelValue;\r\n          });\r\n\r\n        }\r\n\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsCollapseToggle', function () {\r\n\r\n    return {\r\n      require: ['^?ngModel', '^bsCollapse'],\r\n      link: function postLink (scope, element, attrs, controllers) {\r\n\r\n        // var ngModelCtrl = controllers[0];\r\n        var bsCollapseCtrl = controllers[1];\r\n\r\n        // Add base attr\r\n        element.attr('data-toggle', 'collapse');\r\n\r\n        // Push pane to parent bsCollapse controller\r\n        bsCollapseCtrl.$registerToggle(element);\r\n\r\n        // remove toggle from collapse controller when toggle is destroyed\r\n        scope.$on('$destroy', function () {\r\n          bsCollapseCtrl.$unregisterToggle(element);\r\n        });\r\n\r\n        var actionEventHandler = function () {\r\n          if (!attrs.disabled) {\r\n            var index = attrs.bsCollapseToggle && attrs.bsCollapseToggle !== 'bs-collapse-toggle' ? attrs.bsCollapseToggle : bsCollapseCtrl.$toggles.indexOf(element);\r\n            bsCollapseCtrl.$setActive(index * 1);\r\n            scope.$apply();\r\n          }\r\n        };\r\n\r\n        element.on('click', actionEventHandler);\r\n        element.bind('keydown keypress', function (e) {\r\n          if (e.which === 13 || e.which === 32) {\r\n            actionEventHandler();\r\n            e.preventDefault();\r\n          } else if (e.which !== 16 && e.which !== 9) {\r\n            e.preventDefault();\r\n          }\r\n        });\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsCollapseTarget', function ($animate) {\r\n\r\n    return {\r\n      require: ['^?ngModel', '^bsCollapse'],\r\n      // scope: true,\r\n      link: function postLink (scope, element, attrs, controllers) {\r\n\r\n        // var ngModelCtrl = controllers[0];\r\n        var bsCollapseCtrl = controllers[1];\r\n\r\n        // Add base class\r\n        element.addClass('collapse');\r\n\r\n        // Add animation class\r\n        if (bsCollapseCtrl.$options.animation) {\r\n          element.addClass(bsCollapseCtrl.$options.animation);\r\n        }\r\n\r\n        // Push pane to parent bsCollapse controller\r\n        bsCollapseCtrl.$registerTarget(element);\r\n\r\n        // remove pane target from collapse controller when target is destroyed\r\n        scope.$on('$destroy', function () {\r\n          bsCollapseCtrl.$unregisterTarget(element);\r\n        });\r\n\r\n        function render () {\r\n          var index = bsCollapseCtrl.$targets.indexOf(element);\r\n          var active = bsCollapseCtrl.$activeIndexes();\r\n          var action = 'removeClass';\r\n          if (angular.isArray(active)) {\r\n            if (active.indexOf(index) !== -1) {\r\n              action = 'addClass';\r\n            }\r\n          } else if (index === active) {\r\n            action = 'addClass';\r\n          }\r\n\r\n          $animate[action](element, bsCollapseCtrl.$options.activeClass);\r\n        }\r\n\r\n        bsCollapseCtrl.$viewChangeListeners.push(function () {\r\n          render();\r\n        });\r\n        render();\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n\r\n// Source: button\\button.js\r\nangular.module('mgcrea.ngStrap.button', [])\r\n\r\n  .provider('$button', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      activeClass: 'active',\r\n      toggleEvent: 'click'\r\n    };\r\n\r\n    this.$get = function () {\r\n      return {defaults: defaults};\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsCheckboxGroup', function () {\r\n\r\n    return {\r\n      restrict: 'A',\r\n      require: 'ngModel',\r\n      compile: function postLink (element, attr) {\r\n        element.attr('data-toggle', 'buttons');\r\n        element.removeAttr('ng-model');\r\n        var children = element[0].querySelectorAll('input[type=\"checkbox\"]');\r\n        angular.forEach(children, function (child) {\r\n          var childEl = angular.element(child);\r\n          childEl.attr('bs-checkbox', '');\r\n          childEl.attr('ng-model', attr.ngModel + '.' + childEl.attr('value'));\r\n        });\r\n      }\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsCheckbox', function ($button, $$rAF) {\r\n\r\n    var defaults = $button.defaults;\r\n    var constantValueRegExp = /^(true|false|\\d+)$/;\r\n\r\n    return {\r\n      restrict: 'A',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        var options = defaults;\r\n\r\n        // Support label > input[type=\"checkbox\"]\r\n        var isInput = element[0].nodeName === 'INPUT';\r\n        var activeElement = isInput ? element.parent() : element;\r\n\r\n        var trueValue = angular.isDefined(attr.trueValue) ? attr.trueValue : true;\r\n        if (constantValueRegExp.test(attr.trueValue)) {\r\n          trueValue = scope.$eval(attr.trueValue);\r\n        }\r\n        var falseValue = angular.isDefined(attr.falseValue) ? attr.falseValue : false;\r\n        if (constantValueRegExp.test(attr.falseValue)) {\r\n          falseValue = scope.$eval(attr.falseValue);\r\n        }\r\n\r\n        // Parse exotic values\r\n        var hasExoticValues = typeof trueValue !== 'boolean' || typeof falseValue !== 'boolean';\r\n        if (hasExoticValues) {\r\n          controller.$parsers.push(function (viewValue) {\r\n            // console.warn('$parser', element.attr('ng-model'), 'viewValue', viewValue);\r\n            return viewValue ? trueValue : falseValue;\r\n          });\r\n          // modelValue -> $formatters -> viewValue\r\n          controller.$formatters.push(function (modelValue) {\r\n             // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n            return angular.equals(modelValue, trueValue);\r\n          });\r\n        }\r\n\r\n        // model -> view\r\n        controller.$render = function () {\r\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\r\n          var isActive = !!controller.$viewValue;\r\n          $$rAF(function () {\r\n            if (isInput) element[0].checked = isActive;\r\n            activeElement.toggleClass(options.activeClass, isActive);\r\n          });\r\n        };\r\n\r\n        // view -> model\r\n        element.bind(options.toggleEvent, function () {\r\n          scope.$apply(function () {\r\n            // console.warn('!click', element.attr('ng-model'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\r\n            if (!isInput) {\r\n              controller.$setViewValue(!activeElement.hasClass('active'));\r\n            }\r\n            controller.$render();\r\n          });\r\n        });\r\n\r\n      }\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsRadioGroup', function () {\r\n\r\n    return {\r\n      restrict: 'A',\r\n      require: 'ngModel',\r\n      compile: function postLink (element, attr) {\r\n        element.attr('data-toggle', 'buttons');\r\n        element.removeAttr('ng-model');\r\n        var children = element[0].querySelectorAll('input[type=\"radio\"]');\r\n        angular.forEach(children, function (child) {\r\n          angular.element(child).attr('bs-radio', '');\r\n          angular.element(child).attr('ng-model', attr.ngModel);\r\n        });\r\n      }\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsRadio', function ($button, $$rAF) {\r\n\r\n    var defaults = $button.defaults;\r\n    var constantValueRegExp = /^(true|false|\\d+)$/;\r\n\r\n    return {\r\n      restrict: 'A',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        var options = defaults;\r\n\r\n        // Support `label > input[type=\"radio\"]` markup\r\n        var isInput = element[0].nodeName === 'INPUT';\r\n        var activeElement = isInput ? element.parent() : element;\r\n\r\n        var value;\r\n        attr.$observe('value', function (v) {\r\n          if (typeof v !== 'boolean' && constantValueRegExp.test(v)) {\r\n            value = scope.$eval(v);\r\n          } else {\r\n            value = v;\r\n          }\r\n          controller.$render();\r\n        });\r\n\r\n        // model -> view\r\n        controller.$render = function () {\r\n          // console.warn('$render', element.attr('value'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\r\n          var isActive = angular.equals(controller.$viewValue, value);\r\n          $$rAF(function () {\r\n            if (isInput) element[0].checked = isActive;\r\n            activeElement.toggleClass(options.activeClass, isActive);\r\n          });\r\n        };\r\n\r\n        // view -> model\r\n        element.bind(options.toggleEvent, function () {\r\n          scope.$apply(function () {\r\n            // console.warn('!click', element.attr('value'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\r\n            controller.$setViewValue(value);\r\n            controller.$render();\r\n          });\r\n        });\r\n\r\n      }\r\n\r\n    };\r\n\r\n  });\r\n\r\n// Source: aside\\aside.js\r\nangular.module('mgcrea.ngStrap.aside', ['mgcrea.ngStrap.modal'])\r\n\r\n  .provider('$aside', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade-and-slide-right',\r\n      prefixClass: 'aside',\r\n      prefixEvent: 'aside',\r\n      placement: 'right',\r\n      templateUrl: 'aside/aside.tpl.html',\r\n      contentTemplate: false,\r\n      container: false,\r\n      element: null,\r\n      backdrop: true,\r\n      keyboard: true,\r\n      html: false,\r\n      show: true\r\n    };\r\n\r\n    this.$get = function ($modal) {\r\n\r\n      function AsideFactory (config) {\r\n\r\n        var $aside = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n\r\n        $aside = $modal(options);\r\n\r\n        return $aside;\r\n\r\n      }\r\n\r\n      return AsideFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsAside', function ($window, $sce, $aside) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink (scope, element, attr, transclusion) {\r\n        // Directive options\r\n        var options = {scope: scope, element: element, show: false};\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['backdrop', 'keyboard', 'html', 'container'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Support scope as data-attrs\r\n        angular.forEach(['title', 'content'], function (key) {\r\n          if (attr[key]) {\r\n            attr.$observe(key, function (newValue, oldValue) {\r\n              scope[key] = $sce.trustAsHtml(newValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Support scope as an object\r\n        if (attr.bsAside) {\r\n          scope.$watch(attr.bsAside, function (newValue, oldValue) {\r\n            if (angular.isObject(newValue)) {\r\n              angular.extend(scope, newValue);\r\n            } else {\r\n              scope.content = newValue;\r\n            }\r\n          }, true);\r\n        }\r\n\r\n        // Initialize aside\r\n        var aside = $aside(options);\r\n\r\n        // Trigger\r\n        element.on(attr.trigger || 'click', aside.toggle);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (aside) aside.destroy();\r\n          options = null;\r\n          aside = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n\r\n// Source: alert\\alert.js\r\n// @BUG: following snippet won't compile correctly\r\n\r\nangular.module('mgcrea.ngStrap.alert', ['mgcrea.ngStrap.modal'])\r\n\r\n  .provider('$alert', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      prefixClass: 'alert',\r\n      prefixEvent: 'alert',\r\n      placement: null,\r\n      templateUrl: 'alert/alert.tpl.html',\r\n      container: false,\r\n      element: null,\r\n      backdrop: false,\r\n      keyboard: true,\r\n      show: true,\r\n      // Specific options\r\n      duration: false,\r\n      type: false,\r\n      dismissable: true\r\n    };\r\n\r\n    this.$get = function ($modal, $timeout) {\r\n\r\n      function AlertFactory (config) {\r\n\r\n        var $alert = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n\r\n        $alert = $modal(options);\r\n\r\n        // Support scope as string options [/*title, content, */ type, dismissable]\r\n        $alert.$scope.dismissable = !!options.dismissable;\r\n        if (options.type) {\r\n          $alert.$scope.type = options.type;\r\n        }\r\n\r\n        // Support auto-close duration\r\n        var show = $alert.show;\r\n        if (options.duration) {\r\n          $alert.show = function () {\r\n            show();\r\n            $timeout(function () {\r\n              $alert.hide();\r\n            }, options.duration * 1000);\r\n          };\r\n        }\r\n\r\n        return $alert;\r\n\r\n      }\r\n\r\n      return AlertFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsAlert', function ($window, $sce, $alert) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink (scope, element, attr, transclusion) {\r\n\r\n        // Directive options\r\n        var options = {scope: scope, element: element, show: false};\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'keyboard', 'html', 'container', 'animation', 'duration', 'dismissable'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['keyboard', 'html', 'container', 'dismissable'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // overwrite inherited title value when no value specified\r\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\r\n        if (!scope.hasOwnProperty('title')) {\r\n          scope.title = '';\r\n        }\r\n\r\n        // Support scope as data-attrs\r\n        angular.forEach(['title', 'content', 'type'], function (key) {\r\n          if (attr[key]) {\r\n            attr.$observe(key, function (newValue, oldValue) {\r\n              scope[key] = $sce.trustAsHtml(newValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Support scope as an object\r\n        if (attr.bsAlert) {\r\n          scope.$watch(attr.bsAlert, function (newValue, oldValue) {\r\n            if (angular.isObject(newValue)) {\r\n              angular.extend(scope, newValue);\r\n            } else {\r\n              scope.content = newValue;\r\n            }\r\n          }, true);\r\n        }\r\n\r\n        // Initialize alert\r\n        var alert = $alert(options);\r\n\r\n        // Trigger\r\n        element.on(attr.trigger || 'click', alert.toggle);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (alert) alert.destroy();\r\n          options = null;\r\n          alert = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n\r\n// Source: affix\\affix.js\r\nangular.module('mgcrea.ngStrap.affix', ['mgcrea.ngStrap.helpers.dimensions', 'mgcrea.ngStrap.helpers.debounce'])\r\n\r\n  .provider('$affix', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      offsetTop: 'auto',\r\n      inlineStyles: true,\r\n      setWidth: true\r\n    };\r\n\r\n    this.$get = function ($window, debounce, dimensions) {\r\n\r\n      var bodyEl = angular.element($window.document.body);\r\n      var windowEl = angular.element($window);\r\n\r\n      function AffixFactory (element, config) {\r\n\r\n        var $affix = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n        var targetEl = options.target;\r\n\r\n        // Initial private vars\r\n        var reset = 'affix affix-top affix-bottom';\r\n        var setWidth = false;\r\n        var initialAffixTop = 0;\r\n        var initialOffsetTop = 0;\r\n        var offsetTop = 0;\r\n        var offsetBottom = 0;\r\n        var affixed = null;\r\n        var unpin = null;\r\n\r\n        var parent = element.parent();\r\n        // Options: custom parent\r\n        if (options.offsetParent) {\r\n          if (options.offsetParent.match(/^\\d+$/)) {\r\n            for (var i = 0; i < (options.offsetParent * 1) - 1; i++) {\r\n              parent = parent.parent();\r\n            }\r\n          } else {\r\n            parent = angular.element(options.offsetParent);\r\n          }\r\n        }\r\n\r\n        $affix.init = function () {\r\n\r\n          this.$parseOffsets();\r\n          initialOffsetTop = dimensions.offset(element[0]).top + initialAffixTop;\r\n          setWidth = options.setWidth && !element[0].style.width;\r\n\r\n          // Bind events\r\n          targetEl.on('scroll', this.checkPosition);\r\n          targetEl.on('click', this.checkPositionWithEventLoop);\r\n          windowEl.on('resize', this.$debouncedOnResize);\r\n\r\n          // Both of these checkPosition() calls are necessary for the case where\r\n          // the user hits refresh after scrolling to the bottom of the page.\r\n          this.checkPosition();\r\n          this.checkPositionWithEventLoop();\r\n\r\n        };\r\n\r\n        $affix.destroy = function () {\r\n\r\n          // Unbind events\r\n          targetEl.off('scroll', this.checkPosition);\r\n          targetEl.off('click', this.checkPositionWithEventLoop);\r\n          windowEl.off('resize', this.$debouncedOnResize);\r\n\r\n        };\r\n\r\n        $affix.checkPositionWithEventLoop = function () {\r\n\r\n          // IE 9 throws an error if we use 'this' instead of '$affix'\r\n          // in this setTimeout call\r\n          setTimeout($affix.checkPosition, 1);\r\n\r\n        };\r\n\r\n        $affix.checkPosition = function () {\r\n          // if (!this.$element.is(':visible')) return\r\n\r\n          var scrollTop = getScrollTop();\r\n          var position = dimensions.offset(element[0]);\r\n          var elementHeight = dimensions.height(element[0]);\r\n\r\n          // Get required affix class according to position\r\n          var affix = getRequiredAffixClass(unpin, position, elementHeight);\r\n\r\n          // Did affix status changed this last check?\r\n          if (affixed === affix) return;\r\n          affixed = affix;\r\n\r\n          if (affix === 'top') {\r\n            unpin = null;\r\n            if (setWidth) {\r\n              element.css('width', '');\r\n            }\r\n            if (options.inlineStyles) {\r\n              element.css('position', (options.offsetParent) ? '' : 'relative');\r\n              element.css('top', '');\r\n            }\r\n          } else if (affix === 'bottom') {\r\n            if (options.offsetUnpin) {\r\n              unpin = -(options.offsetUnpin * 1);\r\n            } else {\r\n              // Calculate unpin threshold when affixed to bottom.\r\n              // Hopefully the browser scrolls pixel by pixel.\r\n              unpin = position.top - scrollTop;\r\n            }\r\n            if (setWidth) {\r\n              element.css('width', '');\r\n            }\r\n            if (options.inlineStyles) {\r\n              element.css('position', (options.offsetParent) ? '' : 'relative');\r\n              element.css('top', (options.offsetParent) ? '' : ((bodyEl[0].offsetHeight - offsetBottom - elementHeight - initialOffsetTop) + 'px'));\r\n            }\r\n          } else { // affix === 'middle'\r\n            unpin = null;\r\n            if (setWidth) {\r\n              element.css('width', element[0].offsetWidth + 'px');\r\n            }\r\n            if (options.inlineStyles) {\r\n              element.css('position', 'fixed');\r\n              element.css('top', initialAffixTop + 'px');\r\n            }\r\n          }\r\n\r\n          // Add proper affix class\r\n          element.removeClass(reset).addClass('affix' + ((affix !== 'middle') ? '-' + affix : ''));\r\n\r\n        };\r\n\r\n        $affix.$onResize = function () {\r\n          $affix.$parseOffsets();\r\n          $affix.checkPosition();\r\n        };\r\n        $affix.$debouncedOnResize = debounce($affix.$onResize, 50);\r\n\r\n        $affix.$parseOffsets = function () {\r\n          var initialPosition = element[0].style.position;\r\n          var initialTop = element[0].style.top;\r\n          // Reset position to calculate correct offsetTop\r\n          if (options.inlineStyles) {\r\n            element.css('position', (options.offsetParent) ? '' : 'relative');\r\n            element.css('top', '');\r\n          }\r\n\r\n          if (options.offsetTop) {\r\n            if (options.offsetTop === 'auto') {\r\n              options.offsetTop = '+0';\r\n            }\r\n            if (options.offsetTop.match(/^[-+]\\d+$/)) {\r\n              initialAffixTop = - options.offsetTop * 1;\r\n              if (options.offsetParent) {\r\n                offsetTop = dimensions.offset(parent[0]).top + (options.offsetTop * 1);\r\n              } else {\r\n                offsetTop = dimensions.offset(element[0]).top - dimensions.css(element[0], 'marginTop', true) + (options.offsetTop * 1);\r\n              }\r\n            } else {\r\n              offsetTop = options.offsetTop * 1;\r\n            }\r\n          }\r\n\r\n          if (options.offsetBottom) {\r\n            if (options.offsetParent && options.offsetBottom.match(/^[-+]\\d+$/)) {\r\n              // add 1 pixel due to rounding problems...\r\n              offsetBottom = getScrollHeight() - (dimensions.offset(parent[0]).top + dimensions.height(parent[0])) + (options.offsetBottom * 1) + 1;\r\n            } else {\r\n              offsetBottom = options.offsetBottom * 1;\r\n            }\r\n          }\r\n\r\n          // Bring back the element's position after calculations\r\n          if (options.inlineStyles) {\r\n            element.css('position', initialPosition);\r\n            element.css('top', initialTop);\r\n          }\r\n        };\r\n\r\n        // Private methods\r\n\r\n        function getRequiredAffixClass (_unpin, position, elementHeight) {\r\n          var scrollTop = getScrollTop();\r\n          var scrollHeight = getScrollHeight();\r\n\r\n          if (scrollTop <= offsetTop) {\r\n            return 'top';\r\n          } else if (_unpin !== null) {\r\n            return scrollTop + _unpin <= position.top ? 'middle' : 'bottom';\r\n          } else if (offsetBottom !== null && (position.top + elementHeight + initialAffixTop >= scrollHeight - offsetBottom)) {\r\n            return 'bottom';\r\n          }\r\n          return 'middle';\r\n        }\r\n\r\n        function getScrollTop () {\r\n          return targetEl[0] === $window ? $window.pageYOffset : targetEl[0].scrollTop;\r\n        }\r\n\r\n        function getScrollHeight () {\r\n          return targetEl[0] === $window ? $window.document.body.scrollHeight : targetEl[0].scrollHeight;\r\n        }\r\n\r\n        $affix.init();\r\n        return $affix;\r\n\r\n      }\r\n\r\n      return AffixFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsAffix', function ($affix, $window, $timeout) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      require: '^?bsAffixTarget',\r\n      link: function postLink (scope, element, attr, affixTarget) {\r\n\r\n        var options = {scope: scope, target: affixTarget ? affixTarget.$element : angular.element($window)};\r\n        angular.forEach(['offsetTop', 'offsetBottom', 'offsetParent', 'offsetUnpin', 'inlineStyles', 'setWidth'], function (key) {\r\n          if (angular.isDefined(attr[key])) {\r\n            var option = attr[key];\r\n            if (/true/i.test(option)) option = true;\r\n            if (/false/i.test(option)) option = false;\r\n            options[key] = option;\r\n          }\r\n        });\r\n\r\n        var affix;\r\n        $timeout(function () { affix = $affix(element, options); });\r\n        scope.$on('$destroy', function () {\r\n          if (affix) affix.destroy();\r\n          options = null;\r\n          affix = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsAffixTarget', function () {\r\n    return {\r\n      controller: function ($element) {\r\n        this.$element = $element;\r\n      }\r\n    };\r\n  });\r\n\r\n// Source: module.js\r\nangular.module('mgcrea.ngStrap', [\r\n  'mgcrea.ngStrap.modal',\r\n  'mgcrea.ngStrap.aside',\r\n  'mgcrea.ngStrap.alert',\r\n  'mgcrea.ngStrap.button',\r\n  'mgcrea.ngStrap.select',\r\n  'mgcrea.ngStrap.datepicker',\r\n  'mgcrea.ngStrap.timepicker',\r\n  'mgcrea.ngStrap.navbar',\r\n  'mgcrea.ngStrap.tooltip',\r\n  'mgcrea.ngStrap.popover',\r\n  'mgcrea.ngStrap.dropdown',\r\n  'mgcrea.ngStrap.typeahead',\r\n  'mgcrea.ngStrap.scrollspy',\r\n  'mgcrea.ngStrap.affix',\r\n  'mgcrea.ngStrap.tab',\r\n  'mgcrea.ngStrap.collapse'\r\n]);\r\n\r\n})(window, document);\r\n","'use strict';\r\n\r\nif (angular.version.minor < 3 && angular.version.dot < 14) {\r\n  angular.module('ng')\r\n\r\n  .factory('$$rAF', function ($window, $timeout) {\r\n\r\n    var requestAnimationFrame = $window.requestAnimationFrame ||\r\n                                $window.webkitRequestAnimationFrame ||\r\n                                $window.mozRequestAnimationFrame;\r\n\r\n    var cancelAnimationFrame = $window.cancelAnimationFrame ||\r\n                               $window.webkitCancelAnimationFrame ||\r\n                               $window.mozCancelAnimationFrame ||\r\n                               $window.webkitCancelRequestAnimationFrame;\r\n\r\n    var rafSupported = !!requestAnimationFrame;\r\n    var raf = rafSupported ?\r\n      function (fn) {\r\n        var id = requestAnimationFrame(fn);\r\n        return function () {\r\n          cancelAnimationFrame(id);\r\n        };\r\n      } :\r\n      function (fn) {\r\n        var timer = $timeout(fn, 16.66, false); // 1000 / 60 = 16.666\r\n        return function () {\r\n          $timeout.cancel(timer);\r\n        };\r\n      };\r\n\r\n    raf.supported = rafSupported;\r\n\r\n    return raf;\r\n\r\n  });\r\n}\r\n","'use strict';\r\n\r\n// NOTICE: This file was forked from the angular-material project (github.com/angular/material)\r\n// MIT Licensed - Copyright (c) 2014-2015 Google, Inc. http://angularjs.org\r\n\r\nangular.module('mgcrea.ngStrap.core', [])\r\n  .service('$bsCompiler', bsCompilerService);\r\n\r\nfunction bsCompilerService ($q, $http, $injector, $compile, $controller, $templateCache) {\r\n\r\n  /*\r\n   * @ngdoc service\r\n   * @name $bsCompiler\r\n   * @module material.core\r\n   * @description\r\n   * The $bsCompiler service is an abstraction of angular's compiler, that allows the developer\r\n   * to easily compile an element with a templateUrl, controller, and locals.\r\n   *\r\n   * @usage\r\n   * <hljs lang=\"js\">\r\n   * $bsCompiler.compile({\r\n   *   templateUrl: 'modal.html',\r\n   *   controller: 'ModalCtrl',\r\n   *   locals: {\r\n   *     modal: myModalInstance;\r\n   *   }\r\n   * }).then(function(compileData) {\r\n   *   compileData.element; // modal.html's template in an element\r\n   *   compileData.link(myScope); //attach controller & scope to element\r\n   * });\r\n   * </hljs>\r\n   */\r\n\r\n   /*\r\n    * @ngdoc method\r\n    * @name $bsCompiler#compile\r\n    * @description A helper to compile an HTML template/templateUrl with a given controller,\r\n    * locals, and scope.\r\n    * @param {object} options An options object, with the following properties:\r\n    *\r\n    *    - `controller` - `{(string=|function()=}` Controller fn that should be associated with\r\n    *      newly created scope or the name of a registered controller if passed as a string.\r\n    *    - `controllerAs` - `{string=}` A controller alias name. If present the controller will be\r\n    *      published to scope under the `controllerAs` name.\r\n    *    - `template` - `{string=}` An html template as a string.\r\n    *    - `templateUrl` - `{string=}` A path to an html template.\r\n    *    - `transformTemplate` - `{function(template)=}` A function which transforms the template after\r\n    *      it is loaded. It will be given the template string as a parameter, and should\r\n    *      return a a new string representing the transformed template.\r\n    *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should\r\n    *      be injected into the controller. If any of these dependencies are promises, the compiler\r\n    *      will wait for them all to be resolved, or if one is rejected before the controller is\r\n    *      instantiated `compile()` will fail..\r\n    *      * `key` - `{string}`: a name of a dependency to be injected into the controller.\r\n    *      * `factory` - `{string|function}`: If `string` then it is an alias for a service.\r\n    *        Otherwise if function, then it is injected and the return value is treated as the\r\n    *        dependency. If the result is a promise, it is resolved before its value is\r\n    *        injected into the controller.\r\n    *\r\n    * @returns {object=} promise A promise, which will be resolved with a `compileData` object.\r\n    * `compileData` has the following properties:\r\n    *\r\n    *   - `element` - `{element}`: an uncompiled element matching the provided template.\r\n    *   - `link` - `{function(scope)}`: A link function, which, when called, will compile\r\n    *     the element and instantiate the provided controller (if given).\r\n    *   - `locals` - `{object}`: The locals which will be passed into the controller once `link` is\r\n    *     called. If `bindToController` is true, they will be coppied to the ctrl instead\r\n    *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in.\r\n    */\r\n  this.compile = function (options) {\r\n\r\n    if (options.template && /\\.html$/.test(options.template)) {\r\n      console.warn('Deprecated use of `template` option to pass a file. Please use the `templateUrl` option instead.');\r\n      options.templateUrl = options.template;\r\n      options.template = '';\r\n    }\r\n\r\n    var templateUrl = options.templateUrl;\r\n    var template = options.template || '';\r\n    var controller = options.controller;\r\n    var controllerAs = options.controllerAs;\r\n    var resolve = options.resolve || {};\r\n    var locals = options.locals || {};\r\n    var transformTemplate = options.transformTemplate || angular.identity;\r\n    var bindToController = options.bindToController;\r\n\r\n    // Take resolve values and invoke them.\r\n    // Resolves can either be a string (value: 'MyRegisteredAngularConst'),\r\n    // or an invokable 'factory' of sorts: (value: function ValueGetter($dependency) {})\r\n    angular.forEach(resolve, function (value, key) {\r\n      if (angular.isString(value)) {\r\n        resolve[key] = $injector.get(value);\r\n      } else {\r\n        resolve[key] = $injector.invoke(value);\r\n      }\r\n    });\r\n    // Add the locals, which are just straight values to inject\r\n    // eg locals: { three: 3 }, will inject three into the controller\r\n    angular.extend(resolve, locals);\r\n\r\n    if (template) {\r\n      resolve.$template = $q.when(template);\r\n    } else if (templateUrl) {\r\n      resolve.$template = fetchTemplate(templateUrl);\r\n    } else {\r\n      throw new Error('Missing `template` / `templateUrl` option.');\r\n    }\r\n\r\n    if (options.titleTemplate) {\r\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.titleTemplate)])\r\n        .then(function (templates) {\r\n          var templateEl = angular.element(templates[0]);\r\n          findElement('[ng-bind=\"title\"]', templateEl[0])\r\n            .removeAttr('ng-bind')\r\n            .html(templates[1]);\r\n          return templateEl[0].outerHTML;\r\n        });\r\n    }\r\n\r\n    if (options.contentTemplate) {\r\n      // TODO(mgcrea): deprecate?\r\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.contentTemplate)])\r\n        .then(function (templates) {\r\n          var templateEl = angular.element(templates[0]);\r\n          var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0])\r\n            .removeAttr('ng-bind')\r\n            .html(templates[1]);\r\n          // Drop the default footer as you probably don't want it if you use a custom contentTemplate\r\n          if (!options.templateUrl) contentEl.next().remove();\r\n          return templateEl[0].outerHTML;\r\n        });\r\n    }\r\n\r\n    // Wait for all the resolves to finish if they are promises\r\n    return $q.all(resolve).then(function (locals) {\r\n\r\n      var template = transformTemplate(locals.$template);\r\n      if (options.html) {\r\n        template = template.replace(/ng-bind=\"/ig, 'ng-bind-html=\"');\r\n      }\r\n      // var element = options.element || angular.element('<div>').html(template.trim()).contents();\r\n      var element = angular.element('<div>').html(template.trim()).contents();\r\n      var linkFn = $compile(element);\r\n\r\n      // Return a linking function that can be used later when the element is ready\r\n      return {\r\n        locals: locals,\r\n        element: element,\r\n        link: function link (scope) {\r\n          locals.$scope = scope;\r\n\r\n          // Instantiate controller if it exists, because we have scope\r\n          if (controller) {\r\n            var invokeCtrl = $controller(controller, locals, true);\r\n            if (bindToController) {\r\n              angular.extend(invokeCtrl.instance, locals);\r\n            }\r\n            // Support angular@~1.2 invokeCtrl\r\n            var ctrl = angular.isObject(invokeCtrl) ? invokeCtrl : invokeCtrl();\r\n            // See angular-route source for this logic\r\n            element.data('$ngControllerController', ctrl);\r\n            element.children().data('$ngControllerController', ctrl);\r\n\r\n            if (controllerAs) {\r\n              scope[controllerAs] = ctrl;\r\n            }\r\n          }\r\n\r\n          return linkFn.apply(null, arguments);\r\n        }\r\n      };\r\n    });\r\n\r\n  };\r\n\r\n  function findElement (query, element) {\r\n    return angular.element((element || document).querySelectorAll(query));\r\n  }\r\n\r\n  var fetchPromises = {};\r\n  function fetchTemplate (template) {\r\n    if (fetchPromises[template]) return fetchPromises[template];\r\n    return (fetchPromises[template] = $http.get(template, {cache: $templateCache})\r\n      .then(function (res) {\r\n        return res.data;\r\n      }));\r\n  }\r\n\r\n}\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.typeahead', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\r\n\r\n  .provider('$typeahead', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      prefixClass: 'typeahead',\r\n      prefixEvent: '$typeahead',\r\n      placement: 'bottom-left',\r\n      templateUrl: 'typeahead/typeahead.tpl.html',\r\n      trigger: 'focus',\r\n      container: false,\r\n      keyboard: true,\r\n      html: false,\r\n      delay: 0,\r\n      minLength: 1,\r\n      filter: 'bsAsyncFilter',\r\n      limit: 6,\r\n      autoSelect: false,\r\n      comparator: '',\r\n      trimValue: true\r\n    };\r\n\r\n    this.$get = function ($window, $rootScope, $tooltip, $$rAF, $timeout) {\r\n\r\n      function TypeaheadFactory (element, controller, config) {\r\n\r\n        var $typeahead = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n\r\n        $typeahead = $tooltip(element, options);\r\n        var parentScope = config.scope;\r\n        var scope = $typeahead.$scope;\r\n\r\n        scope.$resetMatches = function () {\r\n          scope.$matches = [];\r\n          scope.$activeIndex = options.autoSelect ? 0 : -1; // If set to 0, the first match will be highlighted\r\n        };\r\n        scope.$resetMatches();\r\n\r\n        scope.$activate = function (index) {\r\n          scope.$$postDigest(function () {\r\n            $typeahead.activate(index);\r\n          });\r\n        };\r\n\r\n        scope.$select = function (index, evt) {\r\n          scope.$$postDigest(function () {\r\n            $typeahead.select(index);\r\n          });\r\n        };\r\n\r\n        scope.$isVisible = function () {\r\n          return $typeahead.$isVisible();\r\n        };\r\n\r\n        // Public methods\r\n\r\n        $typeahead.update = function (matches) {\r\n          scope.$matches = matches;\r\n          if (scope.$activeIndex >= matches.length) {\r\n            scope.$activeIndex = options.autoSelect ? 0 : -1;\r\n          }\r\n\r\n          // wrap in a $timeout so the results are updated\r\n          // before repositioning\r\n          safeDigest(scope);\r\n          $$rAF($typeahead.$applyPlacement);\r\n        };\r\n\r\n        $typeahead.activate = function (index) {\r\n          scope.$activeIndex = index;\r\n        };\r\n\r\n        $typeahead.select = function (index) {\r\n          if (index === -1) return;\r\n          var value = scope.$matches[index].value;\r\n          // console.log('$setViewValue', value);\r\n          controller.$setViewValue(value);\r\n          controller.$render();\r\n          scope.$resetMatches();\r\n          if (parentScope) parentScope.$digest();\r\n          // Emit event\r\n          scope.$emit(options.prefixEvent + '.select', value, index, $typeahead);\r\n          if (angular.isDefined(options.onSelect) && angular.isFunction(options.onSelect)) {\r\n            options.onSelect(value, index, $typeahead);\r\n          }\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $typeahead.$isVisible = function () {\r\n          if (!options.minLength || !controller) {\r\n            return !!scope.$matches.length;\r\n          }\r\n          // minLength support\r\n          return scope.$matches.length && angular.isString(controller.$viewValue) && controller.$viewValue.length >= options.minLength;\r\n        };\r\n\r\n        $typeahead.$getIndex = function (value) {\r\n          var index;\r\n          for (index = scope.$matches.length; index--;) {\r\n            if (angular.equals(scope.$matches[index].value, value)) break;\r\n          }\r\n          return index;\r\n        };\r\n\r\n        $typeahead.$onMouseDown = function (evt) {\r\n          // Prevent blur on mousedown\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n        };\r\n\r\n        $typeahead.$$updateScrollTop = function (container, index) {\r\n          if (index > -1 && index < container.children.length) {\r\n            var active = container.children[index];\r\n            var clientTop = active.offsetTop;\r\n            var clientBottom = active.offsetTop + active.clientHeight;\r\n            var highWatermark = container.scrollTop;\r\n            var lowWatermark = container.scrollTop + container.clientHeight;\r\n\r\n            // active entry overlaps top border\r\n            if (clientBottom >= highWatermark && clientTop < highWatermark) {\r\n              container.scrollTop = Math.max(0, container.scrollTop - container.clientHeight);\r\n            } else if (clientBottom > lowWatermark) {\r\n              // top of active element is invisible because it's below the bottom of the visible container window\r\n              container.scrollTop = clientTop;\r\n            }\r\n          }\r\n        };\r\n\r\n        $typeahead.$onKeyDown = function (evt) {\r\n          if (!/(38|40|13)/.test(evt.keyCode)) return;\r\n\r\n          // Let ngSubmit pass if the typeahead tip is hidden or no option is selected\r\n          if ($typeahead.$isVisible() && !(evt.keyCode === 13 && scope.$activeIndex === -1)) {\r\n            evt.preventDefault();\r\n            evt.stopPropagation();\r\n          }\r\n\r\n          // Select with enter\r\n          if (evt.keyCode === 13 && scope.$matches.length) {\r\n            $typeahead.select(scope.$activeIndex);\r\n          // Navigate with keyboard\r\n          } else if (evt.keyCode === 38 && scope.$activeIndex > 0) {\r\n            scope.$activeIndex--;\r\n          } else if (evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) {\r\n            scope.$activeIndex++;\r\n          } else if (angular.isUndefined(scope.$activeIndex)) {\r\n            scope.$activeIndex = 0;\r\n          }\r\n\r\n          // update scrollTop property on $typeahead when scope.$activeIndex is not in visible area\r\n          $typeahead.$$updateScrollTop($typeahead.$element[0], scope.$activeIndex);\r\n          scope.$digest();\r\n        };\r\n\r\n        // Overrides\r\n\r\n        var show = $typeahead.show;\r\n        $typeahead.show = function () {\r\n          show();\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed immediately.\r\n          $timeout(function () {\r\n            if ($typeahead.$element) {\r\n              $typeahead.$element.on('mousedown', $typeahead.$onMouseDown);\r\n              if (options.keyboard) {\r\n                if (element) element.on('keydown', $typeahead.$onKeyDown);\r\n              }\r\n            }\r\n          }, 0, false);\r\n        };\r\n\r\n        var hide = $typeahead.hide;\r\n        $typeahead.hide = function () {\r\n          if ($typeahead.$element) $typeahead.$element.off('mousedown', $typeahead.$onMouseDown);\r\n          if (options.keyboard) {\r\n            if (element) element.off('keydown', $typeahead.$onKeyDown);\r\n          }\r\n          if (!options.autoSelect) {\r\n            $typeahead.activate(-1);\r\n          }\r\n          hide();\r\n        };\r\n\r\n        return $typeahead;\r\n\r\n      }\r\n\r\n      // Helper functions\r\n\r\n      function safeDigest (scope) {\r\n        /* eslint-disable no-unused-expressions */\r\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\r\n        /* eslint-enable no-unused-expressions */\r\n      }\r\n\r\n      TypeaheadFactory.defaults = defaults;\r\n      return TypeaheadFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .filter('bsAsyncFilter', function ($filter) {\r\n    return function (array, expression, comparator) {\r\n      if (array && angular.isFunction(array.then)) {\r\n        return array.then(function (results) {\r\n          return $filter('filter')(results, expression, comparator);\r\n        });\r\n      }\r\n      return $filter('filter')(array, expression, comparator);\r\n    };\r\n  })\r\n\r\n  .directive('bsTypeahead', function ($window, $parse, $q, $typeahead, $parseOptions) {\r\n\r\n    var defaults = $typeahead.defaults;\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        // Fixes firefox bug when using objects in model with typeahead\r\n        // Yes this breaks any other directive using a 'change' event on this input,\r\n        // but if it is using the 'change' event why is it used with typeahead?\r\n        element.off('change');\r\n\r\n        // Directive options\r\n        var options = {\r\n          scope: scope\r\n        };\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'filter', 'limit', 'minLength', 'watchOptions', 'selectMode', 'autoSelect', 'comparator', 'id', 'prefixEvent', 'prefixClass'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container', 'trimValue', 'filter'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n        });\r\n\r\n        // bind functions from the attrs to the show, hide and select events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide', 'onSelect'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Disable browser autocompletion\r\n        if (!element.attr('autocomplete')) element.attr('autocomplete', 'off');\r\n\r\n        // Build proper bsOptions\r\n        var filter = angular.isDefined(options.filter) ? options.filter : defaults.filter;\r\n        var limit = options.limit || defaults.limit;\r\n        var comparator = options.comparator || defaults.comparator;\r\n\r\n        var bsOptions = attr.bsOptions;\r\n        if (filter) {\r\n          bsOptions += ' | ' + filter + ':$viewValue';\r\n          if (comparator) bsOptions += ':' + comparator;\r\n        }\r\n        if (limit) bsOptions += ' | limitTo:' + limit;\r\n        var parsedOptions = $parseOptions(bsOptions);\r\n\r\n        // Initialize typeahead\r\n        var typeahead = $typeahead(element, controller, options);\r\n\r\n        // Watch options on demand\r\n        if (options.watchOptions) {\r\n          // Watch bsOptions values before filtering for changes, drop function calls\r\n          var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').replace(/\\(.*\\)/g, '').trim();\r\n          scope.$watchCollection(watchedOptions, function (newValue, oldValue) {\r\n            // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\r\n            parsedOptions.valuesFn(scope, controller).then(function (values) {\r\n              typeahead.update(values);\r\n              controller.$render();\r\n            });\r\n          });\r\n        }\r\n\r\n        // Watch model for changes\r\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\r\n          // console.warn('$watch', element.attr('ng-model'), newValue);\r\n          scope.$modelValue = newValue; // Publish modelValue on scope for custom templates\r\n          parsedOptions.valuesFn(scope, controller)\r\n            .then(function (values) {\r\n              // Prevent input with no future prospect if selectMode is truthy\r\n              // @TODO test selectMode\r\n              if (options.selectMode && !values.length && newValue.length > 0) {\r\n                controller.$setViewValue(controller.$viewValue.substring(0, controller.$viewValue.length - 1));\r\n                return;\r\n              }\r\n              if (values.length > limit) values = values.slice(0, limit);\r\n              typeahead.update(values);\r\n              // Queue a new rendering that will leverage collection loading\r\n              controller.$render();\r\n            });\r\n        });\r\n\r\n        // modelValue -> $formatters -> viewValue\r\n        controller.$formatters.push(function (modelValue) {\r\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n          var displayValue = parsedOptions.displayValue(modelValue);\r\n\r\n          // If we can determine the displayValue, use that\r\n          if (displayValue) {\r\n            return displayValue;\r\n          }\r\n\r\n          // If there's no display value, attempt to use the modelValue.\r\n          // If the model is an object not much we can do\r\n          if (angular.isDefined(modelValue) && typeof modelValue !== 'object') {\r\n            return modelValue;\r\n          }\r\n          return '';\r\n        });\r\n\r\n        // Model rendering in view\r\n        controller.$render = function () {\r\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\r\n          if (controller.$isEmpty(controller.$viewValue)) {\r\n            return element.val('');\r\n          }\r\n          var index = typeahead.$getIndex(controller.$modelValue);\r\n          var selected = index !== -1 ? typeahead.$scope.$matches[index].label : controller.$viewValue;\r\n          selected = angular.isObject(selected) ? parsedOptions.displayValue(selected) : selected;\r\n          var value = selected ? selected.toString().replace(/<(?:.|\\n)*?>/gm, '') : '';\r\n          var ss = element[0].selectionStart;\r\n          var sd = element[0].selectionEnd;\r\n          element.val(options.trimValue === false ? value : value.trim());\r\n          element[0].setSelectionRange(ss, sd);\r\n        };\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (typeahead) typeahead.destroy();\r\n          options = null;\r\n          typeahead = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.helpers.parseOptions', [])\r\n\r\n  .provider('$parseOptions', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      regexp: /^\\s*(.*?)(?:\\s+as\\s+(.*?))?(?:\\s+group\\s+by\\s+(.*))?\\s+for\\s+(?:([\\$\\w][\\$\\w]*)|(?:\\(\\s*([\\$\\w][\\$\\w]*)\\s*,\\s*([\\$\\w][\\$\\w]*)\\s*\\)))\\s+in\\s+(.*?)(?:\\s+track\\s+by\\s+(.*?))?$/\r\n    };\r\n\r\n    this.$get = function ($parse, $q) {\r\n\r\n      function ParseOptionsFactory (attr, config) {\r\n\r\n        var $parseOptions = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n        $parseOptions.$values = [];\r\n\r\n        // Private vars\r\n        var match;\r\n        var displayFn;\r\n        var valueName;\r\n        /* eslint-disable no-unused-vars */\r\n        var keyName;\r\n        var groupByFn;\r\n        /* eslint-enable no-unused-vars */\r\n        var valueFn;\r\n        var valuesFn;\r\n\r\n        $parseOptions.init = function () {\r\n          $parseOptions.$match = match = attr.match(options.regexp);\r\n          displayFn = $parse(match[2] || match[1]);\r\n          valueName = match[4] || match[6];\r\n          keyName = match[5];\r\n          groupByFn = $parse(match[3] || '');\r\n          valueFn = $parse(match[2] ? match[1] : valueName);\r\n          valuesFn = $parse(match[7]);\r\n        };\r\n\r\n        $parseOptions.valuesFn = function (scope, controller) {\r\n          return $q.when(valuesFn(scope, controller))\r\n          .then(function (values) {\r\n            if (!angular.isArray(values)) {\r\n              values = [];\r\n            }\r\n            $parseOptions.$values = values.length ? parseValues(values, scope) : [];\r\n            return $parseOptions.$values;\r\n          });\r\n        };\r\n\r\n        $parseOptions.displayValue = function (modelValue) {\r\n          var scope = {};\r\n          scope[valueName] = modelValue;\r\n          return displayFn(scope);\r\n        };\r\n\r\n        // Private functions\r\n\r\n        function parseValues (values, scope) {\r\n          return values.map(function (match, index) {\r\n            var locals = {};\r\n            var label;\r\n            var value;\r\n            locals[valueName] = match;\r\n            label = displayFn(scope, locals);\r\n            value = valueFn(scope, locals);\r\n            return {label: label, value: value, index: index};\r\n          });\r\n        }\r\n\r\n        $parseOptions.init();\r\n        return $parseOptions;\r\n\r\n      }\r\n\r\n      return ParseOptionsFactory;\r\n\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.helpers.ngFocusOut', [])\r\n  .directive('ngFocusOut', ['$parse', '$rootScope', function ($parse, $rootScope) {\r\n    return {\r\n      restrict: 'A',\r\n      compile: function ($element, attr) {\r\n        // NOTE:\r\n        // We expose the powerful `$event` object on the scope that provides access to the Window,\r\n        // etc. This is OK, because expressions are not sandboxed any more (and the expression\r\n        // sandbox was never meant to be a security feature anyway).\r\n        var fn = $parse(attr.ngFocusOut);\r\n\r\n        return function link (scope, element) {\r\n          function ngEventHandler (event) {\r\n            var callback = function () {\r\n              fn(scope, {\r\n                $event: event\r\n              });\r\n            };\r\n            if ($rootScope.$$phase) {\r\n              scope.$evalAsync(callback);\r\n            } else {\r\n              scope.$apply(callback);\r\n            }\r\n          }\r\n\r\n          // setup the handler\r\n          element.on('focusout', ngEventHandler);\r\n\r\n          scope.$on('$destroy', function () {\r\n            // tear down the handler\r\n            element.off('focusout', ngEventHandler);\r\n          });\r\n        };\r\n      }\r\n    };\r\n  }]);\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.helpers.focusElement', [])\r\n  .directive('focusElement', ['$timeout', '$parse', function ($timeout, $parse) {\r\n    return {\r\n      link: function (scope, element, attrs) {\r\n        scope.$watch(attrs.focusElement, function (value) {\r\n          if (value === true) {\r\n            $timeout(function () {\r\n              element[0].focus();\r\n            });\r\n          }\r\n        });\r\n      }\r\n    };\r\n  }]);\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.helpers.dimensions', [])\r\n\r\n  .factory('dimensions', function () {\r\n\r\n    var fn = {};\r\n\r\n    /**\r\n     * Test the element nodeName\r\n     * @param element\r\n     * @param name\r\n     */\r\n    var nodeName = fn.nodeName = function (element, name) {\r\n      return element.nodeName && element.nodeName.toLowerCase() === name.toLowerCase();\r\n    };\r\n\r\n    /**\r\n     * Returns the element computed style\r\n     * @param element\r\n     * @param prop\r\n     * @param extra\r\n     */\r\n    fn.css = function (element, prop, extra) {\r\n      var value;\r\n      if (element.currentStyle) { // IE\r\n        value = element.currentStyle[prop];\r\n      } else if (window.getComputedStyle) {\r\n        value = window.getComputedStyle(element)[prop];\r\n      } else {\r\n        value = element.style[prop];\r\n      }\r\n      return extra === true ? parseFloat(value) || 0 : value;\r\n    };\r\n\r\n    /**\r\n     * Provides read-only equivalent of jQuery's offset function:\r\n     * @required-by bootstrap-tooltip, bootstrap-affix\r\n     * @url http://api.jquery.com/offset/\r\n     * @param element\r\n     */\r\n    fn.offset = function (element) {\r\n      var boxRect = element.getBoundingClientRect();\r\n      var docElement = element.ownerDocument;\r\n      return {\r\n        width: boxRect.width || element.offsetWidth,\r\n        height: boxRect.height || element.offsetHeight,\r\n        top: boxRect.top + (window.pageYOffset || docElement.documentElement.scrollTop) - (docElement.documentElement.clientTop || 0),\r\n        left: boxRect.left + (window.pageXOffset || docElement.documentElement.scrollLeft) - (docElement.documentElement.clientLeft || 0)\r\n      };\r\n    };\r\n\r\n    /**\r\n     * Provides set equivalent of jQuery's offset function:\r\n     * @required-by bootstrap-tooltip\r\n     * @url http://api.jquery.com/offset/\r\n     * @param element\r\n     * @param options\r\n     * @param i\r\n     */\r\n    fn.setOffset = function (element, options, i) {\r\n      var curPosition;\r\n      var curLeft;\r\n      var curCSSTop;\r\n      var curTop;\r\n      var curOffset;\r\n      var curCSSLeft;\r\n      var calculatePosition;\r\n      var position = fn.css(element, 'position');\r\n      var curElem = angular.element(element);\r\n      var props = {};\r\n\r\n      // Set position first, in-case top/left are set even on static elem\r\n      if (position === 'static') {\r\n        element.style.position = 'relative';\r\n      }\r\n\r\n      curOffset = fn.offset(element);\r\n      curCSSTop = fn.css(element, 'top');\r\n      curCSSLeft = fn.css(element, 'left');\r\n      calculatePosition = (position === 'absolute' || position === 'fixed') &&\r\n                          (curCSSTop + curCSSLeft).indexOf('auto') > -1;\r\n\r\n      // Need to be able to calculate position if either\r\n      // top or left is auto and position is either absolute or fixed\r\n      if (calculatePosition) {\r\n        curPosition = fn.position(element);\r\n        curTop = curPosition.top;\r\n        curLeft = curPosition.left;\r\n      } else {\r\n        curTop = parseFloat(curCSSTop) || 0;\r\n        curLeft = parseFloat(curCSSLeft) || 0;\r\n      }\r\n\r\n      if (angular.isFunction(options)) {\r\n        options = options.call(element, i, curOffset);\r\n      }\r\n\r\n      if (options.top !== null) {\r\n        props.top = (options.top - curOffset.top) + curTop;\r\n      }\r\n      if (options.left !== null) {\r\n        props.left = (options.left - curOffset.left) + curLeft;\r\n      }\r\n\r\n      if ('using' in options) {\r\n        options.using.call(curElem, props);\r\n      } else {\r\n        curElem.css({\r\n          top: props.top + 'px',\r\n          left: props.left + 'px'\r\n        });\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Provides read-only equivalent of jQuery's position function\r\n     * @required-by bootstrap-tooltip, bootstrap-affix\r\n     * @url http://api.jquery.com/offset/\r\n     * @param element\r\n     */\r\n    fn.position = function (element) {\r\n\r\n      var offsetParentRect = {top: 0, left: 0};\r\n      var offsetParentEl;\r\n      var offset;\r\n\r\n      // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\r\n      if (fn.css(element, 'position') === 'fixed') {\r\n\r\n        // We assume that getBoundingClientRect is available when computed position is fixed\r\n        offset = element.getBoundingClientRect();\r\n\r\n      } else {\r\n\r\n        // Get *real* offsetParentEl\r\n        offsetParentEl = offsetParentElement(element);\r\n\r\n        // Get correct offsets\r\n        offset = fn.offset(element);\r\n        if (!nodeName(offsetParentEl, 'html')) {\r\n          offsetParentRect = fn.offset(offsetParentEl);\r\n        }\r\n\r\n        // Add offsetParent borders\r\n        offsetParentRect.top += fn.css(offsetParentEl, 'borderTopWidth', true);\r\n        offsetParentRect.left += fn.css(offsetParentEl, 'borderLeftWidth', true);\r\n      }\r\n\r\n      // Subtract parent offsets and element margins\r\n      return {\r\n        width: element.offsetWidth,\r\n        height: element.offsetHeight,\r\n        top: offset.top - offsetParentRect.top - fn.css(element, 'marginTop', true),\r\n        left: offset.left - offsetParentRect.left - fn.css(element, 'marginLeft', true)\r\n      };\r\n\r\n    };\r\n\r\n    /**\r\n     * Returns the closest, non-statically positioned offsetParent of a given element\r\n     * @required-by fn.position\r\n     * @param element\r\n     */\r\n    function offsetParentElement (element) {\r\n      var docElement = element.ownerDocument;\r\n      var offsetParent = element.offsetParent || docElement;\r\n      if (nodeName(offsetParent, '#document')) return docElement.documentElement;\r\n      while (offsetParent && !nodeName(offsetParent, 'html') && fn.css(offsetParent, 'position') === 'static') {\r\n        offsetParent = offsetParent.offsetParent;\r\n      }\r\n      return offsetParent || docElement.documentElement;\r\n    }\r\n\r\n    /**\r\n     * Provides equivalent of jQuery's height function\r\n     * @required-by bootstrap-affix\r\n     * @url http://api.jquery.com/height/\r\n     * @param element\r\n     * @param outer\r\n     */\r\n    fn.height = function (element, outer) {\r\n      var value = element.offsetHeight;\r\n      if (outer) {\r\n        value += fn.css(element, 'marginTop', true) + fn.css(element, 'marginBottom', true);\r\n      } else {\r\n        value -= fn.css(element, 'paddingTop', true) + fn.css(element, 'paddingBottom', true) + fn.css(element, 'borderTopWidth', true) + fn.css(element, 'borderBottomWidth', true);\r\n      }\r\n      return value;\r\n    };\r\n\r\n    /**\r\n     * Provides equivalent of jQuery's width function\r\n     * @required-by bootstrap-affix\r\n     * @url http://api.jquery.com/width/\r\n     * @param element\r\n     * @param outer\r\n     */\r\n    fn.width = function (element, outer) {\r\n      var value = element.offsetWidth;\r\n      if (outer) {\r\n        value += fn.css(element, 'marginLeft', true) + fn.css(element, 'marginRight', true);\r\n      } else {\r\n        value -= fn.css(element, 'paddingLeft', true) + fn.css(element, 'paddingRight', true) + fn.css(element, 'borderLeftWidth', true) + fn.css(element, 'borderRightWidth', true);\r\n      }\r\n      return value;\r\n    };\r\n\r\n    return fn;\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.helpers.debounce', [])\r\n\r\n// @source jashkenas/underscore\r\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L693\r\n.factory('debounce', function ($timeout) {\r\n  return function (func, wait, immediate) {\r\n    var timeout = null;\r\n    return function () {\r\n      var context = this;\r\n      var args = arguments;\r\n      var callNow = immediate && !timeout;\r\n      if (timeout) {\r\n        $timeout.cancel(timeout);\r\n      }\r\n      timeout = $timeout(function later () {\r\n        timeout = null;\r\n        if (!immediate) {\r\n          func.apply(context, args);\r\n        }\r\n      }, wait, false);\r\n      if (callNow) {\r\n        func.apply(context, args);\r\n      }\r\n      return timeout;\r\n    };\r\n  };\r\n})\r\n\r\n\r\n// @source jashkenas/underscore\r\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L661\r\n.factory('throttle', function ($timeout) {\r\n  return function (func, wait, options) {\r\n    var timeout = null;\r\n    if (!options) options = {};\r\n    return function () {\r\n      var context = this;\r\n      var args = arguments;\r\n      if (!timeout) {\r\n        if (options.leading !== false) {\r\n          func.apply(context, args);\r\n        }\r\n        timeout = $timeout(function later () {\r\n          timeout = null;\r\n          if (options.trailing !== false) {\r\n            func.apply(context, args);\r\n          }\r\n        }, wait, false);\r\n      }\r\n    };\r\n  };\r\n});\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.helpers.dateParser', [])\r\n\r\n.provider('$dateParser', function ($localeProvider) {\r\n\r\n  // define a custom ParseDate object to use instead of native Date\r\n  // to avoid date values wrapping when setting date component values\r\n  function ParseDate () {\r\n    this.year = 1970;\r\n    this.month = 0;\r\n    this.day = 1;\r\n    this.hours = 0;\r\n    this.minutes = 0;\r\n    this.seconds = 0;\r\n    this.milliseconds = 0;\r\n  }\r\n\r\n  ParseDate.prototype.setMilliseconds = function (value) { this.milliseconds = value; };\r\n  ParseDate.prototype.setSeconds = function (value) { this.seconds = value; };\r\n  ParseDate.prototype.setMinutes = function (value) { this.minutes = value; };\r\n  ParseDate.prototype.setHours = function (value) { this.hours = value; };\r\n  ParseDate.prototype.getHours = function () { return this.hours; };\r\n  ParseDate.prototype.setDate = function (value) { this.day = value; };\r\n  ParseDate.prototype.setMonth = function (value) { this.month = value; };\r\n  ParseDate.prototype.setFullYear = function (value) { this.year = value; };\r\n  ParseDate.prototype.fromDate = function (value) {\r\n    this.year = value.getFullYear();\r\n    this.month = value.getMonth();\r\n    this.day = value.getDate();\r\n    this.hours = value.getHours();\r\n    this.minutes = value.getMinutes();\r\n    this.seconds = value.getSeconds();\r\n    this.milliseconds = value.getMilliseconds();\r\n    return this;\r\n  };\r\n\r\n  ParseDate.prototype.toDate = function () {\r\n    return new Date(this.year, this.month, this.day, this.hours, this.minutes, this.seconds, this.milliseconds);\r\n  };\r\n\r\n  var proto = ParseDate.prototype;\r\n\r\n  function noop () {\r\n  }\r\n\r\n  function isNumeric (n) {\r\n    return !isNaN(parseFloat(n)) && isFinite(n);\r\n  }\r\n\r\n  function indexOfCaseInsensitive (array, value) {\r\n    var len = array.length;\r\n    var str = value.toString().toLowerCase();\r\n    for (var i = 0; i < len; i++) {\r\n      if (array[i].toLowerCase() === str) { return i; }\r\n    }\r\n    return -1; // Return -1 per the \"Array.indexOf()\" method.\r\n  }\r\n\r\n  var defaults = this.defaults = {\r\n    format: 'shortDate',\r\n    strict: false\r\n  };\r\n\r\n  this.$get = function ($locale, dateFilter) {\r\n\r\n    var DateParserFactory = function (config) {\r\n\r\n      var options = angular.extend({}, defaults, config);\r\n\r\n      var $dateParser = {};\r\n\r\n      /* eslint-disable key-spacing, quote-props */\r\n      var regExpMap = {\r\n        'sss'   : '[0-9]{3}',\r\n        'ss'    : '[0-5][0-9]',\r\n        's'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\r\n        'mm'    : '[0-5][0-9]',\r\n        'm'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\r\n        'HH'    : '[01][0-9]|2[0-3]',\r\n        'H'     : options.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',\r\n        'hh'    : '[0][1-9]|[1][012]',\r\n        'h'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\r\n        'a'     : 'AM|PM',\r\n        'EEEE'  : $locale.DATETIME_FORMATS.DAY.join('|'),\r\n        'EEE'   : $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\r\n        'dd'    : '0[1-9]|[12][0-9]|3[01]',\r\n        'd'     : options.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',\r\n        'MMMM'  : $locale.DATETIME_FORMATS.MONTH.join('|'),\r\n        'MMM'   : $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\r\n        'MM'    : '0[1-9]|1[012]',\r\n        'M'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\r\n        'yyyy'  : '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',\r\n        'yy'    : '[0-9]{2}',\r\n        'y'     : options.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}'\r\n      };\r\n\r\n      var setFnMap = {\r\n        'sss'   : proto.setMilliseconds,\r\n        'ss'    : proto.setSeconds,\r\n        's'     : proto.setSeconds,\r\n        'mm'    : proto.setMinutes,\r\n        'm'     : proto.setMinutes,\r\n        'HH'    : proto.setHours,\r\n        'H'     : proto.setHours,\r\n        'hh'    : proto.setHours,\r\n        'h'     : proto.setHours,\r\n        'EEEE'  : noop,\r\n        'EEE'   : noop,\r\n        'dd'    : proto.setDate,\r\n        'd'     : proto.setDate,\r\n        'a'     : function (value) { var hours = this.getHours() % 12; return this.setHours(value.match(/pm/i) ? hours + 12 : hours); },\r\n        'MMMM'  : function (value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.MONTH, value)); },\r\n        'MMM'   : function (value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.SHORTMONTH, value)); },\r\n        'MM'    : function (value) { return this.setMonth(1 * value - 1); },\r\n        'M'     : function (value) { return this.setMonth(1 * value - 1); },\r\n        'yyyy'  : proto.setFullYear,\r\n        'yy'    : function (value) { return this.setFullYear(2000 + 1 * value); },\r\n        'y'     : function (value) { return (1 * value <= 50 && value.length === 2) ? this.setFullYear(2000 + 1 * value) : this.setFullYear(1 * value); }\r\n      };\r\n      /* eslint-enable key-spacing, quote-props */\r\n\r\n      var regex;\r\n      var setMap;\r\n\r\n      $dateParser.init = function () {\r\n        $dateParser.$format = $locale.DATETIME_FORMATS[options.format] || options.format;\r\n        regex = regExpForFormat($dateParser.$format);\r\n        setMap = setMapForFormat($dateParser.$format);\r\n      };\r\n\r\n      $dateParser.isValid = function (date) {\r\n        if (angular.isDate(date)) return !isNaN(date.getTime());\r\n        return regex.test(date);\r\n      };\r\n\r\n      $dateParser.parse = function (value, baseDate, format, timezone) {\r\n        // check for date format special names\r\n        if (format) format = $locale.DATETIME_FORMATS[format] || format;\r\n        if (angular.isDate(value)) value = dateFilter(value, format || $dateParser.$format, timezone);\r\n        var formatRegex = format ? regExpForFormat(format) : regex;\r\n        var formatSetMap = format ? setMapForFormat(format) : setMap;\r\n        var matches = formatRegex.exec(value);\r\n        if (!matches) return false;\r\n        // use custom ParseDate object to set parsed values\r\n        var date = baseDate && !isNaN(baseDate.getTime()) ? new ParseDate().fromDate(baseDate) : new ParseDate().fromDate(new Date(1970, 0, 1, 0));\r\n        for (var i = 0; i < matches.length - 1; i++) {\r\n          if (formatSetMap[i]) formatSetMap[i].call(date, matches[i + 1]);\r\n        }\r\n        // convert back to native Date object\r\n        var newDate = date.toDate();\r\n\r\n        // check new native Date object for day values overflow\r\n        if (parseInt(date.day, 10) !== newDate.getDate()) {\r\n          return false;\r\n        }\r\n\r\n        return newDate;\r\n      };\r\n\r\n      $dateParser.getDateForAttribute = function (key, value) {\r\n        var date;\r\n\r\n        if (value === 'today') {\r\n          var today = new Date();\r\n          date = new Date(today.getFullYear(), today.getMonth(), today.getDate() + (key === 'maxDate' ? 1 : 0), 0, 0, 0, (key === 'minDate' ? 0 : -1));\r\n        } else if (angular.isString(value) && value.match(/^\".+\"$/)) { // Support {{ dateObj }}\r\n          date = new Date(value.substr(1, value.length - 2));\r\n        } else if (isNumeric(value)) {\r\n          date = new Date(parseInt(value, 10));\r\n        } else if (angular.isString(value) && value.length === 0) { // Reset date\r\n          date = key === 'minDate' ? -Infinity : +Infinity;\r\n        } else {\r\n          date = new Date(value);\r\n        }\r\n\r\n        return date;\r\n      };\r\n\r\n      $dateParser.getTimeForAttribute = function (key, value) {\r\n        var time;\r\n\r\n        if (value === 'now') {\r\n          time = new Date().setFullYear(1970, 0, 1);\r\n        } else if (angular.isString(value) && value.match(/^\".+\"$/)) {\r\n          time = new Date(value.substr(1, value.length - 2)).setFullYear(1970, 0, 1);\r\n        } else if (isNumeric(value)) {\r\n          time = new Date(parseInt(value, 10)).setFullYear(1970, 0, 1);\r\n        } else if (angular.isString(value) && value.length === 0) { // Reset time\r\n          time = key === 'minTime' ? -Infinity : +Infinity;\r\n        } else {\r\n          time = $dateParser.parse(value, new Date(1970, 0, 1, 0));\r\n        }\r\n\r\n        return time;\r\n      };\r\n\r\n      /* Handle switch to/from daylight saving.\r\n      * Hours may be non-zero on daylight saving cut-over:\r\n      * > 12 when midnight changeover, but then cannot generate\r\n      * midnight datetime, so jump to 1AM, otherwise reset.\r\n      * @param  date  (Date) the date to check\r\n      * @return  (Date) the corrected date\r\n      *\r\n      * __ copied from jquery ui datepicker __\r\n      */\r\n      $dateParser.daylightSavingAdjust = function (date) {\r\n        if (!date) {\r\n          return null;\r\n        }\r\n        date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);\r\n        return date;\r\n      };\r\n\r\n      /* Correct the date for timezone offset.\r\n      * @param  date  (Date) the date to adjust\r\n      * @param  timezone  (string) the timezone to adjust for\r\n      * @param  undo  (boolean) to add or subtract timezone offset\r\n      * @return  (Date) the corrected date\r\n      */\r\n      $dateParser.timezoneOffsetAdjust = function (date, timezone, undo) {\r\n        if (!date) {\r\n          return null;\r\n        }\r\n        // Right now, only 'UTC' is supported.\r\n        if (timezone && timezone === 'UTC') {\r\n          date = new Date(date.getTime());\r\n          date.setMinutes(date.getMinutes() + (undo ? -1 : 1) * date.getTimezoneOffset());\r\n        }\r\n        return date;\r\n      };\r\n\r\n      // Private functions\r\n\r\n      function regExpForFormat (format) {\r\n        // `format` string can contain literal values.\r\n        // These need to be escaped by surrounding with\r\n        // single quotes (e.g. `\"h 'in the morning'\"`).\r\n        // In order to output a single quote, escape it - i.e.,\r\n        // two single quotes in a sequence (e.g. `\"h 'o''clock'\"`).\r\n\r\n        var re = buildDateAbstractRegex(format);\r\n        return buildDateParseRegex(re);\r\n      }\r\n\r\n      function buildDateAbstractRegex (format) {\r\n        var escapedFormat = escapeReservedSymbols(format);\r\n        var escapedLiteralFormat = escapedFormat.replace(/''/g, '\\\\\\'');\r\n        var literalRegex = /('(?:\\\\'|.)*?')/;\r\n        var formatParts = escapedLiteralFormat.split(literalRegex);\r\n        var dateElements = Object.keys(regExpMap);\r\n        var dateRegexParts = [];\r\n\r\n        angular.forEach(formatParts, function (part) {\r\n          if (isFormatStringLiteral(part)) {\r\n            part = trimLiteralEscapeChars(part);\r\n          } else {\r\n            // Abstract replaces to avoid collisions\r\n            for (var i = 0; i < dateElements.length; i++) {\r\n              part = part.split(dateElements[i]).join('${' + i + '}');\r\n            }\r\n          }\r\n          dateRegexParts.push(part);\r\n        });\r\n\r\n        return dateRegexParts.join('');\r\n      }\r\n\r\n      function escapeReservedSymbols (text) {\r\n        return text.replace(/\\\\/g, '[\\\\\\\\]')\r\n                   .replace(/-/g, '[-]')\r\n                   .replace(/\\./g, '[.]')\r\n                   .replace(/\\*/g, '[*]')\r\n                   .replace(/\\+/g, '[+]')\r\n                   .replace(/\\?/g, '[?]')\r\n                   .replace(/\\$/g, '[$]')\r\n                   .replace(/\\^/g, '[^]')\r\n                   .replace(/\\//g, '[/]')\r\n                   .replace(/\\\\s/g, '[\\\\s]');\r\n      }\r\n\r\n      function isFormatStringLiteral (text) {\r\n        return /^'.*'$/.test(text);\r\n      }\r\n\r\n      function trimLiteralEscapeChars (text) {\r\n        return text.replace(/^'(.*)'$/, '$1');\r\n      }\r\n\r\n      function buildDateParseRegex (abstractRegex) {\r\n        var dateElements = Object.keys(regExpMap);\r\n        var re = abstractRegex;\r\n\r\n        // Replace abstracted values\r\n        for (var i = 0; i < dateElements.length; i++) {\r\n          re = re.split('${' + i + '}').join('(' + regExpMap[dateElements[i]] + ')');\r\n        }\r\n\r\n        return new RegExp('^' + re + '$', ['i']);\r\n      }\r\n\r\n      function setMapForFormat (format) {\r\n        var re = buildDateAbstractRegex(format);\r\n        return buildDateParseValuesMap(re);\r\n      }\r\n\r\n      function buildDateParseValuesMap (abstractRegex) {\r\n        var dateElements = Object.keys(regExpMap);\r\n        var valuesRegex = new RegExp('\\\\${(\\\\d+)}', 'g');\r\n        var valuesMatch;\r\n        var keyIndex;\r\n        var valueKey;\r\n        var valueFunction;\r\n        var valuesFunctionMap = [];\r\n\r\n        /* eslint-disable no-cond-assign */\r\n        while ((valuesMatch = valuesRegex.exec(abstractRegex)) !== null) {\r\n          keyIndex = valuesMatch[1];\r\n          valueKey = dateElements[keyIndex];\r\n          valueFunction = setFnMap[valueKey];\r\n\r\n          valuesFunctionMap.push(valueFunction);\r\n        }\r\n\r\n        return valuesFunctionMap;\r\n      }\r\n\r\n      $dateParser.init();\r\n      return $dateParser;\r\n\r\n    };\r\n\r\n    return DateParserFactory;\r\n\r\n  };\r\n\r\n});\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.helpers.dateFormatter', [])\r\n\r\n  .service('$dateFormatter', function ($locale, dateFilter) {\r\n\r\n    // The unused `lang` arguments are on purpose. The default implementation does not\r\n    // use them and it always uses the locale loaded into the `$locale` service.\r\n    // Custom implementations might use it, thus allowing different directives to\r\n    // have different languages.\r\n\r\n    this.getDefaultLocale = function () {\r\n      return $locale.id;\r\n    };\r\n\r\n    // Format is either a data format name, e.g. \"shortTime\" or \"fullDate\", or a date format\r\n    // Return either the corresponding date format or the given date format.\r\n    this.getDatetimeFormat = function (format, lang) {\r\n      return $locale.DATETIME_FORMATS[format] || format;\r\n    };\r\n\r\n    this.weekdaysShort = function (lang) {\r\n      return $locale.DATETIME_FORMATS.SHORTDAY;\r\n    };\r\n\r\n    this.weekdays = function (lang) {\r\n      return $locale.DATETIME_FORMATS.DAY;\r\n    };\r\n\r\n    function splitTimeFormat (format) {\r\n      return /(h+)([:\\.])?(m+)([:\\.])?(s*)[ ]?(a?)/i.exec(format).slice(1);\r\n    }\r\n\r\n    // h:mm a => h\r\n    this.hoursFormat = function (timeFormat) {\r\n      return splitTimeFormat(timeFormat)[0];\r\n    };\r\n\r\n    // h:mm a => mm\r\n    this.minutesFormat = function (timeFormat) {\r\n      return splitTimeFormat(timeFormat)[2];\r\n    };\r\n\r\n    // h:mm:ss a => ss\r\n    this.secondsFormat = function (timeFormat) {\r\n      return splitTimeFormat(timeFormat)[4];\r\n    };\r\n\r\n    // h:mm a => :\r\n    this.timeSeparator = function (timeFormat) {\r\n      return splitTimeFormat(timeFormat)[1];\r\n    };\r\n\r\n    // h:mm:ss a => true, h:mm a => false\r\n    this.showSeconds = function (timeFormat) {\r\n      return !!splitTimeFormat(timeFormat)[4];\r\n    };\r\n\r\n    // h:mm a => true, H.mm => false\r\n    this.showAM = function (timeFormat) {\r\n      return !!splitTimeFormat(timeFormat)[5];\r\n    };\r\n\r\n    this.formatDate = function (date, format, lang, timezone) {\r\n      return dateFilter(date, format, timezone);\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\r\n\r\n  .provider('$tooltip', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      customClass: '',\r\n      prefixClass: 'tooltip',\r\n      prefixEvent: 'tooltip',\r\n      container: false,\r\n      target: false,\r\n      placement: 'top',\r\n      templateUrl: 'tooltip/tooltip.tpl.html',\r\n      template: '',\r\n      titleTemplate: false,\r\n      trigger: 'hover focus',\r\n      keyboard: false,\r\n      html: false,\r\n      show: false,\r\n      title: '',\r\n      type: '',\r\n      delay: 0,\r\n      autoClose: false,\r\n      bsEnabled: true,\r\n      mouseDownPreventDefault: true,\r\n      mouseDownStopPropagation: true,\r\n      viewport: {\r\n        selector: 'body',\r\n        padding: 0\r\n      }\r\n    };\r\n\r\n    this.$get = function ($window, $rootScope, $bsCompiler, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\r\n\r\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n      var isTouch = ('createTouch' in $window.document) && isNative;\r\n      var $body = angular.element($window.document);\r\n\r\n      function TooltipFactory (element, config) {\r\n\r\n        var $tooltip = {};\r\n\r\n        // Common vars\r\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\r\n        var promise = $tooltip.$promise = $bsCompiler.compile(options);\r\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\r\n\r\n        var nodeName = element[0].nodeName.toLowerCase();\r\n        if (options.delay && angular.isString(options.delay)) {\r\n          var split = options.delay.split(',').map(parseFloat);\r\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\r\n        }\r\n\r\n        // Store $id to identify the triggering element in events\r\n        // give priority to options.id, otherwise, try to use\r\n        // element id if defined\r\n        $tooltip.$id = options.id || element.attr('id') || '';\r\n\r\n        // Support scope as string options\r\n        if (options.title) {\r\n          scope.title = $sce.trustAsHtml(options.title);\r\n        }\r\n\r\n        // Provide scope helpers\r\n        scope.$setEnabled = function (isEnabled) {\r\n          scope.$$postDigest(function () {\r\n            $tooltip.setEnabled(isEnabled);\r\n          });\r\n        };\r\n        scope.$hide = function () {\r\n          scope.$$postDigest(function () {\r\n            $tooltip.hide();\r\n          });\r\n        };\r\n        scope.$show = function () {\r\n          scope.$$postDigest(function () {\r\n            $tooltip.show();\r\n          });\r\n        };\r\n        scope.$toggle = function () {\r\n          scope.$$postDigest(function () {\r\n            $tooltip.toggle();\r\n          });\r\n        };\r\n        // Publish isShown as a protected var on scope\r\n        $tooltip.$isShown = scope.$isShown = false;\r\n\r\n        // Private vars\r\n        var timeout;\r\n        var hoverState;\r\n\r\n        // Fetch, compile then initialize tooltip\r\n        var compileData;\r\n        var tipElement;\r\n        var tipContainer;\r\n        var tipScope;\r\n        promise.then(function (data) {\r\n          compileData = data;\r\n          $tooltip.init();\r\n        });\r\n\r\n        $tooltip.init = function () {\r\n\r\n          // Options: delay\r\n          if (options.delay && angular.isNumber(options.delay)) {\r\n            options.delay = {\r\n              show: options.delay,\r\n              hide: options.delay\r\n            };\r\n          }\r\n\r\n          // Replace trigger on touch devices ?\r\n          // if(isTouch && options.trigger === defaults.trigger) {\r\n          //   options.trigger.replace(/hover/g, 'click');\r\n          // }\r\n\r\n          // Options : container\r\n          if (options.container === 'self') {\r\n            tipContainer = element;\r\n          } else if (angular.isElement(options.container)) {\r\n            tipContainer = options.container;\r\n          } else if (options.container) {\r\n            tipContainer = findElement(options.container);\r\n          }\r\n\r\n          // Options: trigger\r\n          bindTriggerEvents();\r\n\r\n          // Options: target\r\n          if (options.target) {\r\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\r\n          }\r\n\r\n          // Options: show\r\n          if (options.show) {\r\n            scope.$$postDigest(function () {\r\n              if (options.trigger === 'focus') {\r\n                element[0].focus();\r\n              } else {\r\n                $tooltip.show();\r\n              }\r\n            });\r\n          }\r\n\r\n        };\r\n\r\n        $tooltip.destroy = function () {\r\n\r\n          // Unbind events\r\n          unbindTriggerEvents();\r\n\r\n          // Remove element\r\n          destroyTipElement();\r\n\r\n          // Destroy scope\r\n          scope.$destroy();\r\n\r\n        };\r\n\r\n        $tooltip.enter = function () {\r\n\r\n          clearTimeout(timeout);\r\n          hoverState = 'in';\r\n          if (!options.delay || !options.delay.show) {\r\n            return $tooltip.show();\r\n          }\r\n\r\n          timeout = setTimeout(function () {\r\n            if (hoverState === 'in') $tooltip.show();\r\n          }, options.delay.show);\r\n\r\n        };\r\n\r\n        $tooltip.show = function () {\r\n          if (!options.bsEnabled || $tooltip.$isShown) return;\r\n\r\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\r\n          if (angular.isDefined(options.onBeforeShow) && angular.isFunction(options.onBeforeShow)) {\r\n            options.onBeforeShow($tooltip);\r\n          }\r\n          var parent;\r\n          var after;\r\n          if (options.container) {\r\n            parent = tipContainer;\r\n            if (tipContainer[0].lastChild) {\r\n              after = angular.element(tipContainer[0].lastChild);\r\n            } else {\r\n              after = null;\r\n            }\r\n          } else {\r\n            parent = null;\r\n            after = element;\r\n          }\r\n\r\n\r\n          // Hide any existing tipElement\r\n          if (tipElement) destroyTipElement();\r\n          // Fetch a cloned element linked from template\r\n          tipScope = $tooltip.$scope.$new();\r\n          tipElement = $tooltip.$element = compileData.link(tipScope, function (clonedElement, scope) {});\r\n\r\n          // Set the initial positioning.  Make the tooltip invisible\r\n          // so IE doesn't try to focus on it off screen.\r\n          tipElement.css({top: '-9999px', left: '-9999px', right: 'auto', display: 'block', visibility: 'hidden'});\r\n\r\n          // Options: animation\r\n          if (options.animation) tipElement.addClass(options.animation);\r\n          // Options: type\r\n          if (options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\r\n          // Options: custom classes\r\n          if (options.customClass) tipElement.addClass(options.customClass);\r\n\r\n          // Append the element, without any animations.  If we append\r\n          // using $animate.enter, some of the animations cause the placement\r\n          // to be off due to the transforms.\r\n          if (after) {\r\n            after.after(tipElement);\r\n          } else {\r\n            parent.prepend(tipElement);\r\n          }\r\n\r\n          $tooltip.$isShown = scope.$isShown = true;\r\n          safeDigest(scope);\r\n\r\n          // Now, apply placement\r\n          $tooltip.$applyPlacement();\r\n\r\n          // Once placed, animate it.\r\n          // Support v1.2+ $animate\r\n          // https://github.com/angular/angular.js/issues/11713\r\n          if (angular.version.minor <= 2) {\r\n            $animate.enter(tipElement, parent, after, enterAnimateCallback);\r\n          } else {\r\n            $animate.enter(tipElement, parent, after).then(enterAnimateCallback);\r\n          }\r\n          safeDigest(scope);\r\n\r\n          $$rAF(function () {\r\n            // Once the tooltip is placed and the animation starts, make the tooltip visible\r\n            if (tipElement) tipElement.css({visibility: 'visible'});\r\n\r\n            // Bind events\r\n            if (options.keyboard) {\r\n              if (options.trigger !== 'focus') {\r\n                $tooltip.focus();\r\n              }\r\n              bindKeyboardEvents();\r\n            }\r\n          });\r\n\r\n          if (options.autoClose) {\r\n            bindAutoCloseEvents();\r\n          }\r\n\r\n        };\r\n\r\n        function enterAnimateCallback () {\r\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\r\n          if (angular.isDefined(options.onShow) && angular.isFunction(options.onShow)) {\r\n            options.onShow($tooltip);\r\n          }\r\n        }\r\n\r\n        $tooltip.leave = function () {\r\n\r\n          clearTimeout(timeout);\r\n          hoverState = 'out';\r\n          if (!options.delay || !options.delay.hide) {\r\n            return $tooltip.hide();\r\n          }\r\n          timeout = setTimeout(function () {\r\n            if (hoverState === 'out') {\r\n              $tooltip.hide();\r\n            }\r\n          }, options.delay.hide);\r\n\r\n        };\r\n\r\n        var _blur;\r\n        var _tipToHide;\r\n        $tooltip.hide = function (blur) {\r\n\r\n          if (!$tooltip.$isShown) return;\r\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\r\n          if (angular.isDefined(options.onBeforeHide) && angular.isFunction(options.onBeforeHide)) {\r\n            options.onBeforeHide($tooltip);\r\n          }\r\n\r\n          // store blur value for leaveAnimateCallback to use\r\n          _blur = blur;\r\n\r\n          // store current tipElement reference to use\r\n          // in leaveAnimateCallback\r\n          _tipToHide = tipElement;\r\n\r\n          if (tipElement !== null) {\r\n            // Support v1.2+ $animate\r\n            // https://github.com/angular/angular.js/issues/11713\r\n            if (angular.version.minor <= 2) {\r\n              $animate.leave(tipElement, leaveAnimateCallback);\r\n            } else {\r\n              $animate.leave(tipElement).then(leaveAnimateCallback);\r\n            }\r\n          }\r\n\r\n          $tooltip.$isShown = scope.$isShown = false;\r\n          safeDigest(scope);\r\n\r\n          // Unbind events\r\n          if (options.keyboard && tipElement !== null) {\r\n            unbindKeyboardEvents();\r\n          }\r\n\r\n          if (options.autoClose && tipElement !== null) {\r\n            unbindAutoCloseEvents();\r\n          }\r\n        };\r\n\r\n        function leaveAnimateCallback () {\r\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\r\n          if (angular.isDefined(options.onHide) && angular.isFunction(options.onHide)) {\r\n            options.onHide($tooltip);\r\n          }\r\n\r\n          // check if current tipElement still references\r\n          // the same element when hide was called\r\n          if (tipElement === _tipToHide) {\r\n            // Allow to blur the input when hidden, like when pressing enter key\r\n            if (_blur && options.trigger === 'focus') {\r\n              return element[0].blur();\r\n            }\r\n\r\n            // clean up child scopes\r\n            destroyTipElement();\r\n          }\r\n        }\r\n\r\n        $tooltip.toggle = function (evt) {\r\n          if (evt) { evt.preventDefault(); }\r\n          if ($tooltip.$isShown) {\r\n            $tooltip.leave();\r\n          } else {\r\n            $tooltip.enter();\r\n          }\r\n        };\r\n\r\n        $tooltip.focus = function () {\r\n          tipElement[0].focus();\r\n        };\r\n\r\n        $tooltip.setEnabled = function (isEnabled) {\r\n          options.bsEnabled = isEnabled;\r\n        };\r\n\r\n        $tooltip.setViewport = function (viewport) {\r\n          options.viewport = viewport;\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $tooltip.$applyPlacement = function () {\r\n          if (!tipElement) return;\r\n\r\n          // Determine if we're doing an auto or normal placement\r\n          var placement = options.placement;\r\n          var autoToken = /\\s?auto?\\s?/i;\r\n          var autoPlace = autoToken.test(placement);\r\n\r\n          if (autoPlace) {\r\n            placement = placement.replace(autoToken, '') || defaults.placement;\r\n          }\r\n\r\n          // Need to add the position class before we get\r\n          // the offsets\r\n          tipElement.addClass(options.placement);\r\n\r\n          // Get the position of the target element\r\n          // and the height and width of the tooltip so we can center it.\r\n          var elementPosition = getPosition();\r\n          var tipWidth = tipElement.prop('offsetWidth');\r\n          var tipHeight = tipElement.prop('offsetHeight');\r\n\r\n          // Refresh viewport position\r\n          $tooltip.$viewport = options.viewport && findElement(options.viewport.selector || options.viewport);\r\n\r\n          // If we're auto placing, we need to check the positioning\r\n          if (autoPlace) {\r\n            var originalPlacement = placement;\r\n            var viewportPosition = getPosition($tooltip.$viewport);\r\n\r\n            if (/bottom/.test(originalPlacement) && elementPosition.bottom + tipHeight > viewportPosition.bottom) {\r\n              placement = originalPlacement.replace('bottom', 'top');\r\n            } else if (/top/.test(originalPlacement) && elementPosition.top - tipHeight < viewportPosition.top) {\r\n              placement = originalPlacement.replace('top', 'bottom');\r\n            }\r\n\r\n            if (/left/.test(originalPlacement) && elementPosition.left - tipWidth < viewportPosition.left) {\r\n              placement = placement.replace('left', 'right');\r\n            } else if (/right/.test(originalPlacement) && elementPosition.right + tipWidth > viewportPosition.width) {\r\n              placement = placement.replace('right', 'left');\r\n            }\r\n\r\n            tipElement.removeClass(originalPlacement).addClass(placement);\r\n          }\r\n\r\n          // Get the tooltip's top and left coordinates to center it with this directive.\r\n          var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\r\n          applyPlacement(tipPosition, placement);\r\n        };\r\n\r\n        $tooltip.$onKeyUp = function (evt) {\r\n          if (evt.which === 27 && $tooltip.$isShown) {\r\n            $tooltip.hide();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        $tooltip.$onFocusKeyUp = function (evt) {\r\n          if (evt.which === 27) {\r\n            element[0].blur();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        $tooltip.$onFocusElementMouseDown = function (evt) {\r\n          if (options.mouseDownPreventDefault) { evt.preventDefault(); }\r\n          if (options.mouseDownStopPropagation) { evt.stopPropagation(); }\r\n          // Some browsers do not auto-focus buttons (eg. Safari)\r\n          if ($tooltip.$isShown) {\r\n            element[0].blur();\r\n          } else {\r\n            element[0].focus();\r\n          }\r\n        };\r\n\r\n        // bind/unbind events\r\n        function bindTriggerEvents () {\r\n          var triggers = options.trigger.split(' ');\r\n          angular.forEach(triggers, function (trigger) {\r\n            if (trigger === 'click' || trigger === 'contextmenu') {\r\n              element.on(trigger, $tooltip.toggle);\r\n              // element.on('blur', $tooltip.leave);\r\n            } else if (trigger !== 'manual') {\r\n              element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\r\n              element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\r\n              if (nodeName === 'button' && trigger !== 'hover') {\r\n                element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\r\n              }\r\n            }\r\n          });\r\n        }\r\n\r\n        function unbindTriggerEvents () {\r\n          var triggers = options.trigger.split(' ');\r\n          for (var i = triggers.length; i--;) {\r\n            var trigger = triggers[i];\r\n            if (trigger === 'click' || trigger === 'contextmenu') {\r\n              element.off(trigger, $tooltip.toggle);\r\n            } else if (trigger !== 'manual') {\r\n              element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\r\n              element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\r\n              if (nodeName === 'button' && trigger !== 'hover') {\r\n                element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        function bindKeyboardEvents () {\r\n          if (options.trigger !== 'focus') {\r\n            tipElement.on('keyup', $tooltip.$onKeyUp);\r\n          } else {\r\n            element.on('keyup', $tooltip.$onFocusKeyUp);\r\n          }\r\n        }\r\n\r\n        function unbindKeyboardEvents () {\r\n          if (options.trigger !== 'focus') {\r\n            tipElement.off('keyup', $tooltip.$onKeyUp);\r\n          } else {\r\n            element.off('keyup', $tooltip.$onFocusKeyUp);\r\n          }\r\n        }\r\n\r\n        var _autoCloseEventsBinded = false;\r\n        function bindAutoCloseEvents () {\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed imediately.\r\n          $timeout(function () {\r\n            // Stop propagation when clicking inside tooltip\r\n            tipElement.on('click', stopEventPropagation);\r\n\r\n            // Hide when clicking outside tooltip\r\n            $body.on('click', $tooltip.hide);\r\n\r\n            _autoCloseEventsBinded = true;\r\n          }, 0, false);\r\n        }\r\n\r\n        function unbindAutoCloseEvents () {\r\n          if (_autoCloseEventsBinded) {\r\n            tipElement.off('click', stopEventPropagation);\r\n            $body.off('click', $tooltip.hide);\r\n            _autoCloseEventsBinded = false;\r\n          }\r\n        }\r\n\r\n        function stopEventPropagation (event) {\r\n          event.stopPropagation();\r\n        }\r\n\r\n        // Private methods\r\n\r\n        function getPosition ($element) {\r\n          $element = $element || (options.target || element);\r\n\r\n          var el = $element[0];\r\n          var isBody = el.tagName === 'BODY';\r\n\r\n          var elRect = el.getBoundingClientRect();\r\n          var rect = {};\r\n\r\n          // IE8 has issues with angular.extend and using elRect directly.\r\n          // By coping the values of elRect into a new object, we can continue to use extend\r\n          /* eslint-disable guard-for-in */\r\n          for (var p in elRect) { // eslint-disable-line\r\n            // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.\r\n            rect[p] = elRect[p];\r\n          }\r\n          /* eslint-enable guard-for-in */\r\n\r\n          if (rect.width === null) {\r\n            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\r\n            rect = angular.extend({}, rect, {width: elRect.right - elRect.left, height: elRect.bottom - elRect.top});\r\n          }\r\n          var elOffset = isBody ? {top: 0, left: 0} : dimensions.offset(el);\r\n          var scroll = {scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0};\r\n          var outerDims = isBody ? {width: document.documentElement.clientWidth, height: $window.innerHeight} : null;\r\n\r\n          return angular.extend({}, rect, scroll, outerDims, elOffset);\r\n        }\r\n\r\n        function getCalculatedOffset (placement, position, actualWidth, actualHeight) {\r\n          var offset;\r\n          var split = placement.split('-');\r\n\r\n          switch (split[0]) {\r\n            case 'right':\r\n              offset = {\r\n                top: position.top + position.height / 2 - actualHeight / 2,\r\n                left: position.left + position.width\r\n              };\r\n              break;\r\n            case 'bottom':\r\n              offset = {\r\n                top: position.top + position.height,\r\n                left: position.left + position.width / 2 - actualWidth / 2\r\n              };\r\n              break;\r\n            case 'left':\r\n              offset = {\r\n                top: position.top + position.height / 2 - actualHeight / 2,\r\n                left: position.left - actualWidth\r\n              };\r\n              break;\r\n            default:\r\n              offset = {\r\n                top: position.top - actualHeight,\r\n                left: position.left + position.width / 2 - actualWidth / 2\r\n              };\r\n              break;\r\n          }\r\n\r\n          if (!split[1]) {\r\n            return offset;\r\n          }\r\n\r\n          // Add support for corners @todo css\r\n          if (split[0] === 'top' || split[0] === 'bottom') {\r\n            switch (split[1]) {\r\n              case 'left':\r\n                offset.left = position.left;\r\n                break;\r\n              case 'right':\r\n                offset.left = position.left + position.width - actualWidth;\r\n                break;\r\n              default:\r\n                break;\r\n            }\r\n          } else if (split[0] === 'left' || split[0] === 'right') {\r\n            switch (split[1]) {\r\n              case 'top':\r\n                offset.top = position.top - actualHeight + position.height;\r\n                break;\r\n              case 'bottom':\r\n                offset.top = position.top;\r\n                break;\r\n              default:\r\n                break;\r\n            }\r\n          }\r\n\r\n          return offset;\r\n        }\r\n\r\n        function applyPlacement (offset, placement) {\r\n          var tip = tipElement[0];\r\n          var width = tip.offsetWidth;\r\n          var height = tip.offsetHeight;\r\n\r\n          // manually read margins because getBoundingClientRect includes difference\r\n          var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10);\r\n          var marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);\r\n\r\n          // we must check for NaN for ie 8/9\r\n          if (isNaN(marginTop)) marginTop = 0;\r\n          if (isNaN(marginLeft)) marginLeft = 0;\r\n\r\n          offset.top = offset.top + marginTop;\r\n          offset.left = offset.left + marginLeft;\r\n\r\n          // dimensions setOffset doesn't round pixel values\r\n          // so we use setOffset directly with our own function\r\n          dimensions.setOffset(tip, angular.extend({\r\n            using: function (props) {\r\n              tipElement.css({\r\n                top: Math.round(props.top) + 'px',\r\n                left: Math.round(props.left) + 'px',\r\n                right: ''\r\n              });\r\n            }\r\n          }, offset), 0);\r\n\r\n          // check to see if placing tip in new offset caused the tip to resize itself\r\n          var actualWidth = tip.offsetWidth;\r\n          var actualHeight = tip.offsetHeight;\r\n\r\n          if (placement === 'top' && actualHeight !== height) {\r\n            offset.top = offset.top + height - actualHeight;\r\n          }\r\n\r\n          // If it's an exotic placement, exit now instead of\r\n          // applying a delta and changing the arrow\r\n          if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;\r\n\r\n          var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\r\n\r\n          if (delta.left) {\r\n            offset.left += delta.left;\r\n          } else {\r\n            offset.top += delta.top;\r\n          }\r\n\r\n          dimensions.setOffset(tip, offset);\r\n\r\n          if (/top|right|bottom|left/.test(placement)) {\r\n            var isVertical = /top|bottom/.test(placement);\r\n            var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;\r\n            var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';\r\n\r\n            replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);\r\n          }\r\n        }\r\n\r\n        // @source https://github.com/twbs/bootstrap/blob/v3.3.5/js/tooltip.js#L380\r\n        function getViewportAdjustedDelta (placement, position, actualWidth, actualHeight) {\r\n          var delta = {top: 0, left: 0};\r\n          if (!$tooltip.$viewport) return delta;\r\n\r\n          var viewportPadding = options.viewport && options.viewport.padding || 0;\r\n          var viewportDimensions = getPosition($tooltip.$viewport);\r\n\r\n          if (/right|left/.test(placement)) {\r\n            var topEdgeOffset = position.top - viewportPadding - viewportDimensions.scroll;\r\n            var bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;\r\n            if (topEdgeOffset < viewportDimensions.top) { // top overflow\r\n              delta.top = viewportDimensions.top - topEdgeOffset;\r\n            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\r\n              delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\r\n            }\r\n          } else {\r\n            var leftEdgeOffset = position.left - viewportPadding;\r\n            var rightEdgeOffset = position.left + viewportPadding + actualWidth;\r\n            if (leftEdgeOffset < viewportDimensions.left) { // left overflow\r\n              delta.left = viewportDimensions.left - leftEdgeOffset;\r\n            } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow\r\n              delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\r\n            }\r\n          }\r\n\r\n          return delta;\r\n        }\r\n\r\n        function replaceArrow (delta, dimension, isHorizontal) {\r\n          var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);\r\n\r\n          $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\r\n                .css(isHorizontal ? 'top' : 'left', '');\r\n        }\r\n\r\n        function destroyTipElement () {\r\n          // Cancel pending callbacks\r\n          clearTimeout(timeout);\r\n\r\n          if ($tooltip.$isShown && tipElement !== null) {\r\n            if (options.autoClose) {\r\n              unbindAutoCloseEvents();\r\n            }\r\n\r\n            if (options.keyboard) {\r\n              unbindKeyboardEvents();\r\n            }\r\n          }\r\n\r\n          if (tipScope) {\r\n            tipScope.$destroy();\r\n            tipScope = null;\r\n          }\r\n\r\n          if (tipElement) {\r\n            tipElement.remove();\r\n            tipElement = $tooltip.$element = null;\r\n          }\r\n        }\r\n\r\n        return $tooltip;\r\n\r\n      }\r\n\r\n      // Helper functions\r\n\r\n      function safeDigest (scope) {\r\n        /* eslint-disable no-unused-expressions */\r\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\r\n        /* eslint-enable no-unused-expressions */\r\n      }\r\n\r\n      function findElement (query, element) {\r\n        return angular.element((element || document).querySelectorAll(query));\r\n      }\r\n\r\n      return TooltipFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsTooltip', function ($window, $location, $sce, $parse, $tooltip, $$rAF) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink (scope, element, attr, transclusion) {\r\n\r\n        var tooltip;\r\n        // Directive options\r\n        var options = {scope: scope};\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'titleTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\r\n            options[key] = false;\r\n          }\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // should not parse target attribute (anchor tag), only data-target #1454\r\n        var dataTarget = element.attr('data-target');\r\n        if (angular.isDefined(dataTarget)) {\r\n          if (falseValueRegExp.test(dataTarget)) {\r\n            options.target = false;\r\n          } else {\r\n            options.target = dataTarget;\r\n          }\r\n        }\r\n\r\n        // overwrite inherited title value when no value specified\r\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\r\n        if (!scope.hasOwnProperty('title')) {\r\n          scope.title = '';\r\n        }\r\n\r\n        // Observe scope attributes for change\r\n        attr.$observe('title', function (newValue) {\r\n          if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {\r\n            var oldValue = scope.title;\r\n            scope.title = $sce.trustAsHtml(newValue);\r\n            if (angular.isDefined(oldValue)) {\r\n              $$rAF(function () {\r\n                if (tooltip) tooltip.$applyPlacement();\r\n              });\r\n            }\r\n          }\r\n        });\r\n\r\n        attr.$observe('disabled', function (newValue) {\r\n          if (newValue && tooltip.$isShown) {\r\n            tooltip.hide();\r\n          }\r\n        });\r\n\r\n        // Support scope as an object\r\n        if (attr.bsTooltip) {\r\n          scope.$watch(attr.bsTooltip, function (newValue, oldValue) {\r\n            if (angular.isObject(newValue)) {\r\n              angular.extend(scope, newValue);\r\n            } else {\r\n              scope.title = newValue;\r\n            }\r\n            if (angular.isDefined(oldValue)) {\r\n              $$rAF(function () {\r\n                if (tooltip) tooltip.$applyPlacement();\r\n              });\r\n            }\r\n          }, true);\r\n        }\r\n\r\n        // Visibility binding support\r\n        if (attr.bsShow) {\r\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\r\n            if (!tooltip || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\r\n            if (newValue === true) {\r\n              tooltip.show();\r\n            } else {\r\n              tooltip.hide();\r\n            }\r\n          });\r\n        }\r\n\r\n        // Enabled binding support\r\n        if (attr.bsEnabled) {\r\n          scope.$watch(attr.bsEnabled, function (newValue, oldValue) {\r\n            // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\r\n            if (!tooltip || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\r\n            if (newValue === false) {\r\n              tooltip.setEnabled(false);\r\n            } else {\r\n              tooltip.setEnabled(true);\r\n            }\r\n          });\r\n        }\r\n\r\n        // Viewport support\r\n        if (attr.viewport) {\r\n          scope.$watch(attr.viewport, function (newValue) {\r\n            if (!tooltip || !angular.isDefined(newValue)) return;\r\n            tooltip.setViewport(newValue);\r\n          });\r\n        }\r\n\r\n        // Initialize popover\r\n        tooltip = $tooltip(element, options);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (tooltip) tooltip.destroy();\r\n          options = null;\r\n          tooltip = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.tab', [])\r\n\r\n  .provider('$tab', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      template: 'tab/tab.tpl.html',\r\n      navClass: 'nav-tabs',\r\n      activeClass: 'active'\r\n    };\r\n    var _tabsHash = {};\r\n\r\n    var _addTabControl = function (key, control) {\r\n      if (!_tabsHash[key]) _tabsHash[key] = control;\r\n    };\r\n\r\n    var controller = this.controller = function ($scope, $element, $attrs, $timeout) {\r\n      var self = this;\r\n\r\n      // Attributes options\r\n      self.$options = angular.copy(defaults);\r\n      angular.forEach(['animation', 'navClass', 'activeClass', 'id'], function (key) {\r\n        if (angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\r\n      });\r\n\r\n      // Publish options on scope\r\n      $scope.$navClass = self.$options.navClass;\r\n      $scope.$activeClass = self.$options.activeClass;\r\n\r\n      $scope.$onClick = function $onClick (evt, pane, index) {\r\n        if (!pane.disabled) {\r\n          self.$setActive(pane.name || index);\r\n          focusCurrentTab();\r\n        }\r\n\r\n        evt.preventDefault();\r\n        evt.stopPropagation();\r\n      };\r\n\r\n      function navigatePane (index, toLeft) {\r\n        var newIndex = 0;\r\n\r\n        if (toLeft) {\r\n          // Moving to the left\r\n          newIndex = index - 1 < 0 ? (self.$panes.length - 1) : (index - 1);\r\n        } else {\r\n          // Moving to the right\r\n          newIndex = (index + 1) >= self.$panes.length ? 0 : (index + 1);\r\n        }\r\n\r\n        if (self.$panes[newIndex].disabled) {\r\n          navigatePane(newIndex, toLeft);\r\n        } else {\r\n          self.$setActive(self.$panes[newIndex].name || newIndex);\r\n          focusCurrentTab();\r\n        }\r\n      }\r\n\r\n      function focusCurrentTab () {\r\n        $timeout(function () {\r\n          var activeAs = angular.element($element[0].querySelectorAll('li.' + self.$options.activeClass));\r\n\r\n          if (activeAs.length > 0 && activeAs[0]) {\r\n            activeAs[0].focus();\r\n          }\r\n        }, 100);\r\n      }\r\n\r\n      self.$panes = $scope.$panes = [];\r\n\r\n      // Please use $activePaneChangeListeners if you use `bsActivePane`\r\n      // Because we removed `ngModel` as default, we rename viewChangeListeners to\r\n      // activePaneChangeListeners to make more sense.\r\n      self.$activePaneChangeListeners = self.$viewChangeListeners = [];\r\n\r\n      self.$push = function (pane) {\r\n        if (angular.isUndefined(self.$panes.$active)) {\r\n          $scope.$setActive(pane.name || 0);\r\n        }\r\n\r\n        self.$panes.push(pane);\r\n\r\n        self.$panes.forEach(function (tabPane, index) {\r\n          // Set an id value for the pane so that it can be used in the template\r\n          tabPane.$describedBy = self.$options.id === undefined ? undefined : self.$options.id + '_$tab_' + index;\r\n          tabPane.$labeledBy = self.$options.id === undefined ? undefined : self.$options.id + '_$tab_' + index + '_a';\r\n        });\r\n      };\r\n\r\n      self.$remove = function (pane) {\r\n        var index = self.$panes.indexOf(pane);\r\n        var active = self.$panes.$active;\r\n        var activeIndex;\r\n        if (angular.isString(active)) {\r\n          activeIndex = self.$panes.map(function (pane) {\r\n            return pane.name;\r\n          }).indexOf(active);\r\n        } else {\r\n          activeIndex = self.$panes.$active;\r\n        }\r\n\r\n        // remove pane from $panes array\r\n        self.$panes.splice(index, 1);\r\n\r\n        if (index < activeIndex) {\r\n          // we removed a pane before the active pane, so we need to\r\n          // decrement the active pane index\r\n          activeIndex--;\r\n        } else if (index === activeIndex && activeIndex === self.$panes.length) {\r\n          // we remove the active pane and it was the one at the end,\r\n          // so select the previous one\r\n          activeIndex--;\r\n        }\r\n        if (activeIndex >= 0 && activeIndex < self.$panes.length) {\r\n          self.$setActive(self.$panes[activeIndex].name || activeIndex);\r\n        } else {\r\n          self.$setActive();\r\n        }\r\n      };\r\n\r\n      self.$setActive = $scope.$setActive = function (value) {\r\n        self.$panes.$active = value;\r\n        self.$activePaneChangeListeners.forEach(function (fn) {\r\n          fn();\r\n        });\r\n      };\r\n\r\n      self.$isActive = $scope.$isActive = function ($pane, $index) {\r\n        return self.$panes.$active === $pane.name || self.$panes.$active === $index;\r\n      };\r\n\r\n      self.$onKeyPress = $scope.$onKeyPress = function (e, name, index) {\r\n        if (e.keyCode === 32 || e.charCode === 32 || e.keyCode === 13 || e.charCode === 13) {\r\n          // If space or enter was pressed\r\n          self.$setActive(name);\r\n\r\n          e.preventDefault();\r\n          e.stopPropagation();\r\n\r\n        } else if (e.keyCode === 37 || e.charCode === 37 || e.keyCode === 39 || e.charCode === 39) {\r\n          // If the left of right arrow key was pressed.\r\n          navigatePane(index, (e.keyCode === 37 || e.charCode === 37));\r\n        }\r\n      };\r\n    };\r\n\r\n    this.$get = function () {\r\n      var $tab = {};\r\n      $tab.defaults = defaults;\r\n      $tab.controller = controller;\r\n      $tab.addTabControl = _addTabControl;\r\n      $tab.tabsHash = _tabsHash;\r\n      return $tab;\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsTabs', function ($window, $animate, $tab, $parse, $timeout) {\r\n\r\n    var defaults = $tab.defaults;\r\n\r\n    return {\r\n      require: ['?ngModel', 'bsTabs'],\r\n      transclude: true,\r\n      scope: true,\r\n      controller: ['$scope', '$element', '$attrs', '$timeout', $tab.controller],\r\n      templateUrl: function (element, attr) {\r\n        return attr.template || defaults.template;\r\n      },\r\n      link: function postLink (scope, element, attrs, controllers) {\r\n\r\n        var ngModelCtrl = controllers[0];\r\n        var bsTabsCtrl = controllers[1];\r\n\r\n        // Add a way for developers to access tab scope if needed.  This allows for more fine grained control over what\r\n        // tabs are available in the tab component\r\n        if (attrs.tabKey !== '' && attrs.tabKey !== undefined) {\r\n          $tab.addTabControl(attrs.tabKey, bsTabsCtrl);\r\n        }\r\n\r\n        // 'ngModel' does interfere with form validation\r\n        // and status, use `bsActivePane` instead to avoid it\r\n        if (ngModelCtrl) {\r\n\r\n          // Update the modelValue following\r\n          bsTabsCtrl.$activePaneChangeListeners.push(function () {\r\n            ngModelCtrl.$setViewValue(bsTabsCtrl.$panes.$active);\r\n          });\r\n\r\n          // modelValue -> $formatters -> viewValue\r\n          ngModelCtrl.$formatters.push(function (modelValue) {\r\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n            bsTabsCtrl.$setActive(modelValue);\r\n            return modelValue;\r\n          });\r\n        }\r\n\r\n        bsTabsCtrl.$activePaneChangeListeners.push(function () {\r\n          $timeout(function () {\r\n            // get li elements\r\n            var liElements = element.find('li');\r\n            for (var i = 0; i < liElements.length; i++) {\r\n              var iElement = angular.element(liElements[i]);\r\n              if (iElement.hasClass(bsTabsCtrl.$options.activeClass)) {\r\n                // if li is active, set focus to it.\r\n                iElement.find('a')[0].focus();\r\n              }\r\n            }\r\n            // delay, for the class (.active) change to reflect in DOM.\r\n          }, 100);\r\n        });\r\n\r\n        if (attrs.bsActivePane) {\r\n          // adapted from angularjs ngModelController bindings\r\n          // https://github.com/angular/angular.js/blob/v1.3.1/src%2Fng%2Fdirective%2Finput.js#L1730\r\n          var parsedBsActivePane = $parse(attrs.bsActivePane);\r\n\r\n          // Update bsActivePane value with change\r\n          bsTabsCtrl.$activePaneChangeListeners.push(function () {\r\n            parsedBsActivePane.assign(scope, bsTabsCtrl.$panes.$active);\r\n          });\r\n\r\n          // watch bsActivePane for value changes\r\n          scope.$watch(attrs.bsActivePane, function (newValue, oldValue) {\r\n            bsTabsCtrl.$setActive(newValue);\r\n          }, true);\r\n        }\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsPane', function ($window, $animate, $sce) {\r\n\r\n    return {\r\n      require: ['^?ngModel', '^bsTabs'],\r\n      scope: true,\r\n      link: function postLink (scope, element, attrs, controllers) {\r\n\r\n        // var ngModelCtrl = controllers[0];\r\n        var bsTabsCtrl = controllers[1];\r\n\r\n        // Add base class\r\n        element.addClass('tab-pane');\r\n\r\n        // Set up the assistive attributes\r\n        element.attr('role', 'tabpanel');\r\n\r\n        // Observe title attribute for change\r\n        attrs.$observe('title', function (newValue, oldValue) {\r\n          scope.title = $sce.trustAsHtml(newValue);\r\n        });\r\n\r\n        // Save tab name into scope\r\n        scope.name = attrs.name;\r\n        // Save tab id into scope\r\n        scope.id = attrs.id;\r\n\r\n        scope.name = scope.name || scope.id;\r\n\r\n        // Add animation class\r\n        if (bsTabsCtrl.$options.animation) {\r\n          element.addClass(bsTabsCtrl.$options.animation);\r\n        }\r\n\r\n        attrs.$observe('disabled', function (newValue, oldValue) {\r\n          scope.disabled = scope.$eval(newValue);\r\n        });\r\n\r\n        // Push pane to parent bsTabs controller\r\n        bsTabsCtrl.$push(scope);\r\n\r\n        // Once the push has occured when can then update the element with some properties.\r\n        // Update the aria-describedby attribute\r\n        if (scope.$describedBy !== undefined) {\r\n          element.attr('aria-describedby', scope.$describedBy);\r\n        }\r\n\r\n        // remove pane from tab controller when pane is destroyed\r\n        scope.$on('$destroy', function () {\r\n          bsTabsCtrl.$remove(scope);\r\n        });\r\n\r\n        function render () {\r\n          var index = bsTabsCtrl.$panes.indexOf(scope);\r\n\r\n          $animate[bsTabsCtrl.$isActive(scope, index) ? 'addClass' : 'removeClass'](element, bsTabsCtrl.$options.activeClass);\r\n        }\r\n\r\n        bsTabsCtrl.$activePaneChangeListeners.push(function () {\r\n          render();\r\n        });\r\n        render();\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.timepicker', ['mgcrea.ngStrap.helpers.dateParser', 'mgcrea.ngStrap.helpers.dateFormatter', 'mgcrea.ngStrap.tooltip'])\r\n\r\n  .provider('$timepicker', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      defaultDate: 'auto',\r\n      // uncommenting the following line will break backwards compatability\r\n      // prefixEvent: 'timepicker',\r\n      prefixClass: 'timepicker',\r\n      placement: 'bottom-left',\r\n      templateUrl: 'timepicker/timepicker.tpl.html',\r\n      trigger: 'focus',\r\n      container: false,\r\n      keyboard: true,\r\n      html: false,\r\n      delay: 0,\r\n      // lang: $locale.id,\r\n      useNative: true,\r\n      timeType: 'date',\r\n      timeFormat: 'shortTime',\r\n      timezone: null,\r\n      modelTimeFormat: null,\r\n      autoclose: false,\r\n      minTime: -Infinity,\r\n      maxTime: +Infinity,\r\n      length: 5,\r\n      hourStep: 1,\r\n      minuteStep: 5,\r\n      secondStep: 5,\r\n      roundDisplay: false,\r\n      iconUp: 'glyphicon glyphicon-chevron-up',\r\n      iconDown: 'glyphicon glyphicon-chevron-down',\r\n      arrowBehavior: 'pager'\r\n    };\r\n\r\n    this.$get = function ($window, $document, $rootScope, $sce, $dateFormatter, $tooltip, $timeout) {\r\n\r\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n      var isTouch = ('createTouch' in $window.document) && isNative;\r\n      if (!defaults.lang) {\r\n        defaults.lang = $dateFormatter.getDefaultLocale();\r\n      }\r\n\r\n      function timepickerFactory (element, controller, config) {\r\n\r\n        var $timepicker = $tooltip(element, angular.extend({}, defaults, config));\r\n        var parentScope = config.scope;\r\n        var options = $timepicker.$options;\r\n        var scope = $timepicker.$scope;\r\n\r\n        var lang = options.lang;\r\n        var formatDate = function (date, format, timezone) {\r\n          return $dateFormatter.formatDate(date, format, lang, timezone);\r\n        };\r\n\r\n        function floorMinutes (time) {\r\n          // coeff used to floor current time to nearest minuteStep interval\r\n          var coeff = 1000 * 60 * options.minuteStep;\r\n          return new Date(Math.floor(time.getTime() / coeff) * coeff);\r\n        }\r\n\r\n        // View vars\r\n\r\n        var selectedIndex = 0;\r\n        var defaultDate = options.roundDisplay ? floorMinutes(new Date()) : new Date();\r\n        var startDate = controller.$dateValue || defaultDate;\r\n        var viewDate = {\r\n          hour: startDate.getHours(),\r\n          meridian: startDate.getHours() < 12,\r\n          minute: startDate.getMinutes(),\r\n          second: startDate.getSeconds(),\r\n          millisecond: startDate.getMilliseconds()\r\n        };\r\n\r\n        var format = $dateFormatter.getDatetimeFormat(options.timeFormat, lang);\r\n\r\n        var hoursFormat = $dateFormatter.hoursFormat(format);\r\n        var timeSeparator = $dateFormatter.timeSeparator(format);\r\n        var minutesFormat = $dateFormatter.minutesFormat(format);\r\n        var secondsFormat = $dateFormatter.secondsFormat(format);\r\n        var showSeconds = $dateFormatter.showSeconds(format);\r\n        var showAM = $dateFormatter.showAM(format);\r\n\r\n        scope.$iconUp = options.iconUp;\r\n        scope.$iconDown = options.iconDown;\r\n\r\n        // Scope methods\r\n\r\n        scope.$select = function (date, index) {\r\n          $timepicker.select(date, index);\r\n        };\r\n        scope.$moveIndex = function (value, index) {\r\n          $timepicker.$moveIndex(value, index);\r\n        };\r\n        scope.$switchMeridian = function (date) {\r\n          $timepicker.switchMeridian(date);\r\n        };\r\n\r\n        // Public methods\r\n\r\n        $timepicker.update = function (date) {\r\n          // console.warn('$timepicker.update() newValue=%o', date);\r\n          if (angular.isDate(date) && !isNaN(date.getTime())) {\r\n            $timepicker.$date = date;\r\n            angular.extend(viewDate, {\r\n              hour: date.getHours(),\r\n              minute: date.getMinutes(),\r\n              second: date.getSeconds(),\r\n              millisecond: date.getMilliseconds()\r\n            });\r\n            $timepicker.$build();\r\n          } else if (!$timepicker.$isBuilt) {\r\n            $timepicker.$build();\r\n          }\r\n        };\r\n\r\n        $timepicker.select = function (date, index, keep) {\r\n          // console.warn('$timepicker.select', date, scope.$mode);\r\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\r\n            controller.$dateValue = options.defaultDate === 'today' ? new Date() : new Date(1970, 0, 1);\r\n          }\r\n\r\n          if (!angular.isDate(date)) date = new Date(date);\r\n          if (index === 0) controller.$dateValue.setHours(date.getHours());\r\n          else if (index === 1) controller.$dateValue.setMinutes(date.getMinutes());\r\n          else if (index === 2) controller.$dateValue.setSeconds(date.getSeconds());\r\n          controller.$setViewValue(angular.copy(controller.$dateValue));\r\n          controller.$render();\r\n          if (options.autoclose && !keep) {\r\n            $timeout(function () {\r\n              $timepicker.hide(true);\r\n            });\r\n          }\r\n        };\r\n\r\n        $timepicker.switchMeridian = function (date) {\r\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\r\n            return;\r\n          }\r\n          var hours = (date || controller.$dateValue).getHours();\r\n          controller.$dateValue.setHours(hours < 12 ? hours + 12 : hours - 12);\r\n          controller.$setViewValue(angular.copy(controller.$dateValue));\r\n          controller.$render();\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $timepicker.$build = function () {\r\n          // console.warn('$timepicker.$build() viewDate=%o', viewDate);\r\n          var i;\r\n          var midIndex = scope.midIndex = parseInt(options.length / 2, 10);\r\n          var hours = [];\r\n          var hour;\r\n          for (i = 0; i < options.length; i++) {\r\n            hour = new Date(1970, 0, 1, viewDate.hour - (midIndex - i) * options.hourStep);\r\n            hours.push({\r\n              date: hour,\r\n              label: formatDate(hour, hoursFormat),\r\n              selected: $timepicker.$date && $timepicker.$isSelected(hour, 0),\r\n              disabled: $timepicker.$isDisabled(hour, 0)\r\n            });\r\n          }\r\n          var minutes = [];\r\n          var minute;\r\n          for (i = 0; i < options.length; i++) {\r\n            minute = new Date(1970, 0, 1, 0, viewDate.minute - (midIndex - i) * options.minuteStep);\r\n            minutes.push({\r\n              date: minute,\r\n              label: formatDate(minute, minutesFormat),\r\n              selected: $timepicker.$date && $timepicker.$isSelected(minute, 1),\r\n              disabled: $timepicker.$isDisabled(minute, 1)\r\n            });\r\n          }\r\n          var seconds = [];\r\n          var second;\r\n          for (i = 0; i < options.length; i++) {\r\n            second = new Date(1970, 0, 1, 0, 0, viewDate.second - (midIndex - i) * options.secondStep);\r\n            seconds.push({\r\n              date: second,\r\n              label: formatDate(second, secondsFormat),\r\n              selected: $timepicker.$date && $timepicker.$isSelected(second, 2),\r\n              disabled: $timepicker.$isDisabled(second, 2)\r\n            });\r\n          }\r\n\r\n          var rows = [];\r\n          for (i = 0; i < options.length; i++) {\r\n            if (showSeconds) {\r\n              rows.push([hours[i], minutes[i], seconds[i]]);\r\n            } else {\r\n              rows.push([hours[i], minutes[i]]);\r\n            }\r\n          }\r\n          scope.rows = rows;\r\n          scope.showSeconds = showSeconds;\r\n          scope.showAM = showAM;\r\n          scope.isAM = ($timepicker.$date || hours[midIndex].date).getHours() < 12;\r\n          scope.timeSeparator = timeSeparator;\r\n          $timepicker.$isBuilt = true;\r\n        };\r\n\r\n        $timepicker.$isSelected = function (date, index) {\r\n          if (!$timepicker.$date) return false;\r\n          else if (index === 0) {\r\n            return date.getHours() === $timepicker.$date.getHours();\r\n          } else if (index === 1) {\r\n            return date.getMinutes() === $timepicker.$date.getMinutes();\r\n          } else if (index === 2) {\r\n            return date.getSeconds() === $timepicker.$date.getSeconds();\r\n          }\r\n        };\r\n\r\n        $timepicker.$isDisabled = function (date, index) {\r\n          var selectedTime;\r\n          if (index === 0) {\r\n            selectedTime = date.getTime() + viewDate.minute * 6e4 + viewDate.second * 1e3;\r\n          } else if (index === 1) {\r\n            selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.second * 1e3;\r\n          } else if (index === 2) {\r\n            selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.minute * 6e4;\r\n          }\r\n          return selectedTime < options.minTime * 1 || selectedTime > options.maxTime * 1;\r\n        };\r\n\r\n        scope.$arrowAction = function (value, index) {\r\n          if (options.arrowBehavior === 'picker') {\r\n            $timepicker.$setTimeByStep(value, index);\r\n          } else {\r\n            $timepicker.$moveIndex(value, index);\r\n          }\r\n        };\r\n\r\n        $timepicker.$setTimeByStep = function (value, index) {\r\n          var newDate = new Date($timepicker.$date || startDate);\r\n          var hours = newDate.getHours();\r\n          var minutes = newDate.getMinutes();\r\n          var seconds = newDate.getSeconds();\r\n          if (index === 0) {\r\n            newDate.setHours(hours - (parseInt(options.hourStep, 10) * value));\r\n          } else if (index === 1) {\r\n            newDate.setMinutes(minutes - (parseInt(options.minuteStep, 10) * value));\r\n          } else if (index === 2) {\r\n            newDate.setSeconds(seconds - (parseInt(options.secondStep, 10) * value));\r\n          }\r\n          $timepicker.select(newDate, index, true);\r\n        };\r\n\r\n        $timepicker.$moveIndex = function (value, index) {\r\n          var targetDate;\r\n          if (index === 0) {\r\n            targetDate = new Date(1970, 0, 1, viewDate.hour + (value * options.length), viewDate.minute, viewDate.second);\r\n            angular.extend(viewDate, {\r\n              hour: targetDate.getHours()\r\n            });\r\n          } else if (index === 1) {\r\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute + (value * options.length * options.minuteStep), viewDate.second);\r\n            angular.extend(viewDate, {\r\n              minute: targetDate.getMinutes()\r\n            });\r\n          } else if (index === 2) {\r\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute, viewDate.second + (value * options.length * options.secondStep));\r\n            angular.extend(viewDate, {\r\n              second: targetDate.getSeconds()\r\n            });\r\n          }\r\n          $timepicker.$build();\r\n        };\r\n\r\n        $timepicker.$onMouseDown = function (evt) {\r\n          // Prevent blur on mousedown on .dropdown-menu\r\n          if (evt.target.nodeName.toLowerCase() !== 'input') evt.preventDefault();\r\n          evt.stopPropagation();\r\n          // Emulate click for mobile devices\r\n          if (isTouch) {\r\n            var targetEl = angular.element(evt.target);\r\n            if (targetEl[0].nodeName.toLowerCase() !== 'button') {\r\n              targetEl = targetEl.parent();\r\n            }\r\n            targetEl.triggerHandler('click');\r\n          }\r\n        };\r\n\r\n        $timepicker.$onKeyDown = function (evt) {\r\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n\r\n          // Close on enter\r\n          if (evt.keyCode === 13) {\r\n            $timepicker.hide(true);\r\n            return;\r\n          }\r\n\r\n          // Navigate with keyboard\r\n          var newDate = new Date($timepicker.$date);\r\n          var hours = newDate.getHours();\r\n          var hoursLength = formatDate(newDate, hoursFormat).length;\r\n          var minutes = newDate.getMinutes();\r\n          var minutesLength = formatDate(newDate, minutesFormat).length;\r\n          var seconds = newDate.getSeconds();\r\n          var secondsLength = formatDate(newDate, secondsFormat).length;\r\n          var sepLength = 1;\r\n          var lateralMove = /(37|39)/.test(evt.keyCode);\r\n          var count = 2 + showSeconds * 1 + showAM * 1;\r\n\r\n          // Navigate indexes (left, right)\r\n          if (lateralMove) {\r\n            if (evt.keyCode === 37) selectedIndex = selectedIndex < 1 ? count - 1 : selectedIndex - 1;\r\n            else if (evt.keyCode === 39) selectedIndex = selectedIndex < count - 1 ? selectedIndex + 1 : 0;\r\n          }\r\n\r\n          // Update values (up, down)\r\n          var selectRange = [0, hoursLength];\r\n          var incr = 0;\r\n          if (evt.keyCode === 38) incr = -1;\r\n          if (evt.keyCode === 40) incr = +1;\r\n          var isSeconds = selectedIndex === 2 && showSeconds;\r\n          var isMeridian = selectedIndex === 2 && !showSeconds || selectedIndex === 3 && showSeconds;\r\n          if (selectedIndex === 0) {\r\n            newDate.setHours(hours + incr * parseInt(options.hourStep, 10));\r\n            // re-calculate hours length because we have changed hours value\r\n            hoursLength = formatDate(newDate, hoursFormat).length;\r\n            selectRange = [0, hoursLength];\r\n          } else if (selectedIndex === 1) {\r\n            newDate.setMinutes(minutes + incr * parseInt(options.minuteStep, 10));\r\n            // re-calculate minutes length because we have changes minutes value\r\n            minutesLength = formatDate(newDate, minutesFormat).length;\r\n            selectRange = [hoursLength + sepLength, minutesLength];\r\n          } else if (isSeconds) {\r\n            newDate.setSeconds(seconds + incr * parseInt(options.secondStep, 10));\r\n            // re-calculate seconds length because we have changes seconds value\r\n            secondsLength = formatDate(newDate, secondsFormat).length;\r\n            selectRange = [hoursLength + sepLength + minutesLength + sepLength, secondsLength];\r\n          } else if (isMeridian) {\r\n            if (!lateralMove) $timepicker.switchMeridian();\r\n            selectRange = [hoursLength + sepLength + minutesLength + sepLength + (secondsLength + sepLength) * showSeconds, 2];\r\n          }\r\n          $timepicker.select(newDate, selectedIndex, true);\r\n          createSelection(selectRange[0], selectRange[1]);\r\n          parentScope.$digest();\r\n        };\r\n\r\n        // Private\r\n\r\n        function createSelection (start, length) {\r\n          var end = start + length;\r\n          if (element[0].createTextRange) {\r\n            var selRange = element[0].createTextRange();\r\n            selRange.collapse(true);\r\n            selRange.moveStart('character', start);\r\n            selRange.moveEnd('character', end);\r\n            selRange.select();\r\n          } else if (element[0].setSelectionRange) {\r\n            element[0].setSelectionRange(start, end);\r\n          } else if (angular.isUndefined(element[0].selectionStart)) {\r\n            element[0].selectionStart = start;\r\n            element[0].selectionEnd = end;\r\n          }\r\n        }\r\n\r\n        function focusElement () {\r\n          element[0].focus();\r\n        }\r\n\r\n        // Overrides\r\n\r\n        var _init = $timepicker.init;\r\n        $timepicker.init = function () {\r\n          if (isNative && options.useNative) {\r\n            element.prop('type', 'time');\r\n            element.css('-webkit-appearance', 'textfield');\r\n            return;\r\n          } else if (isTouch) {\r\n            element.prop('type', 'text');\r\n            element.attr('readonly', 'true');\r\n            element.on('click', focusElement);\r\n          }\r\n          _init();\r\n        };\r\n\r\n        var _destroy = $timepicker.destroy;\r\n        $timepicker.destroy = function () {\r\n          if (isNative && options.useNative) {\r\n            element.off('click', focusElement);\r\n          }\r\n          _destroy();\r\n        };\r\n\r\n        var _show = $timepicker.show;\r\n        $timepicker.show = function () {\r\n          if ((!isTouch && element.attr('readonly')) || element.attr('disabled')) return;\r\n          _show();\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed imediately.\r\n          $timeout(function () {\r\n            if ($timepicker.$element) $timepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\r\n            if (options.keyboard) {\r\n              if (element) element.on('keydown', $timepicker.$onKeyDown);\r\n            }\r\n          }, 0, false);\r\n        };\r\n\r\n        var _hide = $timepicker.hide;\r\n        $timepicker.hide = function (blur) {\r\n          if (!$timepicker.$isShown) return;\r\n          if ($timepicker.$element) $timepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\r\n          if (options.keyboard) {\r\n            if (element) element.off('keydown', $timepicker.$onKeyDown);\r\n          }\r\n          _hide(blur);\r\n        };\r\n\r\n        return $timepicker;\r\n\r\n      }\r\n\r\n      timepickerFactory.defaults = defaults;\r\n      return timepickerFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n\r\n  .directive('bsTimepicker', function ($window, $parse, $q, $dateFormatter, $dateParser, $timepicker) {\r\n\r\n    var defaults = $timepicker.defaults;\r\n    var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        // Directive options\r\n        var options = {\r\n          scope: scope\r\n        };\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'autoclose', 'timeType', 'timeFormat', 'timezone', 'modelTimeFormat', 'useNative', 'hourStep', 'minuteStep', 'secondStep', 'length', 'arrowBehavior', 'iconUp', 'iconDown', 'roundDisplay', 'id', 'prefixClass', 'prefixEvent', 'defaultDate'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container', 'autoclose', 'useNative', 'roundDisplay'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\r\n            options[key] = false;\r\n          }\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Initialize timepicker\r\n        if (isNative && (options.useNative || defaults.useNative)) options.timeFormat = 'HH:mm';\r\n        var timepicker = $timepicker(element, controller, options);\r\n        options = timepicker.$options;\r\n\r\n        var lang = options.lang;\r\n        var formatDate = function (date, format, timezone) {\r\n          return $dateFormatter.formatDate(date, format, lang, timezone);\r\n        };\r\n\r\n        // Visibility binding support\r\n        if (attr.bsShow) {\r\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\r\n            if (!timepicker || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(timepicker),?/i);\r\n            if (newValue === true) {\r\n              timepicker.show();\r\n            } else {\r\n              timepicker.hide();\r\n            }\r\n          });\r\n        }\r\n\r\n        // Initialize parser\r\n        var dateParser = $dateParser({\r\n          format: options.timeFormat,\r\n          lang: lang\r\n        });\r\n\r\n        // Observe attributes for changes\r\n        angular.forEach(['minTime', 'maxTime'], function (key) {\r\n          // console.warn('attr.$observe(%s)', key, attr[key]);\r\n          if (angular.isDefined(attr[key])) {\r\n            attr.$observe(key, function (newValue) {\r\n              timepicker.$options[key] = dateParser.getTimeForAttribute(key, newValue);\r\n              if (!isNaN(timepicker.$options[key])) timepicker.$build();\r\n              validateAgainstMinMaxTime(controller.$dateValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Watch model for changes\r\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\r\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue, controller.$dateValue);\r\n          timepicker.update(controller.$dateValue);\r\n        }, true);\r\n\r\n        function validateAgainstMinMaxTime (parsedTime) {\r\n          if (!angular.isDate(parsedTime)) return;\r\n          var isMinValid = isNaN(options.minTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) >= options.minTime;\r\n          var isMaxValid = isNaN(options.maxTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) <= options.maxTime;\r\n          var isValid = isMinValid && isMaxValid;\r\n          controller.$setValidity('date', isValid);\r\n          controller.$setValidity('min', isMinValid);\r\n          controller.$setValidity('max', isMaxValid);\r\n          // Only update the model when we have a valid date\r\n          if (!isValid) {\r\n            return;\r\n          }\r\n          controller.$dateValue = parsedTime;\r\n        }\r\n\r\n        // viewValue -> $parsers -> modelValue\r\n        controller.$parsers.unshift(function (viewValue) {\r\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\r\n          var date;\r\n          // Null values should correctly reset the model value & validity\r\n          if (!viewValue) {\r\n            // BREAKING CHANGE:\r\n            // return null (not undefined) when input value is empty, so angularjs 1.3\r\n            // ngModelController can go ahead and run validators, like ngRequired\r\n            controller.$setValidity('date', true);\r\n            return null;\r\n          }\r\n          var parsedTime = angular.isDate(viewValue) ? viewValue : dateParser.parse(viewValue, controller.$dateValue);\r\n          if (!parsedTime || isNaN(parsedTime.getTime())) {\r\n            controller.$setValidity('date', false);\r\n            // Return undefined, causes ngModelController to\r\n            // invalidate model value\r\n            return undefined;\r\n          }\r\n          validateAgainstMinMaxTime(parsedTime);\r\n\r\n          if (options.timeType === 'string') {\r\n            date = dateParser.timezoneOffsetAdjust(parsedTime, options.timezone, true);\r\n            return formatDate(date, options.modelTimeFormat || options.timeFormat);\r\n          }\r\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\r\n          if (options.timeType === 'number') {\r\n            return date.getTime();\r\n          } else if (options.timeType === 'unix') {\r\n            return date.getTime() / 1000;\r\n          } else if (options.timeType === 'iso') {\r\n            return date.toISOString();\r\n          }\r\n          return new Date(date);\r\n        });\r\n\r\n        // modelValue -> $formatters -> viewValue\r\n        controller.$formatters.push(function (modelValue) {\r\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n          var date;\r\n          if (angular.isUndefined(modelValue) || modelValue === null) {\r\n            date = NaN;\r\n          } else if (angular.isDate(modelValue)) {\r\n            date = modelValue;\r\n          } else if (options.timeType === 'string') {\r\n            date = dateParser.parse(modelValue, null, options.modelTimeFormat);\r\n          } else if (options.timeType === 'unix') {\r\n            date = new Date(modelValue * 1000);\r\n          } else {\r\n            date = new Date(modelValue);\r\n          }\r\n          // Setup default value?\r\n          // if(isNaN(date.getTime())) date = new Date(new Date().setMinutes(0) + 36e5);\r\n          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\r\n          return getTimeFormattedString();\r\n        });\r\n\r\n        // viewValue -> element\r\n        controller.$render = function () {\r\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\r\n          element.val(getTimeFormattedString());\r\n        };\r\n\r\n        function getTimeFormattedString () {\r\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.timeFormat);\r\n        }\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (timepicker) timepicker.destroy();\r\n          options = null;\r\n          timepicker = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.select', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\r\n\r\n  .provider('$select', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      prefixClass: 'select',\r\n      prefixEvent: '$select',\r\n      placement: 'bottom-left',\r\n      templateUrl: 'select/select.tpl.html',\r\n      trigger: 'focus',\r\n      container: false,\r\n      keyboard: true,\r\n      html: false,\r\n      delay: 0,\r\n      multiple: false,\r\n      allNoneButtons: false,\r\n      sort: true,\r\n      caretHtml: '&nbsp;<span class=\"caret\"></span>',\r\n      placeholder: 'Choose among the following...',\r\n      allText: 'All',\r\n      noneText: 'None',\r\n      maxLength: 3,\r\n      maxLengthHtml: 'selected',\r\n      iconCheckmark: 'glyphicon glyphicon-ok',\r\n      toggle: false\r\n    };\r\n\r\n    this.$get = function ($window, $document, $rootScope, $tooltip, $timeout) {\r\n\r\n      // var bodyEl = angular.element($window.document.body);\r\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n      var isTouch = ('createTouch' in $window.document) && isNative;\r\n\r\n      function SelectFactory (element, controller, config) {\r\n\r\n        var $select = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n\r\n        $select = $tooltip(element, options);\r\n        var scope = $select.$scope;\r\n\r\n        scope.$matches = [];\r\n        if (options.multiple) {\r\n          scope.$activeIndex = [];\r\n        } else {\r\n          scope.$activeIndex = -1;\r\n        }\r\n        scope.$isMultiple = options.multiple;\r\n        scope.$showAllNoneButtons = options.allNoneButtons && options.multiple;\r\n        scope.$iconCheckmark = options.iconCheckmark;\r\n        scope.$allText = options.allText;\r\n        scope.$noneText = options.noneText;\r\n\r\n        scope.$activate = function (index) {\r\n          scope.$$postDigest(function () {\r\n            $select.activate(index);\r\n          });\r\n        };\r\n\r\n        scope.$select = function (index, evt) {\r\n          scope.$$postDigest(function () {\r\n            $select.select(index);\r\n          });\r\n        };\r\n\r\n        scope.$isVisible = function () {\r\n          return $select.$isVisible();\r\n        };\r\n\r\n        scope.$isActive = function (index) {\r\n          return $select.$isActive(index);\r\n        };\r\n\r\n        scope.$selectAll = function () {\r\n          for (var i = 0; i < scope.$matches.length; i++) {\r\n            if (!scope.$isActive(i)) {\r\n              scope.$select(i);\r\n            }\r\n          }\r\n        };\r\n\r\n        scope.$selectNone = function () {\r\n          for (var i = 0; i < scope.$matches.length; i++) {\r\n            if (scope.$isActive(i)) {\r\n              scope.$select(i);\r\n            }\r\n          }\r\n        };\r\n\r\n        // Public methods\r\n\r\n        $select.update = function (matches) {\r\n          scope.$matches = matches;\r\n          $select.$updateActiveIndex();\r\n        };\r\n\r\n        $select.activate = function (index) {\r\n          if (options.multiple) {\r\n            if ($select.$isActive(index)) {\r\n              scope.$activeIndex.splice(scope.$activeIndex.indexOf(index), 1);\r\n            } else {\r\n              scope.$activeIndex.push(index);\r\n            }\r\n            if (options.sort) scope.$activeIndex.sort(function (a, b) { return a - b; }); // use numeric sort instead of default sort\r\n          } else {\r\n            scope.$activeIndex = index;\r\n          }\r\n          return scope.$activeIndex;\r\n        };\r\n\r\n        $select.select = function (index) {\r\n          if (angular.isUndefined(index) || index < 0 || index >= scope.$matches.length) { return; }\r\n          var value = scope.$matches[index].value;\r\n          scope.$apply(function () {\r\n            $select.activate(index);\r\n            if (options.multiple) {\r\n              controller.$setViewValue(scope.$activeIndex.map(function (index) {\r\n                if (angular.isUndefined(scope.$matches[index])) {\r\n                  return null;\r\n                }\r\n                return scope.$matches[index].value;\r\n              }));\r\n            } else {\r\n              if (options.toggle) {\r\n                controller.$setViewValue((value === controller.$modelValue) ? undefined : value);\r\n              } else {\r\n                controller.$setViewValue(value);\r\n              }\r\n              // Hide if single select\r\n              $select.hide();\r\n            }\r\n          });\r\n          // Emit event\r\n          scope.$emit(options.prefixEvent + '.select', value, index, $select);\r\n          if (angular.isDefined(options.onSelect) && angular.isFunction(options.onSelect)) {\r\n            options.onSelect(value, index, $select);\r\n          }\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $select.$updateActiveIndex = function () {\r\n          if (options.multiple) {\r\n            if (angular.isArray(controller.$modelValue)) {\r\n              scope.$activeIndex = controller.$modelValue.map(function (value) {\r\n                return $select.$getIndex(value);\r\n              });\r\n            } else {\r\n              scope.$activeIndex = [];\r\n            }\r\n          } else {\r\n            if (angular.isDefined(controller.$modelValue) && scope.$matches.length) {\r\n              scope.$activeIndex = $select.$getIndex(controller.$modelValue);\r\n            } else {\r\n              scope.$activeIndex = -1;\r\n            }\r\n          }\r\n        };\r\n\r\n        $select.$isVisible = function () {\r\n          if (!options.minLength || !controller) {\r\n            return scope.$matches.length;\r\n          }\r\n          // minLength support\r\n          return scope.$matches.length && controller.$viewValue.length >= options.minLength;\r\n        };\r\n\r\n        $select.$isActive = function (index) {\r\n          if (options.multiple) {\r\n            return scope.$activeIndex.indexOf(index) !== -1;\r\n          }\r\n          return scope.$activeIndex === index;\r\n        };\r\n\r\n        $select.$getIndex = function (value) {\r\n          var index;\r\n          for (index = scope.$matches.length; index--;) {\r\n            if (angular.equals(scope.$matches[index].value, value)) break;\r\n          }\r\n          return index;\r\n        };\r\n\r\n        $select.$onMouseDown = function (evt) {\r\n          // Prevent blur on mousedown on .dropdown-menu\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n          // Emulate click for mobile devices\r\n          if (isTouch) {\r\n            var targetEl = angular.element(evt.target);\r\n            var anchor;\r\n\r\n            if (evt.target.nodeName !== 'A') {\r\n              var anchorCandidate = targetEl.parent();\r\n              while (!anchor && anchorCandidate.length > 0) {\r\n                if (anchorCandidate[0].nodeName === 'A') {\r\n                  anchor = anchorCandidate;\r\n                }\r\n                anchorCandidate = anchorCandidate.parent();\r\n              }\r\n            }\r\n\r\n            if (anchor) {\r\n              angular.element(anchor).triggerHandler('click');\r\n            } else {\r\n              targetEl.triggerHandler('click');\r\n            }\r\n          }\r\n        };\r\n\r\n        $select.$onKeyDown = function (evt) {\r\n          if (!/(9|13|38|40)/.test(evt.keyCode)) return;\r\n          // Let tab propagate\r\n          if (evt.keyCode !== 9) {\r\n            evt.preventDefault();\r\n            evt.stopPropagation();\r\n          }\r\n\r\n          // release focus on tab\r\n          if (options.multiple && evt.keyCode === 9) {\r\n            return $select.hide();\r\n          }\r\n\r\n          // Select with enter\r\n          if (!options.multiple && (evt.keyCode === 13 || evt.keyCode === 9)) {\r\n            return $select.select(scope.$activeIndex);\r\n          }\r\n\r\n          if (!options.multiple) {\r\n            // Navigate with keyboard\r\n            if (evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;\r\n            else if (evt.keyCode === 38 && scope.$activeIndex < 0) scope.$activeIndex = scope.$matches.length - 1;\r\n            else if (evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;\r\n            else if (angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;\r\n            scope.$digest();\r\n          }\r\n        };\r\n\r\n        $select.$isIE = function () {\r\n          var ua = $window.navigator.userAgent;\r\n          return ua.indexOf('MSIE ') > 0 || ua.indexOf('Trident/') > 0 || ua.indexOf('Edge/') > 0;\r\n        };\r\n\r\n        $select.$selectScrollFix = function (e) {\r\n          if ($document[0].activeElement.tagName === 'UL') {\r\n            e.preventDefault();\r\n            e.stopImmediatePropagation();\r\n            e.target.focus();\r\n          }\r\n        };\r\n\r\n        // Overrides\r\n\r\n        var _show = $select.show;\r\n        $select.show = function () {\r\n          _show();\r\n          if (options.multiple) {\r\n            $select.$element.addClass('select-multiple');\r\n          }\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed imediately.\r\n          $timeout(function () {\r\n            $select.$element.on(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\r\n            if (options.keyboard) {\r\n              element.on('keydown', $select.$onKeyDown);\r\n            }\r\n          }, 0, false);\r\n        };\r\n\r\n        var _hide = $select.hide;\r\n        $select.hide = function () {\r\n          if (!options.multiple && angular.isUndefined(controller.$modelValue)) {\r\n            scope.$activeIndex = -1;\r\n          }\r\n          $select.$element.off(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\r\n          if (options.keyboard) {\r\n            element.off('keydown', $select.$onKeyDown);\r\n          }\r\n          _hide(true);\r\n        };\r\n\r\n        return $select;\r\n\r\n      }\r\n\r\n      SelectFactory.defaults = defaults;\r\n      return SelectFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsSelect', function ($window, $parse, $q, $select, $parseOptions) {\r\n\r\n    var defaults = $select.defaults;\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        // Directive options\r\n        var options = {scope: scope, placeholder: defaults.placeholder};\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'placeholder', 'allNoneButtons', 'maxLength', 'maxLengthHtml', 'allText', 'noneText', 'iconCheckmark', 'autoClose', 'id', 'sort', 'caretHtml', 'prefixClass', 'prefixEvent', 'toggle'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container', 'allNoneButtons', 'sort'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\r\n            options[key] = false;\r\n          }\r\n        });\r\n\r\n        // bind functions from the attrs to the show, hide and select events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide', 'onSelect'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Only parse data-multiple. Angular sets existence attributes to true (multiple/required/etc), they apply this\r\n        // to data-multiple as well for some reason, so we'll parse this ourselves and disregard multiple\r\n        var dataMultiple = element.attr('data-multiple');\r\n        if (angular.isDefined(dataMultiple)) {\r\n          if (falseValueRegExp.test(dataMultiple)) {\r\n            options.multiple = false;\r\n          } else {\r\n            options.multiple = dataMultiple;\r\n          }\r\n        }\r\n\r\n        // Add support for select markup\r\n        if (element[0].nodeName.toLowerCase() === 'select') {\r\n          var inputEl = element;\r\n          inputEl.css('display', 'none');\r\n          element = angular.element('<button type=\"button\" class=\"btn btn-default\" aria-haspopup=\"true\"></button>');\r\n          inputEl.after(element);\r\n        }\r\n\r\n        // Build proper bsOptions\r\n        var parsedOptions = $parseOptions(attr.bsOptions);\r\n\r\n        // Initialize select\r\n        var select = $select(element, controller, options);\r\n\r\n        if (select.$isIE()) {\r\n          element[0].addEventListener('blur', select.$selectScrollFix);\r\n        }\r\n\r\n        // Watch bsOptions values before filtering for changes\r\n        var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').trim();\r\n        scope.$watch(watchedOptions, function (newValue, oldValue) {\r\n          // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\r\n          parsedOptions.valuesFn(scope, controller)\r\n          .then(function (values) {\r\n            select.update(values);\r\n            controller.$render();\r\n          });\r\n        }, true);\r\n\r\n        // Watch model for changes\r\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\r\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue);\r\n          select.$updateActiveIndex();\r\n          controller.$render();\r\n        }, true);\r\n\r\n        // Model rendering in view\r\n        controller.$render = function () {\r\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\r\n          var selected;\r\n          var index;\r\n          if (options.multiple && angular.isArray(controller.$modelValue)) {\r\n            selected = controller.$modelValue.map(function (value) {\r\n              index = select.$getIndex(value);\r\n              return index !== -1 ? select.$scope.$matches[index].label : false;\r\n            }).filter(angular.isDefined);\r\n            if (selected.length > (options.maxLength || defaults.maxLength)) {\r\n              selected = selected.length + ' ' + (options.maxLengthHtml || defaults.maxLengthHtml);\r\n            } else {\r\n              selected = selected.join(', ');\r\n            }\r\n          } else {\r\n            index = select.$getIndex(controller.$modelValue);\r\n            selected = index !== -1 ? select.$scope.$matches[index].label : false;\r\n          }\r\n          element.html((selected || options.placeholder) + (options.caretHtml || defaults.caretHtml));\r\n        };\r\n\r\n        if (options.multiple) {\r\n          controller.$isEmpty = function (value) {\r\n            return !value || value.length === 0;\r\n          };\r\n        }\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (select) select.destroy();\r\n          options = null;\r\n          select = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.scrollspy', ['mgcrea.ngStrap.helpers.debounce', 'mgcrea.ngStrap.helpers.dimensions'])\r\n\r\n  .provider('$scrollspy', function () {\r\n\r\n    // Pool of registered spies\r\n    var spies = this.$$spies = {};\r\n\r\n    var defaults = this.defaults = {\r\n      debounce: 150,\r\n      throttle: 100,\r\n      offset: 100\r\n    };\r\n\r\n    this.$get = function ($window, $document, $rootScope, dimensions, debounce, throttle) {\r\n\r\n      var windowEl = angular.element($window);\r\n      var docEl = angular.element($document.prop('documentElement'));\r\n      var bodyEl = angular.element($window.document.body);\r\n\r\n      // Helper functions\r\n\r\n      function nodeName (element, name) {\r\n        return element[0].nodeName && element[0].nodeName.toLowerCase() === name.toLowerCase();\r\n      }\r\n\r\n      function ScrollSpyFactory (config) {\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n        if (!options.element) options.element = bodyEl;\r\n        var isWindowSpy = nodeName(options.element, 'body');\r\n        var scrollEl = isWindowSpy ? windowEl : options.element;\r\n        var scrollId = isWindowSpy ? 'window' : options.id;\r\n\r\n        // Use existing spy\r\n        if (spies[scrollId]) {\r\n          spies[scrollId].$$count++;\r\n          return spies[scrollId];\r\n        }\r\n\r\n        var $scrollspy = {};\r\n\r\n        // Private vars\r\n        var unbindViewContentLoaded;\r\n        var unbindIncludeContentLoaded;\r\n        var trackedElements = $scrollspy.$trackedElements = [];\r\n        var sortedElements = [];\r\n        var activeTarget;\r\n        var debouncedCheckPosition;\r\n        var throttledCheckPosition;\r\n        var debouncedCheckOffsets;\r\n        /* eslint-disable no-unused-vars */\r\n        var viewportHeight;\r\n        /* eslint-enable no-unused-vars */\r\n        var scrollTop;\r\n\r\n        $scrollspy.init = function () {\r\n\r\n          // Setup internal ref counter\r\n          this.$$count = 1;\r\n\r\n          // Bind events\r\n          debouncedCheckPosition = debounce(this.checkPosition, options.debounce);\r\n          throttledCheckPosition = throttle(this.checkPosition, options.throttle);\r\n          scrollEl.on('click', this.checkPositionWithEventLoop);\r\n          windowEl.on('resize', debouncedCheckPosition);\r\n          scrollEl.on('scroll', throttledCheckPosition);\r\n\r\n          debouncedCheckOffsets = debounce(this.checkOffsets, options.debounce);\r\n          unbindViewContentLoaded = $rootScope.$on('$viewContentLoaded', debouncedCheckOffsets);\r\n          unbindIncludeContentLoaded = $rootScope.$on('$includeContentLoaded', debouncedCheckOffsets);\r\n          debouncedCheckOffsets();\r\n\r\n          // Register spy for reuse\r\n          if (scrollId) {\r\n            spies[scrollId] = $scrollspy;\r\n          }\r\n\r\n        };\r\n\r\n        $scrollspy.destroy = function () {\r\n\r\n          // Check internal ref counter\r\n          this.$$count--;\r\n          if (this.$$count > 0) {\r\n            return;\r\n          }\r\n\r\n          // Unbind events\r\n          scrollEl.off('click', this.checkPositionWithEventLoop);\r\n          windowEl.off('resize', debouncedCheckPosition);\r\n          scrollEl.off('scroll', throttledCheckPosition);\r\n          unbindViewContentLoaded();\r\n          unbindIncludeContentLoaded();\r\n          if (scrollId) {\r\n            delete spies[scrollId];\r\n          }\r\n        };\r\n\r\n        $scrollspy.checkPosition = function () {\r\n\r\n          // Not ready yet\r\n          if (!sortedElements.length) return;\r\n\r\n          // Calculate the scroll position\r\n          scrollTop = (isWindowSpy ? $window.pageYOffset : scrollEl.prop('scrollTop')) || 0;\r\n\r\n          // Calculate the viewport height for use by the components\r\n          viewportHeight = Math.max($window.innerHeight, docEl.prop('clientHeight'));\r\n\r\n          // Activate first element if scroll is smaller\r\n          if (scrollTop < sortedElements[0].offsetTop && activeTarget !== sortedElements[0].target) {\r\n            return $scrollspy.$activateElement(sortedElements[0]);\r\n          }\r\n\r\n          // Activate proper element\r\n          for (var i = sortedElements.length; i--;) {\r\n            if (angular.isUndefined(sortedElements[i].offsetTop) || sortedElements[i].offsetTop === null) continue;\r\n            if (activeTarget === sortedElements[i].target) continue;\r\n            if (scrollTop < sortedElements[i].offsetTop) continue;\r\n            if (sortedElements[i + 1] && scrollTop > sortedElements[i + 1].offsetTop) continue;\r\n            return $scrollspy.$activateElement(sortedElements[i]);\r\n          }\r\n\r\n        };\r\n\r\n        $scrollspy.checkPositionWithEventLoop = function () {\r\n          // IE 9 throws an error if we use 'this' instead of '$scrollspy'\r\n          // in this setTimeout call\r\n          setTimeout($scrollspy.checkPosition, 1);\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $scrollspy.$activateElement = function (element) {\r\n          if (activeTarget) {\r\n            var activeElement = $scrollspy.$getTrackedElement(activeTarget);\r\n            if (activeElement) {\r\n              activeElement.source.removeClass('active');\r\n              if (nodeName(activeElement.source, 'li') && nodeName(activeElement.source.parent().parent(), 'li')) {\r\n                activeElement.source.parent().parent().removeClass('active');\r\n              }\r\n            }\r\n          }\r\n          activeTarget = element.target;\r\n          element.source.addClass('active');\r\n          if (nodeName(element.source, 'li') && nodeName(element.source.parent().parent(), 'li')) {\r\n            element.source.parent().parent().addClass('active');\r\n          }\r\n        };\r\n\r\n        $scrollspy.$getTrackedElement = function (target) {\r\n          return trackedElements.filter(function (obj) {\r\n            return obj.target === target;\r\n          })[0];\r\n        };\r\n\r\n        // Track offsets behavior\r\n\r\n        $scrollspy.checkOffsets = function () {\r\n\r\n          angular.forEach(trackedElements, function (trackedElement) {\r\n            var targetElement = document.querySelector(trackedElement.target);\r\n            trackedElement.offsetTop = targetElement ? dimensions.offset(targetElement).top : null;\r\n            if (options.offset && trackedElement.offsetTop !== null) trackedElement.offsetTop -= options.offset * 1;\r\n          });\r\n\r\n          sortedElements = trackedElements\r\n          .filter(function (el) {\r\n            return el.offsetTop !== null;\r\n          })\r\n          .sort(function (a, b) {\r\n            return a.offsetTop - b.offsetTop;\r\n          });\r\n\r\n          debouncedCheckPosition();\r\n\r\n        };\r\n\r\n        $scrollspy.trackElement = function (target, source) {\r\n          trackedElements.push({target: target, source: source});\r\n        };\r\n\r\n        $scrollspy.untrackElement = function (target, source) {\r\n          var toDelete;\r\n          for (var i = trackedElements.length; i--;) {\r\n            if (trackedElements[i].target === target && trackedElements[i].source === source) {\r\n              toDelete = i;\r\n              break;\r\n            }\r\n          }\r\n          trackedElements.splice(toDelete, 1);\r\n        };\r\n\r\n        $scrollspy.activate = function (i) {\r\n          trackedElements[i].addClass('active');\r\n        };\r\n\r\n        // Initialize plugin\r\n\r\n        $scrollspy.init();\r\n        return $scrollspy;\r\n\r\n      }\r\n\r\n      return ScrollSpyFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsScrollspy', function ($rootScope, debounce, dimensions, $scrollspy) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      link: function postLink (scope, element, attr) {\r\n\r\n        var options = {scope: scope};\r\n        angular.forEach(['offset', 'target'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        var scrollspy = $scrollspy(options);\r\n        scrollspy.trackElement(options.target, element);\r\n\r\n        scope.$on('$destroy', function () {\r\n          if (scrollspy) {\r\n            scrollspy.untrackElement(options.target, element);\r\n            scrollspy.destroy();\r\n          }\r\n          options = null;\r\n          scrollspy = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n\r\n  .directive('bsScrollspyList', function ($rootScope, debounce, dimensions, $scrollspy) {\r\n\r\n    return {\r\n      restrict: 'A',\r\n      compile: function postLink (element, attr) {\r\n        var children = element[0].querySelectorAll('li > a[href]');\r\n        angular.forEach(children, function (child) {\r\n          var childEl = angular.element(child);\r\n          childEl.parent().attr('bs-scrollspy', '').attr('data-target', childEl.attr('href'));\r\n        });\r\n      }\r\n\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.popover', ['mgcrea.ngStrap.tooltip'])\r\n\r\n  .provider('$popover', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      customClass: '',\r\n      // uncommenting the next two lines will break backwards compatability\r\n      // prefixClass: 'popover',\r\n      // prefixEvent: 'popover',\r\n      container: false,\r\n      target: false,\r\n      placement: 'right',\r\n      templateUrl: 'popover/popover.tpl.html',\r\n      contentTemplate: false,\r\n      trigger: 'click',\r\n      keyboard: true,\r\n      html: false,\r\n      title: '',\r\n      content: '',\r\n      delay: 0,\r\n      autoClose: false\r\n    };\r\n\r\n    this.$get = function ($tooltip) {\r\n\r\n      function PopoverFactory (element, config) {\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n\r\n        var $popover = $tooltip(element, options);\r\n\r\n        // Support scope as string options [/*title, */content]\r\n        if (options.content) {\r\n          $popover.$scope.content = options.content;\r\n        }\r\n\r\n        return $popover;\r\n\r\n      }\r\n\r\n      return PopoverFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsPopover', function ($window, $sce, $popover) {\r\n\r\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink (scope, element, attr) {\r\n\r\n        var popover;\r\n        // Directive options\r\n        var options = {scope: scope};\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'customClass', 'autoClose', 'id', 'prefixClass', 'prefixEvent', 'bsEnabled'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container', 'autoClose'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // should not parse target attribute (anchor tag), only data-target #1454\r\n        var dataTarget = element.attr('data-target');\r\n        if (angular.isDefined(dataTarget)) {\r\n          if (falseValueRegExp.test(dataTarget)) {\r\n            options.target = false;\r\n          } else {\r\n            options.target = dataTarget;\r\n          }\r\n        }\r\n\r\n        // Support scope as data-attrs\r\n        angular.forEach(['title', 'content'], function (key) {\r\n          if (attr[key]) {\r\n            attr.$observe(key, function (newValue, oldValue) {\r\n              scope[key] = $sce.trustAsHtml(newValue);\r\n              if (angular.isDefined(oldValue)) {\r\n                requestAnimationFrame(function () {\r\n                  if (popover) popover.$applyPlacement();\r\n                });\r\n              }\r\n            });\r\n          }\r\n        });\r\n\r\n        // Support scope as an object\r\n        if (attr.bsPopover) {\r\n          scope.$watch(attr.bsPopover, function (newValue, oldValue) {\r\n            if (angular.isObject(newValue)) {\r\n              angular.extend(scope, newValue);\r\n            } else {\r\n              scope.content = newValue;\r\n            }\r\n            if (angular.isDefined(oldValue)) {\r\n              requestAnimationFrame(function () {\r\n                if (popover) popover.$applyPlacement();\r\n              });\r\n            }\r\n          }, true);\r\n        }\r\n\r\n        // Visibility binding support\r\n        if (attr.bsShow) {\r\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\r\n            if (!popover || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(popover),?/i);\r\n            if (newValue === true) {\r\n              popover.show();\r\n            } else {\r\n              popover.hide();\r\n            }\r\n          });\r\n        }\r\n\r\n        // Enabled binding support\r\n        if (attr.bsEnabled) {\r\n          scope.$watch(attr.bsEnabled, function (newValue) {\r\n            if (!popover || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(popover),?/i);\r\n            if (newValue === false) {\r\n              popover.setEnabled(false);\r\n            } else {\r\n              popover.setEnabled(true);\r\n            }\r\n          });\r\n        }\r\n\r\n        // Viewport support\r\n        if (attr.viewport) {\r\n          scope.$watch(attr.viewport, function (newValue) {\r\n            if (!popover || !angular.isDefined(newValue)) return;\r\n            popover.setViewport(newValue);\r\n          });\r\n        }\r\n\r\n        // Initialize popover\r\n        popover = $popover(element, options);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (popover) popover.destroy();\r\n          options = null;\r\n          popover = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.navbar', [])\r\n\r\n  .provider('$navbar', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      activeClass: 'active',\r\n      routeAttr: 'data-match-route',\r\n      strict: false\r\n    };\r\n\r\n    this.$get = function () {\r\n      return {defaults: defaults};\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsNavbar', function ($window, $location, $navbar) {\r\n\r\n    var defaults = $navbar.defaults;\r\n\r\n    return {\r\n      restrict: 'A',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        // Directive options\r\n        var options = angular.copy(defaults);\r\n        angular.forEach(Object.keys(defaults), function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // Watch for the $location\r\n        scope.$watch(function () {\r\n\r\n          return $location.path();\r\n\r\n        }, function (newValue, oldValue) {\r\n\r\n          var liElements = element[0].querySelectorAll('li[' + options.routeAttr + ']');\r\n\r\n          angular.forEach(liElements, function (li) {\r\n\r\n            var liElement = angular.element(li);\r\n            var pattern = liElement.attr(options.routeAttr).replace('/', '\\\\/');\r\n            if (options.strict) {\r\n              pattern = '^' + pattern + '$';\r\n            }\r\n            var regexp = new RegExp(pattern, 'i');\r\n\r\n            if (regexp.test(newValue)) {\r\n              liElement.addClass(options.activeClass);\r\n            } else {\r\n              liElement.removeClass(options.activeClass);\r\n            }\r\n\r\n          });\r\n\r\n        });\r\n\r\n      }\r\n\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.modal', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\r\n\r\n  .provider('$modal', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      backdropAnimation: 'am-fade',\r\n      customClass: '',\r\n      prefixClass: 'modal',\r\n      prefixEvent: 'modal',\r\n      placement: 'top',\r\n      templateUrl: 'modal/modal.tpl.html',\r\n      template: '',\r\n      contentTemplate: false,\r\n      container: false,\r\n      element: null,\r\n      backdrop: true,\r\n      keyboard: true,\r\n      html: false,\r\n      show: true,\r\n      size: null,\r\n      zIndex: null,\r\n      containerElement: null\r\n    };\r\n\r\n    this.$get = function ($window, $rootScope, $bsCompiler, $animate, $timeout, $sce, dimensions) {\r\n\r\n      var forEach = angular.forEach;\r\n      var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\r\n      var bodyElement = angular.element($window.document.body);\r\n\r\n      var defaultContainerElement = \"#layoutContainer\";\r\n\r\n      var layoutHideElement = angular.element(defaultContainerElement);\r\n\r\n      var backdropCount = 0;\r\n      var dialogBaseZindex = 1050;\r\n      var backdropBaseZindex = 1040;\r\n\r\n      var validSizes = {\r\n        lg: 'modal-lg',\r\n        sm: 'modal-sm'\r\n      };\r\n\r\n      function ModalFactory(config) {\r\n\r\n        var $modal = {};\r\n\r\n        // Common vars\r\n        var options = $modal.$options = angular.extend({}, defaults, config);\r\n\r\n        var promise = $modal.$promise = $bsCompiler.compile(options);\r\n        var scope = $modal.$scope = options.scope && options.scope.$new() || $rootScope.$new();\r\n\r\n        if (options.containerElement) {\r\n          layoutHideElement = angular.element(options.containerElement);\r\n        }\r\n        if (!options.element && !options.container) {\r\n          options.container = 'body';\r\n        }\r\n\r\n        if (options.zIndex) {\r\n          dialogBaseZindex = parseInt(options.zIndex, 10);\r\n          backdropBaseZindex = dialogBaseZindex - 10;\r\n        }\r\n\r\n        // Store $id to identify the triggering element in events\r\n        // give priority to options.id, otherwise, try to use\r\n        // element id if defined\r\n        $modal.$id = options.id || options.element && options.element.attr('id') || '';\r\n\r\n        $modal.returnFocus = function () {\r\n\r\n        };\r\n\r\n        // Support scope as string options\r\n        forEach(['title', 'content'], function (key) {\r\n          if (options[key]) scope[key] = $sce.trustAsHtml(options[key]);\r\n        });\r\n\r\n        // Provide scope helpers\r\n        scope.$hide = function () {\r\n          scope.$$postDigest(function () {\r\n            $modal.hide();\r\n          });\r\n        };\r\n        scope.$show = function () {\r\n          scope.$$postDigest(function () {\r\n            $modal.show();\r\n          });\r\n        };\r\n        scope.$toggle = function () {\r\n          scope.$$postDigest(function () {\r\n            $modal.toggle();\r\n          });\r\n        };\r\n        // Publish isShown as a protected var on scope\r\n        $modal.$isShown = scope.$isShown = false;\r\n\r\n        // Fetch, compile then initialize modal\r\n        var compileData;\r\n        var modalElement;\r\n        var modalScope;\r\n        var backdropElement = angular.element('<div class=\"' + options.prefixClass + '-backdrop\"/>');\r\n        backdropElement.css({ position: 'fixed', top: '0px', left: '0px', bottom: '0px', right: '0px' });\r\n        promise.then(function (data) {\r\n          compileData = data;\r\n          $modal.init();\r\n        });\r\n\r\n        $modal.init = function () {\r\n\r\n          // Options: show\r\n          if (options.show) {\r\n            scope.$$postDigest(function () {\r\n              $modal.show();\r\n            });\r\n          }\r\n\r\n        };\r\n\r\n        $modal.destroy = function () {\r\n\r\n          // Remove element\r\n          destroyModalElement();\r\n\r\n          // remove backdrop element\r\n          if (backdropElement) {\r\n            backdropElement.remove();\r\n            backdropElement = null;\r\n          }\r\n\r\n          // Destroy scope\r\n          scope.$destroy();\r\n        };\r\n\r\n        $modal.show = function () {\r\n          if ($modal.$isShown) return;\r\n\r\n          var parent;\r\n          var after;\r\n          if (angular.isElement(options.container)) {\r\n            parent = options.container;\r\n            after = options.container[0].lastChild ? angular.element(options.container[0].lastChild) : null;\r\n          } else {\r\n            if (options.container) {\r\n              parent = findElement(options.container);\r\n              after = parent[0] && parent[0].lastChild ? angular.element(parent[0].lastChild) : null;\r\n            } else {\r\n              parent = null;\r\n              after = options.element;\r\n            }\r\n          }\r\n\r\n          // destroy any existing modal elements\r\n          if (modalElement) destroyModalElement();\r\n\r\n          // create a new scope, so we can destroy it and all child scopes\r\n          // when destroying the modal element\r\n          modalScope = $modal.$scope.$new();\r\n          // Fetch a cloned element linked from template (noop callback is required)\r\n          modalElement = $modal.$element = compileData.link(modalScope, function (clonedElement, scope) { });\r\n\r\n          if (options.backdrop) {\r\n            // set z-index\r\n            modalElement.css({ 'z-index': dialogBaseZindex + (backdropCount * 20) });\r\n            backdropElement.css({ 'z-index': backdropBaseZindex + (backdropCount * 20) });\r\n\r\n            // increment number of backdrops\r\n            backdropCount++;\r\n          }\r\n\r\n          if (scope.$emit(options.prefixEvent + '.show.before', $modal).defaultPrevented) {\r\n            return;\r\n          }\r\n          if (angular.isDefined(options.onBeforeShow) && angular.isFunction(options.onBeforeShow)) {\r\n            options.onBeforeShow($modal);\r\n          }\r\n\r\n          // Set the initial positioning.\r\n          modalElement.css({ display: 'block' }).addClass(options.placement);\r\n\r\n          // Options: customClass\r\n          if (options.customClass) {\r\n            modalElement.addClass(options.customClass);\r\n          }\r\n\r\n          // Options: size\r\n          if (options.size && validSizes[options.size]) {\r\n            angular.element(findElement('.modal-dialog', modalElement[0])).addClass(validSizes[options.size]);\r\n          }\r\n\r\n          // Options: animation\r\n          if (options.animation) {\r\n            if (options.backdrop) {\r\n              backdropElement.addClass(options.backdropAnimation);\r\n            }\r\n            modalElement.addClass(options.animation);\r\n          }\r\n\r\n          if (options.backdrop) {\r\n            $animate.enter(backdropElement, bodyElement, null);\r\n          }\r\n\r\n          // Support v1.2+ $animate\r\n          // https://github.com/angular/angular.js/issues/11713\r\n          if (angular.version.minor <= 2) {\r\n            $animate.enter(modalElement, parent, after, enterAnimateCallback);\r\n          } else {\r\n            $animate.enter(modalElement, parent, after).then(enterAnimateCallback);\r\n          }\r\n\r\n          $modal.$isShown = scope.$isShown = true;\r\n          safeDigest(scope);\r\n          // Focus once the enter-animation has started\r\n          // Weird PhantomJS bug hack\r\n          var el = modalElement[0];\r\n          requestAnimationFrame(function () {\r\n            el.focus();\r\n          });\r\n\r\n          bodyElement.addClass(options.prefixClass + '-open');\r\n\r\n          layoutHideElement.attr('aria-hidden', 'true');\r\n\r\n          if (options.animation) {\r\n            bodyElement.addClass(options.prefixClass + '-with-' + options.animation);\r\n          }\r\n\r\n          // Bind events\r\n          bindBackdropEvents();\r\n          bindKeyboardEvents();\r\n        };\r\n\r\n        function enterAnimateCallback() {\r\n          scope.$emit(options.prefixEvent + '.show', $modal);\r\n          if (angular.isDefined(options.onShow) && angular.isFunction(options.onShow)) {\r\n            options.onShow($modal);\r\n          }\r\n\r\n          modalElement.attr('aria-hidden', 'false');\r\n\r\n\t\t  var focusableElement = angular.element(findElement('.modal'));\r\n\t\t  \r\n\t\t  if (focusableElement.length > 0)\r\n\t\t  {\r\n\t\t\tfocusableElement.attr('tabindex', '0');\r\n            setTimeout(function () {\r\n              focusableElement.focus();\r\n            }, 500);\r\n\t\t  }\r\n        }\r\n\r\n        $modal.hide = function () {\r\n          if (!$modal.$isShown) return;\r\n\r\n          if (scope.$emit(options.prefixEvent + '.hide.before', $modal).defaultPrevented) {\r\n            return;\r\n          }\r\n          if (angular.isDefined(options.onBeforeHide) && angular.isFunction(options.onBeforeHide)) {\r\n            options.onBeforeHide($modal);\r\n          }\r\n\r\n          modalElement.attr('aria-hidden', 'true');\r\n\r\n          if ($modal.returnFocus && typeof $modal.returnFocus === 'function') $modal.returnFocus();\r\n\r\n          // Support v1.2+ $animate\r\n          // https://github.com/angular/angular.js/issues/11713\r\n          if (angular.version.minor <= 2) {\r\n            $animate.leave(modalElement, leaveAnimateCallback);\r\n          } else {\r\n            $animate.leave(modalElement).then(leaveAnimateCallback);\r\n          }\r\n\r\n          if (options.backdrop) {\r\n            // decrement number of backdrops\r\n            backdropCount--;\r\n            $animate.leave(backdropElement);\r\n          }\r\n          $modal.$isShown = scope.$isShown = false;\r\n          safeDigest(scope);\r\n\r\n          // Unbind events\r\n          unbindBackdropEvents();\r\n          unbindKeyboardEvents();\r\n        };\r\n\r\n        function leaveAnimateCallback() {\r\n          scope.$emit(options.prefixEvent + '.hide', $modal);\r\n          if (angular.isDefined(options.onHide) && angular.isFunction(options.onHide)) {\r\n            options.onHide($modal);\r\n          }\r\n          if (findElement('.modal').length <= 0) {\r\n            bodyElement.removeClass(options.prefixClass + '-open');\r\n            layoutHideElement.attr('aria-hidden', 'false');\r\n          }\r\n          if (options.animation) {\r\n            bodyElement.removeClass(options.prefixClass + '-with-' + options.animation);\r\n          }\r\n        }\r\n\r\n        function findFocusableElements() {\r\n          // Add all elements we want to include in our selection\r\n          var focusableElements = 'a:not([disabled]), button:not([disabled]), input:not([disabled]), [tabindex]:not([disabled]):not([tabindex=\"-1\"])';\r\n          if (document.activeElement) {\r\n            var focusable = Array.prototype.filter.call(modalElement[0].querySelectorAll(focusableElements),\r\n              function (element) {\r\n                // Check for visibility while always include the current activeElement\r\n                return element.offsetWidth > 0 || element.offsetHeight > 0 || element === document.activeElement;\r\n              });\r\n\r\n            return focusable;\r\n          }\r\n        }\r\n\r\n        function findNextFocusableElement(inReverse) {\r\n          if (document.activeElement) {\r\n            var focusable = findFocusableElements();\r\n            if (focusable === undefined) return;\r\n            if (inReverse) {\r\n              focusable = Array.prototype.reverse.call(focusable);\r\n            }\r\n\r\n            var index = focusable.indexOf(document.activeElement);\r\n            return focusable[index + 1];\r\n          }\r\n        }\r\n\r\n        $modal.toggle = function () {\r\n          if ($modal.$isShown) {\r\n            $modal.hide();\r\n          } else {\r\n            $modal.show();\r\n          }\r\n        };\r\n\r\n        $modal.focus = function () {\r\n          modalElement[0].focus();\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $modal.$onKeyUp = function (evt) {\r\n\r\n          // Escape was pressed on an open modal. Hide it.\r\n          if (evt.which === 27 && $modal.$isShown) {\r\n            $modal.hide();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        $modal.$onKeyDown = function (evt) {\r\n          if (options.keyboard) {\r\n            if (evt.keyCode === 9) {\r\n\r\n              var nextFocusable = findNextFocusableElement(evt.shiftKey);\r\n              if (nextFocusable === undefined) {\r\n                if (evt.preventDefault) evt.preventDefault();\r\n                if (evt.stopPropagation) evt.stopPropagation();\r\n\r\n                var focusable = findFocusableElements();\r\n                if (evt.shiftKey) {\r\n                  focusable[focusable.length - 1].focus();\r\n                } else {\r\n                  focusable[0].focus();\r\n                }\r\n              }\r\n            }\r\n          }\r\n        };\r\n\r\n        function bindBackdropEvents() {\r\n          if (options.backdrop) {\r\n            modalElement.on('click', hideOnBackdropClick);\r\n            backdropElement.on('click', hideOnBackdropClick);\r\n            backdropElement.on('wheel', preventEventDefault);\r\n          }\r\n        }\r\n\r\n        function unbindBackdropEvents() {\r\n          if (options.backdrop) {\r\n            modalElement.off('click', hideOnBackdropClick);\r\n            backdropElement.off('click', hideOnBackdropClick);\r\n            backdropElement.off('wheel', preventEventDefault);\r\n          }\r\n        }\r\n\r\n        function bindKeyboardEvents() {\r\n          if (options.keyboard) {\r\n            modalElement.on('keyup', $modal.$onKeyUp);\r\n            modalElement.on('keydown', $modal.$onKeyDown);\r\n          }\r\n        }\r\n\r\n        function unbindKeyboardEvents() {\r\n          if (options.keyboard) {\r\n            modalElement.off('keyup', $modal.$onKeyUp);\r\n            modalElement.off('keydown', $modal.$onKeyDown);\r\n          }\r\n        }\r\n\r\n        // Private helpers\r\n\r\n        function hideOnBackdropClick(evt) {\r\n          if (evt.target !== evt.currentTarget) return;\r\n          if (options.backdrop === 'static') {\r\n            $modal.focus();\r\n          } else {\r\n            $modal.hide();\r\n          }\r\n        }\r\n\r\n        function preventEventDefault(evt) {\r\n          evt.preventDefault();\r\n        }\r\n\r\n        function destroyModalElement() {\r\n          if ($modal.$isShown && modalElement !== null) {\r\n            // un-bind events\r\n            unbindBackdropEvents();\r\n            unbindKeyboardEvents();\r\n          }\r\n\r\n          if (modalScope) {\r\n            modalScope.$destroy();\r\n            modalScope = null;\r\n          }\r\n\r\n          if (modalElement) {\r\n            modalElement.remove();\r\n            modalElement = $modal.$element = null;\r\n          }\r\n        }\r\n\r\n        return $modal;\r\n\r\n      }\r\n\r\n      // Helper functions\r\n\r\n      function safeDigest(scope) {\r\n        /* eslint-disable no-unused-expressions */\r\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\r\n        /* eslint-enable no-unused-expressions */\r\n      }\r\n\r\n      function findElement(query, element) {\r\n        return angular.element((element || document).querySelectorAll(query));\r\n      }\r\n\r\n      return ModalFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsModal', function ($window, $sce, $parse, $modal) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink(scope, element, attr, transclusion) {\r\n\r\n        // Directive options\r\n        var options = { scope: scope, element: element, show: false };\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation', 'backdropAnimation', 'id', 'prefixEvent', 'prefixClass', 'customClass', 'modalClass', 'size', 'zIndex'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // Options: alias modalClass to customClass\r\n        if (options.modalClass) {\r\n          options.customClass = options.modalClass;\r\n        }\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['backdrop', 'keyboard', 'html', 'container'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Support scope as data-attrs\r\n        angular.forEach(['title', 'content'], function (key) {\r\n          if (attr[key]) {\r\n            attr.$observe(key, function (newValue, oldValue) {\r\n              scope[key] = $sce.trustAsHtml(newValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Support scope as an object\r\n        if (attr.bsModal) {\r\n          scope.$watch(attr.bsModal, function (newValue, oldValue) {\r\n            if (angular.isObject(newValue)) {\r\n              angular.extend(scope, newValue);\r\n            } else {\r\n              scope.content = newValue;\r\n            }\r\n          }, true);\r\n        }\r\n\r\n        // Initialize modal\r\n        var modal = $modal(options);\r\n\r\n        if (options.keyboard) {\r\n          modal.returnFocus = function () {\r\n            element[0].focus();\r\n          };\r\n        }\r\n\r\n        // Trigger\r\n        element.on(attr.trigger || 'click', modal.toggle);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (modal) modal.destroy();\r\n          options = null;\r\n          modal = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.dropdown', ['mgcrea.ngStrap.tooltip'])\r\n\r\n  .provider('$dropdown', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      prefixClass: 'dropdown',\r\n      prefixEvent: 'dropdown',\r\n      placement: 'bottom-left',\r\n      templateUrl: 'dropdown/dropdown.tpl.html',\r\n      trigger: 'click',\r\n      container: false,\r\n      keyboard: true,\r\n      html: false,\r\n      delay: 0\r\n    };\r\n\r\n    this.$get = function ($window, $rootScope, $tooltip, $timeout) {\r\n\r\n      var bodyEl = angular.element($window.document.body);\r\n      var matchesSelector = Element.prototype.matchesSelector || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector;\r\n\r\n      function DropdownFactory (element, config) {\r\n\r\n        var $dropdown = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n        /* var scope = */\r\n        $dropdown.$scope = options.scope && options.scope.$new() || $rootScope.$new();\r\n\r\n        $dropdown = $tooltip(element, options);\r\n        var parentEl = element.parent();\r\n\r\n        if (element && element[0] && element[0].tagName.toUpperCase() === 'BUTTON') {\r\n          element.attr('aria-haspopup', 'true');\r\n          element.attr('data-toggle', 'dropdown');\r\n          element.attr('aria-expanded', 'false');\r\n          element.attr('role', 'button');\r\n        }\r\n\r\n        // Protected methods\r\n\r\n        $dropdown.$onKeyDown = function (evt) {\r\n          if ((/(9)/.test(evt.keyCode) && !options.keyboard) || /27/.test(evt.keyCode)) {\r\n            $dropdown.hide(/27/.test(evt.keyCode));\r\n            return;\r\n          }\r\n          if (!/(38|40)/.test(evt.keyCode)) return;\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n\r\n          // Retrieve focused index\r\n          var items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider) a'));\r\n          if (!items.length) return;\r\n          var index;\r\n          angular.forEach(items, function (el, i) {\r\n            if (matchesSelector && matchesSelector.call(el, ':focus')) index = i;\r\n          });\r\n\r\n          // Navigate with keyboard\r\n          if (evt.keyCode === 38 && index > 0) index--;\r\n          else if (evt.keyCode === 40 && index < items.length - 1) index++;\r\n          else if (angular.isUndefined(index)) index = 0;\r\n          items.eq(index)[0].focus();\r\n\r\n        };\r\n\r\n        $dropdown.$onFocusOut = function (evt) {\r\n          // find out if the related target's parents contain the datepicker's $element\r\n          var inMenu = false;\r\n          var parent = angular.element(evt.relatedTarget);\r\n          while (parent !== undefined && parent.length && parent[0] !== $window.document.body) {\r\n            parent = parent.parent();\r\n            if (parent !== undefined && parent[0] === $dropdown.$element[0]) {\r\n              inMenu = true;\r\n              break;\r\n            } else {\r\n              inMenu = false;\r\n            }\r\n          }\r\n\r\n          if (!inMenu) {\r\n            $dropdown.hide();\r\n          } else {\r\n            evt.preventDefault();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        // Overrides\r\n\r\n        var show = $dropdown.show;\r\n        $dropdown.show = function () {\r\n          show();\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed imediately.\r\n          $timeout(function () {\r\n            // Set assistive technology properties\r\n            element.attr('aria-expanded', 'true');\r\n            if ($dropdown.$element) {\r\n              $dropdown.$element.attr('aria-hidden', 'false');\r\n              $dropdown.$element.attr('role', 'menu');\r\n              $dropdown.$element.attr('tabindex', '-1');\r\n            }\r\n            if (options.keyboard && $dropdown.$element) {\r\n              $dropdown.$element.on('keydown', $dropdown.$onKeyDown);\r\n              $dropdown.$element.on('focusout', $dropdown.$onFocusOut);\r\n            }\r\n\r\n            bodyEl.on('click', onBodyClick);\r\n\r\n            if ($dropdown.$element) {\r\n              var items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider)'));\r\n              items.attr('role', 'presentation');\r\n\r\n              angular.element($dropdown.$element[0].querySelectorAll('li.divider')).attr('role', 'seperator');\r\n\r\n              items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider) a'));\r\n              items.attr('role', 'menuitem');\r\n              if (items.length && options.keyboard) {\r\n                items[0].focus();\r\n              }\r\n            }\r\n          }, 0, false);\r\n          if (parentEl.hasClass('dropdown')) parentEl.addClass('open');\r\n        };\r\n\r\n        var hide = $dropdown.hide;\r\n                $dropdown.hide = function (returnFocus) {\r\n          if (!$dropdown.$isShown) return;\r\n\r\n          element.attr('aria-expanded', 'true');\r\n          $dropdown.$element.attr('aria-hidden', 'true');\r\n\r\n          if (options.keyboard && $dropdown.$element) {\r\n            $dropdown.$element.off('keydown', $dropdown.$onKeyDown);\r\n            $dropdown.$element.off('focusout', $dropdown.$onFocusOut);\r\n          }\r\n\r\n          bodyEl.off('click', onBodyClick);\r\n          if (parentEl.hasClass('dropdown')) parentEl.removeClass('open');\r\n          $timeout(function () {\r\n            hide();\r\n            if (returnFocus) {\r\n              $timeout(function () {\r\n                if (element && element[0]) {\r\n                  element[0].focus();\r\n                }\r\n              }, 0, false);\r\n            }\r\n          }, 200);\r\n        };\r\n\r\n        var destroy = $dropdown.destroy;\r\n        $dropdown.destroy = function () {\r\n          bodyEl.off('click', onBodyClick);\r\n          destroy();\r\n        };\r\n\r\n        // Private functions\r\n\r\n        function onBodyClick (evt) {\r\n          if (evt.target === element[0]) return;\r\n          return evt.target !== element[0] && $dropdown.hide();\r\n        }\r\n\r\n        return $dropdown;\r\n\r\n      }\r\n\r\n      return DropdownFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsDropdown', function ($window, $sce, $dropdown) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      compile: function (tElement, tAttrs) {\r\n\r\n        // Support for inlined template (next sibling)\r\n        // It must be fetched before compilation\r\n        if (!tAttrs.bsDropdown) {\r\n          var nextSibling = tElement[0].nextSibling;\r\n          while (nextSibling && nextSibling.nodeType !== 1) {\r\n            nextSibling = nextSibling.nextSibling;\r\n          }\r\n          if (nextSibling && nextSibling.className.split(' ').indexOf('dropdown-menu') >= 0) {\r\n            tAttrs.template = nextSibling.outerHTML;\r\n            tAttrs.templateUrl = undefined;\r\n            nextSibling.parentNode.removeChild(nextSibling);\r\n          }\r\n        }\r\n\r\n        return function postLink (scope, element, attr) {\r\n\r\n          // Directive options\r\n          var options = {\r\n            scope: scope\r\n          };\r\n          angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'id', 'autoClose'], function (key) {\r\n            if (angular.isDefined(tAttrs[key])) options[key] = tAttrs[key];\r\n          });\r\n\r\n          // use string regex match boolean attr falsy values, leave truthy values be\r\n          var falseValueRegExp = /^(false|0|)$/i;\r\n          angular.forEach(['html', 'container'], function (key) {\r\n            if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n          });\r\n\r\n          // bind functions from the attrs to the show and hide events\r\n          angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n            var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n            if (angular.isDefined(attr[bsKey])) {\r\n              options[key] = scope.$eval(attr[bsKey]);\r\n            }\r\n          });\r\n\r\n          // Support scope as an object\r\n          if (attr.bsDropdown) {\r\n            scope.$watch(attr.bsDropdown, function (newValue, oldValue) {\r\n              scope.content = newValue;\r\n            }, true);\r\n          }\r\n\r\n          // Initialize dropdown\r\n          var dropdown = $dropdown(element, options);\r\n\r\n          // Visibility binding support\r\n          if (attr.bsShow) {\r\n            scope.$watch(attr.bsShow, function (newValue, oldValue) {\r\n              if (!dropdown || !angular.isDefined(newValue)) return;\r\n              if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(dropdown),?/i);\r\n              if (newValue === true) {\r\n                dropdown.show();\r\n              } else {\r\n                dropdown.hide();\r\n              }\r\n            });\r\n          }\r\n\r\n          // Garbage collection\r\n          scope.$on('$destroy', function () {\r\n            if (dropdown) dropdown.destroy();\r\n            options = null;\r\n            dropdown = null;\r\n          });\r\n\r\n        };\r\n      }\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.datepicker', [\r\n  'mgcrea.ngStrap.helpers.dateParser',\r\n  'mgcrea.ngStrap.helpers.dateFormatter',\r\n  'mgcrea.ngStrap.helpers.focusElement',\r\n  'mgcrea.ngStrap.helpers.ngFocusOut',\r\n  'mgcrea.ngStrap.tooltip'])\r\n  .provider('$datepicker', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      // Uncommenting the following line will break backwards compatability\r\n      // prefixEvent: 'datepicker',\r\n      prefixClass: 'datepicker',\r\n      placement: 'bottom-left',\r\n      templateUrl: 'datepicker/datepicker.tpl.html',\r\n      trigger: 'focus',\r\n      container: false,\r\n      keyboard: true,\r\n      html: false,\r\n      delay: 0,\r\n      // lang: $locale.id,\r\n      useNative: false,\r\n      dateType: 'date',\r\n      dateFormat: 'shortDate',\r\n      timezone: null,\r\n      modelDateFormat: null,\r\n      dayFormat: 'dd',\r\n      monthFormat: 'MMM',\r\n      yearFormat: 'yyyy',\r\n      monthTitleFormat: 'MMMM yyyy',\r\n      yearTitleFormat: 'yyyy',\r\n      strictFormat: false,\r\n      autoclose: false,\r\n      minDate: -Infinity,\r\n      maxDate: +Infinity,\r\n      startView: 0,\r\n      minView: 0,\r\n      startWeek: 0,\r\n      daysOfWeekDisabled: '',\r\n      hasToday: false,\r\n      hasClear: false,\r\n      iconLeft: 'glyphicon glyphicon-chevron-left',\r\n      iconRight: 'glyphicon glyphicon-chevron-right',\r\n      // The format that will be given to the screen reader values placed in the DOM.\r\n      screenReaderDateFormat: 'fullDate',\r\n      // Focuses the table element in the dropdown upon display of the picker.\r\n      // Used mainly in 508 situations when a button is pressed via a keyboard to show the calendar.\r\n      focusOnOpen: false\r\n    };\r\n\r\n    this.$get = function ($window, $document, $rootScope, $sce, $dateFormatter, datepickerViews, $tooltip, $timeout) {\r\n\r\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n      var isTouch = ('createTouch' in $window.document) && isNative;\r\n      if (!defaults.lang) defaults.lang = $dateFormatter.getDefaultLocale();\r\n\r\n      function DatepickerFactory (element, controller, config) {\r\n\r\n        // The datepicker is based on the tooltip control. Build a basic tooltip from the\r\n        // defaults and the configuration passed.\r\n        var $datepicker = $tooltip(element, angular.extend({}, defaults, config));\r\n        var parentScope = config.scope;\r\n        var options = $datepicker.$options;\r\n        var scope = $datepicker.$scope;\r\n        if (options.startView) options.startView -= options.minView;\r\n\r\n        // Add assistive technology helper attributes.\r\n        element.attr('aria-expanded', 'false').attr('aria-haspopup', 'true');\r\n\r\n        // View vars\r\n\r\n        // Initialize the datepicker view collection by passing a reference to the base object.\r\n        var pickerViews = datepickerViews($datepicker);\r\n        $datepicker.$views = pickerViews.views;\r\n        var viewDate = pickerViews.viewDate;\r\n        /*\r\n         * View mode for the date picker.\r\n         * 0: days\r\n         * 1: months\r\n         * 2: years\r\n         */\r\n        scope.$mode = options.startView;\r\n        // icon class override\r\n        scope.$iconLeft = options.iconLeft;\r\n        scope.$iconRight = options.iconRight;\r\n        // Show buttons at the bottom of the picker.\r\n        scope.$hasToday = options.hasToday;\r\n        scope.$hasClear = options.hasClear;\r\n        /*\r\n         * An id on the element is necessary when working with assistive technologies. The view will use the id to build out the\r\n         * aria attributes which are linked via ids.\r\n         */\r\n        scope.id = options.id !== null && options.id !== undefined ? options.id : undefined;\r\n        scope.dropdownId = options.id !== null && options.id !== undefined ? (options.id + '_dropdown') : undefined;\r\n        scope.keyboard = options.keyboard;\r\n        scope.focusOnOpen = options.focusOnOpen;\r\n\r\n        // labels\r\n        scope.$nextLabel = options.labelNext;\r\n        scope.$previousLabel = options.labelPrevious;\r\n\r\n        // This is the actual current picker view.\r\n        var $picker = $datepicker.$views[scope.$mode];\r\n\r\n        // Internal handlers\r\n\r\n        function handleOnKeyDown (evt, apply) {\r\n          if (!/(33|34|38|37|39|40|13)/.test(evt.keyCode) &&\r\n            !(/(33|34|38|37|39|40|13)/.test(evt.keyCode) && evt.shiftKey) &&\r\n            !(/(33|34|38|37|39|40|13)/.test(evt.keyCode) && evt.altKey)) {\r\n            return false;\r\n          }\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n\r\n          if (evt.keyCode === 13) {\r\n            if (!scope.$mode) {\r\n              $datepicker.hide(true);\r\n              if (options.focusOnOpen) return true;\r\n            } else {\r\n              if (apply === undefined || apply) {\r\n                scope.$apply(function () {\r\n                  $datepicker.setMode(scope.$mode - 1);\r\n                });\r\n              } else {\r\n                $datepicker.setMode(scope.$mode - 1);\r\n              }\r\n            }\r\n            return false;\r\n          }\r\n\r\n          return true;\r\n        }\r\n\r\n        // Scope methods\r\n\r\n        /**\r\n         * Pass through from the scope to the provider for the selection of a date.\r\n         */\r\n        scope.$select = function (date, disabled) {\r\n          if (disabled) return;\r\n          $datepicker.select(date);\r\n        };\r\n        scope.$selectPane = function (value) {\r\n          $datepicker.$selectPane(value);\r\n        };\r\n        scope.$toggleMode = function () {\r\n          $datepicker.setMode((scope.$mode + 1) % $datepicker.$views.length);\r\n        };\r\n        scope.$setToday = function () {\r\n          if (options.autoclose) {\r\n            $datepicker.setMode(0);\r\n            $datepicker.select(new Date());\r\n          } else {\r\n            $datepicker.select(new Date(), true);\r\n          }\r\n        };\r\n        scope.$clear = function () {\r\n          if (options.autoclose) {\r\n            $datepicker.setMode(0);\r\n            $datepicker.select(null);\r\n          } else {\r\n            $datepicker.select(null, true);\r\n          }\r\n        };\r\n        scope.$focused = function (dayInfo) {\r\n          scope.selectedDayId = dayInfo.id;\r\n          if (dayInfo.isNext && !scope.selected) {\r\n            if (scope.$mode) {\r\n              $datepicker.update(dayInfo.date);\r\n            } else {\r\n              scope.$select(dayInfo.date);\r\n            }\r\n          }\r\n        };\r\n        scope.$onKeyDown = function (evt, day) {\r\n          var continueHandling = handleOnKeyDown(evt, false);\r\n\r\n          if (continueHandling) {\r\n            // Navigate with keyboard\r\n            $picker.onKeyDown(evt);\r\n          }\r\n        };\r\n        scope.$onFocusOut = function (evt) {\r\n          // find out if the related target's parents contain the datepicker's $element\r\n          var inTable = false;\r\n          var parent = angular.element(evt.relatedTarget);\r\n          while (parent !== undefined && parent.length && parent[0] !== $window.document.body) {\r\n            parent = parent.parent();\r\n            if (parent !== undefined && parent[0] === $datepicker.$element[0]) {\r\n              inTable = true;\r\n              break;\r\n            } else {\r\n              inTable = false;\r\n            }\r\n          }\r\n\r\n          // In Chrome there is an issue when moving from month to month, year to year, etc.\r\n          //\r\n\r\n          if (!inTable && !evt.relatedTarget) {\r\n            // hmm\r\n          } else if (!inTable) {\r\n            $datepicker.hide();\r\n          } else {\r\n            evt.stopPropagation();\r\n            evt.preventDefault();\r\n          }\r\n        };\r\n\r\n        // Public methods\r\n\r\n        $datepicker.update = function (date) {\r\n          // console.warn('$datepicker.update() newValue=%o', date);\r\n          if (angular.isDate(date) && !isNaN(date.getTime())) {\r\n            $datepicker.$date = date;\r\n            $picker.update.call($picker, date);\r\n          }\r\n          // Build only if pristine\r\n          $datepicker.$build(true);\r\n        };\r\n\r\n        $datepicker.updateDisabledDates = function (dateRanges) {\r\n          options.disabledDateRanges = dateRanges;\r\n          for (var i = 0, l = scope.rows.length; i < l; i++) {\r\n            angular.forEach(scope.rows[i], $datepicker.$setDisabledEl);\r\n          }\r\n        };\r\n\r\n        $datepicker.select = function (date, keep) {\r\n          // console.warn('$datepicker.select', date, scope.$mode);\r\n          if (angular.isDate(date)) {\r\n            if (!angular.isDate(controller.$dateValue) || isNaN(controller.$dateValue.getTime())) {\r\n              controller.$dateValue = new Date(date);\r\n            }\r\n          } else {\r\n            controller.$dateValue = null;\r\n          }\r\n          if (!scope.$mode || keep) {\r\n            controller.$setViewValue(angular.copy(date));\r\n            controller.$render();\r\n            if (options.autoclose && !keep) {\r\n              $timeout(function () {\r\n                $datepicker.hide(true);\r\n              });\r\n            }\r\n          } else {\r\n            angular.extend(viewDate, {\r\n              year: date.getFullYear(),\r\n              month: date.getMonth(),\r\n              date: date.getDate()\r\n            });\r\n            $datepicker.setMode(scope.$mode - 1);\r\n            $datepicker.$build();\r\n          }\r\n        };\r\n\r\n        /**\r\n         * This changes the mode of the picker. By setting the mode the view for the picker will be\r\n         * rebuilt. The views are days, months, and years.\r\n         * @param {int} mode View mode for the datepicker. 0: day view, 1: month view, 2: year view.\r\n         */\r\n        $datepicker.setMode = function setMode (mode) {\r\n          scope.$mode = mode;\r\n          $picker = $datepicker.$views[scope.$mode];\r\n          // The picker has been changed so the view needs to be built.\r\n          $datepicker.$build();\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        /**\r\n         * Builds the datepicker's view based on the picker that is currently set.\r\n         */\r\n        $datepicker.$build = function $build (pristine) {\r\n          // console.warn('$datepicker.$build() viewDate=%o', viewDate);\r\n          if (pristine === true && $picker.built) return;\r\n          if (pristine === false && !$picker.built) return;\r\n          $picker.build.call($picker);\r\n        };\r\n\r\n        $datepicker.$updateSelected = function () {\r\n          for (var i = 0, l = scope.rows.length; i < l; i++) {\r\n            angular.forEach(scope.rows[i], function (day) {\r\n              updateSelected(day);\r\n              if (day.selected) scope.selected = day;\r\n            });\r\n          }\r\n        };\r\n\r\n        $datepicker.$isSelected = function (date) {\r\n          return $picker.isSelected(date);\r\n        };\r\n\r\n        $datepicker.$setDisabledEl = function (el) {\r\n          el.disabled = $picker.isDisabled(el.date);\r\n        };\r\n\r\n        $datepicker.$selectPane = function (value) {\r\n          var steps = $picker.steps;\r\n          // set targetDate to first day of month to avoid problems with\r\n          // date values rollover. This assumes the viewDate does not\r\n          // depend on the day of the month\r\n          var targetDate = new Date(Date.UTC(viewDate.year + ((steps.year || 0) * value), viewDate.month + ((steps.month || 0) * value), 1));\r\n          angular.extend(viewDate, {\r\n            year: targetDate.getUTCFullYear(),\r\n            month: targetDate.getUTCMonth(),\r\n            date: targetDate.getUTCDate()\r\n          });\r\n          $datepicker.$build();\r\n        };\r\n\r\n        $datepicker.$onMouseDown = function (evt) {\r\n          // Prevent blur on mousedown on .dropdown-menu\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n          // Emulate click for mobile devices\r\n          if (isTouch) {\r\n            var targetEl = angular.element(evt.target);\r\n            if (targetEl[0].nodeName.toLowerCase() !== 'button') {\r\n              targetEl = targetEl.parent();\r\n            }\r\n            targetEl.triggerHandler('click');\r\n          }\r\n        };\r\n\r\n        /**\r\n         * Handles the onKeyDown event from the element that this datepicker is bound.\r\n         * In the standard case this will be an input element. If the trigger is set\r\n         * to click and is bound to a button then it is likely we're servicing a 508\r\n         * type situation where the implementation will no longer uses. Focus will be\r\n         * given to the table.\r\n         */\r\n        $datepicker.$onKeyDown = function (evt) {\r\n          var continueHandling = handleOnKeyDown(evt);\r\n\r\n          if (continueHandling) {\r\n            // Navigate with keyboard\r\n            $picker.onKeyDown(evt);\r\n            parentScope.$digest();\r\n          }\r\n        };\r\n\r\n        // $datepicker.$onFocusOut = function (evt) {\r\n        //   // find out if the related target's parents contain the datepicker's $element\r\n        //   var inTable = false;\r\n        //   var parent = angular.element(evt.relatedTarget);\r\n        //   while (parent !== undefined && parent.length && parent[0] !== $window.document.body) {\r\n        //     parent = parent.parent();\r\n        //     if (parent !== undefined && parent[0] === $datepicker.$element[0]) {\r\n        //       inTable = true;\r\n        //       break;\r\n        //     } else {\r\n        //       inTable = false;\r\n        //     }\r\n        //   }\r\n\r\n        //   // In Chrome there is an issue when moving from month to month, year to year, etc.\r\n        //   //\r\n\r\n        //   if (!inTable && !evt.relatedTarget) {\r\n        //     // hmm\r\n        //   } else if (!inTable) {\r\n        //     $datepicker.hide();\r\n        //   } else {\r\n        //     evt.stopPropagation();\r\n        //     evt.preventDefault();\r\n        //   }\r\n        // };\r\n\r\n        // Private\r\n\r\n        function updateSelected (el) {\r\n          el.selected = $datepicker.$isSelected(el.date);\r\n          el.focused = el.selected;\r\n        }\r\n\r\n        function focusElement () {\r\n          element[0].focus();\r\n        }\r\n\r\n        // Overrides\r\n\r\n        // The datepicker will override the init functionality of the tool\r\n        var _init = $datepicker.init;\r\n        /**\r\n         * Initialize the datepicker.\r\n         */\r\n        $datepicker.init = function () {\r\n          if (isNative && options.useNative) {\r\n            element.prop('type', 'date');\r\n            element.css('-webkit-appearance', 'textfield');\r\n            return;\r\n          } else if (isTouch) {\r\n            element.prop('type', 'text');\r\n            element.attr('readonly', 'true');\r\n            element.on('click', focusElement);\r\n          }\r\n          _init();\r\n        };\r\n\r\n        // The datepicker will override the destroy functionalty of the tooltip. Storing a ref to the\r\n        // tooltip's destroy function so that it can be invoked when the datepicker needs to be destroyed.\r\n        var _destroy = $datepicker.destroy;\r\n\r\n        /**\r\n         * Destroys the datepicker by removing bound events. Calls the destroy function on the tooltip.\r\n         */\r\n        $datepicker.destroy = function () {\r\n          if (isNative && options.useNative) {\r\n            element.off('click', focusElement);\r\n          }\r\n          _destroy();\r\n        };\r\n\r\n        // The datepicker will override the show functionality of the tooltip. Store a ref to the\r\n        // tooltip's show function so that it can be invoked at the appropriate time when the picker\r\n        // is to be shown.\r\n        var _show = $datepicker.show;\r\n\r\n        /**\r\n         * Override for the tooltip's show function.\r\n         *\r\n         * Checks the element for readonly or disabled before showing the \"tooltip\".\r\n         * Once shown it sets up the appropriate events.\r\n         */\r\n        $datepicker.show = function show () {\r\n          // If the input the directive is bound to is readonly or disabled then do not show a picker.\r\n          if ((!isTouch && element.attr('readonly')) || element.attr('disabled')) return;\r\n\r\n          // Call the \"overriden base\" function on the tooltip.\r\n          _show();\r\n\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed imediately.\r\n          $timeout(function () {\r\n            // if $datepicker is no longer showing, don't setup events\r\n            if (!$datepicker.$isShown) return;\r\n\r\n            // Update assistive technologies for view changes:\r\n            $datepicker.$element.attr('aria-hidden', 'false');\r\n            element.attr('aria-expanded', 'true');\r\n\r\n            // Setup the event mouse click event. TODO: Can this be wired up in the view?\r\n            $datepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\r\n\r\n            // If keyboard navigation is enabled (true by default).\r\n            if (options.keyboard) {\r\n              // $datepicker.$element.on('keydown', $datepicker.$onKeyDown);\r\n              // Check to see if the table element should receive the focus when the picker is shown.\r\n              if (options.focusOnOpen) {\r\n                // Focus the table element.\r\n                // $datepicker.$element.find('table')[0].focus();\r\n                // $datepicker.$element.on('focusout', $datepicker.$onFocusOut);\r\n              } else {\r\n                element.on('keydown', $datepicker.$onKeyDown);\r\n              }\r\n            }\r\n          }, 0, false);\r\n        };\r\n\r\n        // The datepicker will override the hide functionality of the tooltip. Store a ref to the\r\n        // tooltip's show function so that it can be invoked at the appropriate time when the picker\r\n        // is to be hidden.\r\n        var _hide = $datepicker.hide;\r\n\r\n        /**\r\n         * Overrid efor the tooltip's hide function.\r\n         *\r\n         * Updates attributes for assistive technologies and unbinds events.\r\n         */\r\n        $datepicker.hide = function (blur) {\r\n          // If the picker is already hidden don't do anything.\r\n          if (!$datepicker.$isShown) return;\r\n\r\n          // Update the attributes used by assisteive technologies\r\n          $datepicker.$element.attr('aria-hidden', 'true');\r\n          element.attr('aria-expanded', 'false');\r\n\r\n          // Unbind the mouse and touch events\r\n          $datepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\r\n\r\n          // If keyboard events were bound then unbind them.\r\n          if (options.keyboard) {\r\n            element.off('keydown', $datepicker.$onKeyDown);\r\n            $datepicker.$element.off('keydown', $datepicker.$onKeyDown);\r\n          }\r\n          if (options.focusOnOpen) {\r\n            // $datepicker.$element.off('focusout', $datepicker.$onFocusOut);\r\n            element[0].focus();\r\n          }\r\n          // Call the tooltip's hide function.\r\n          _hide(blur);\r\n        };\r\n\r\n        return $datepicker;\r\n      }\r\n\r\n      DatepickerFactory.defaults = defaults;\r\n      return DatepickerFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsDatepicker', function ($window, $parse, $q, $dateFormatter, $dateParser, $datepicker) {\r\n\r\n    // var defaults = $datepicker.defaults;\r\n    var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        // Directive options\r\n        var options = {\r\n          scope: scope\r\n        };\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'autoclose', 'dateType', 'dateFormat', 'timezone', 'modelDateFormat', 'dayFormat', 'strictFormat', 'startWeek', 'startDate', 'useNative', 'lang', 'startView', 'minView', 'iconLeft', 'iconRight', 'daysOfWeekDisabled', 'id', 'prefixClass', 'prefixEvent', 'hasToday', 'hasClear', 'focusOnOpen', 'labelNext', 'labelPrevious', 'labelMonth', 'labelYear', 'labelDays'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container', 'autoclose', 'useNative', 'hasToday', 'hasClear', 'focusOnOpen'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\r\n            options[key] = false;\r\n          }\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Initialize datepicker\r\n        var datepicker = $datepicker(element, controller, options);\r\n        options = datepicker.$options;\r\n        // Set expected iOS format\r\n        if (isNative && options.useNative) options.dateFormat = 'yyyy-MM-dd';\r\n\r\n        var lang = options.lang;\r\n\r\n        var formatDate = function (date, format) {\r\n          return $dateFormatter.formatDate(date, format, lang);\r\n        };\r\n\r\n        var dateParser = $dateParser({\r\n          format: options.dateFormat,\r\n          lang: lang,\r\n          strict: options.strictFormat\r\n        });\r\n\r\n        // Visibility binding support\r\n        if (attr.bsShow) {\r\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\r\n            if (!datepicker || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(datepicker),?/i);\r\n            if (newValue === true) {\r\n              datepicker.show();\r\n            } else {\r\n              datepicker.hide();\r\n            }\r\n          });\r\n        }\r\n\r\n        // Observe attributes for changes\r\n        angular.forEach(['minDate', 'maxDate'], function (key) {\r\n          // console.warn('attr.$observe(%s)', key, attr[key]);\r\n          if (angular.isDefined(attr[key])) {\r\n            attr.$observe(key, function (newValue) {\r\n              // console.warn('attr.$observe(%s)=%o', key, newValue);\r\n              datepicker.$options[key] = dateParser.getDateForAttribute(key, newValue);\r\n              // Build only if dirty\r\n              if (!isNaN(datepicker.$options[key])) datepicker.$build(false);\r\n              validateAgainstMinMaxDate(controller.$dateValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Observe date format\r\n        if (angular.isDefined(attr.dateFormat)) {\r\n          attr.$observe('dateFormat', function (newValue) {\r\n            datepicker.$options.dateFormat = newValue;\r\n          });\r\n        }\r\n\r\n        // Watch model for changes\r\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\r\n          datepicker.update(controller.$dateValue);\r\n        }, true);\r\n\r\n        // Normalize undefined/null/empty array,\r\n        // so that we don't treat changing from undefined->null as a change.\r\n        function normalizeDateRanges (ranges) {\r\n          if (!ranges || !ranges.length) return null;\r\n          return ranges;\r\n        }\r\n\r\n        if (angular.isDefined(attr.disabledDates)) {\r\n          scope.$watch(attr.disabledDates, function (disabledRanges, previousValue) {\r\n            disabledRanges = normalizeDateRanges(disabledRanges);\r\n            previousValue = normalizeDateRanges(previousValue);\r\n\r\n            if (disabledRanges) {\r\n              datepicker.updateDisabledDates(disabledRanges);\r\n            }\r\n          });\r\n        }\r\n\r\n        function validateAgainstMinMaxDate (parsedDate) {\r\n          if (!angular.isDate(parsedDate)) return;\r\n          var isMinValid = isNaN(datepicker.$options.minDate) || parsedDate.getTime() >= datepicker.$options.minDate;\r\n          var isMaxValid = isNaN(datepicker.$options.maxDate) || parsedDate.getTime() <= datepicker.$options.maxDate;\r\n          var isValid = isMinValid && isMaxValid;\r\n          controller.$setValidity('date', isValid);\r\n          controller.$setValidity('min', isMinValid);\r\n          controller.$setValidity('max', isMaxValid);\r\n          // Only update the model when we have a valid date\r\n          if (isValid) controller.$dateValue = parsedDate;\r\n        }\r\n\r\n        // viewValue -> $parsers -> modelValue\r\n        controller.$parsers.unshift(function (viewValue) {\r\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\r\n          var date;\r\n          // Null values should correctly reset the model value & validity\r\n          if (!viewValue) {\r\n            controller.$setValidity('date', true);\r\n            // BREAKING CHANGE:\r\n            // return null (not undefined) when input value is empty, so angularjs 1.3\r\n            // ngModelController can go ahead and run validators, like ngRequired\r\n            return null;\r\n          }\r\n          var parsedDate = dateParser.parse(viewValue, controller.$dateValue);\r\n          if (!parsedDate || isNaN(parsedDate.getTime())) {\r\n            controller.$setValidity('date', false);\r\n            // return undefined, causes ngModelController to\r\n            // invalidate model value\r\n            return;\r\n          }\r\n          validateAgainstMinMaxDate(parsedDate);\r\n\r\n          if (options.dateType === 'string') {\r\n            date = dateParser.timezoneOffsetAdjust(parsedDate, options.timezone, true);\r\n            return formatDate(date, options.modelDateFormat || options.dateFormat);\r\n          }\r\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\r\n          if (options.dateType === 'number') {\r\n            return date.getTime();\r\n          } else if (options.dateType === 'unix') {\r\n            return date.getTime() / 1000;\r\n          } else if (options.dateType === 'iso') {\r\n            return date.toISOString();\r\n          }\r\n          return new Date(date);\r\n        });\r\n\r\n        // modelValue -> $formatters -> viewValue\r\n        controller.$formatters.push(function (modelValue) {\r\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n          var date;\r\n          if (angular.isUndefined(modelValue) || modelValue === null) {\r\n            date = NaN;\r\n          } else if (angular.isDate(modelValue)) {\r\n            date = modelValue;\r\n          } else if (options.dateType === 'string') {\r\n            date = dateParser.parse(modelValue, null, options.modelDateFormat);\r\n          } else if (options.dateType === 'unix') {\r\n            date = new Date(modelValue * 1000);\r\n          } else {\r\n            date = new Date(modelValue);\r\n          }\r\n          // Setup default value?\r\n          // if (isNaN(date.getTime())) {\r\n          //   var today = new Date();\r\n          //   date = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0);\r\n          // }\r\n          // do not adjust date if timezone is UTC\r\n          if (options.timezone === 'UTC') {\r\n            controller.$dateValue = date;\r\n          } else {\r\n            controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\r\n          }\r\n          return getDateFormattedString();\r\n        });\r\n\r\n        // viewValue -> element\r\n        controller.$render = function () {\r\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\r\n          element.val(getDateFormattedString());\r\n        };\r\n\r\n        function getDateFormattedString () {\r\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.dateFormat);\r\n        }\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (datepicker) datepicker.destroy();\r\n          options = null;\r\n          datepicker = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsDatepickerDisplay', function ($datepicker, $dateParser, $dateFormatter) {\r\n    return {\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n        // Directive options\r\n        var options = {\r\n          scope: scope\r\n        };\r\n        angular.forEach(['dateType', 'dateFormat', 'timezone', 'modelDateFormat', 'dayFormat', 'strictFormat', 'lang'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        options = angular.extend({}, $datepicker.defaults, options);\r\n\r\n        var lang = options.lang;\r\n\r\n        var formatDate = function (date, format) {\r\n          return $dateFormatter.formatDate(date, format, lang);\r\n        };\r\n\r\n        var dateParser = $dateParser({\r\n          format: options.dateFormat,\r\n          lang: lang,\r\n          strict: options.strictFormat\r\n        });\r\n\r\n        // Observe attributes for changes\r\n        angular.forEach(['minDate', 'maxDate'], function (key) {\r\n          if (angular.isDefined(attr[key])) {\r\n            attr.$observe(key, function (newValue) {\r\n              options[key] = dateParser.getDateForAttribute(key, newValue);\r\n              validateAgainstMinMaxDate(controller.$dateValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Observe date format\r\n        if (angular.isDefined(attr.dateFormat)) {\r\n          attr.$observe('dateFormat', function (newValue) {\r\n            options.dateFormat = newValue;\r\n          });\r\n        }\r\n\r\n        function validateAgainstMinMaxDate (parsedDate) {\r\n          if (!angular.isDate(parsedDate)) return;\r\n          var isMinValid = isNaN(options.minDate) || parsedDate.getTime() >= options.minDate;\r\n          var isMaxValid = isNaN(options.maxDate) || parsedDate.getTime() <= options.maxDate;\r\n          var isValid = isMinValid && isMaxValid;\r\n          controller.$setValidity('date', isValid);\r\n          controller.$setValidity('min', isMinValid);\r\n          controller.$setValidity('max', isMaxValid);\r\n          // Only update the model when we have a valid date\r\n          if (isValid) controller.$dateValue = parsedDate;\r\n        }\r\n\r\n        // viewValue -> $parsers -> modelValue\r\n        controller.$parsers.unshift(function (viewValue) {\r\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\r\n          var date;\r\n          // Null values should correctly reset the model value & validity\r\n          if (!viewValue) {\r\n            controller.$setValidity('date', true);\r\n            // BREAKING CHANGE:\r\n            // return null (not undefined) when input value is empty, so angularjs 1.3\r\n            // ngModelController can go ahead and run validators, like ngRequired\r\n            return null;\r\n          }\r\n          var parsedDate = dateParser.parse(viewValue, controller.$dateValue);\r\n          if (!parsedDate || isNaN(parsedDate.getTime())) {\r\n            controller.$setValidity('date', false);\r\n            // return undefined, causes ngModelController to\r\n            // invalidate model value\r\n            return;\r\n          }\r\n          validateAgainstMinMaxDate(parsedDate);\r\n\r\n          if (options.dateType === 'string') {\r\n            date = dateParser.timezoneOffsetAdjust(parsedDate, options.timezone, true);\r\n            return formatDate(date, options.modelDateFormat || options.dateFormat);\r\n          }\r\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\r\n          if (options.dateType === 'number') {\r\n            return date.getTime();\r\n          } else if (options.dateType === 'unix') {\r\n            return date.getTime() / 1000;\r\n          } else if (options.dateType === 'iso') {\r\n            return date.toISOString();\r\n          }\r\n\r\n          return date === null ? null : new Date(date);\r\n        });\r\n\r\n        // modelValue -> $formatters -> viewValue\r\n        controller.$formatters.push(function (modelValue) {\r\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n          var date;\r\n          if (angular.isUndefined(modelValue) || modelValue === null) {\r\n            date = NaN;\r\n          } else if (angular.isDate(modelValue)) {\r\n            date = modelValue;\r\n          } else if (options.dateType === 'string') {\r\n            date = dateParser.parse(modelValue, null, options.modelDateFormat);\r\n          } else if (options.dateType === 'unix') {\r\n            date = new Date(modelValue * 1000);\r\n          } else {\r\n            date = new Date(modelValue);\r\n          }\r\n          // Setup default value?\r\n          // if (isNaN(date.getTime())) {\r\n          //   var today = new Date();\r\n          //   date = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0);\r\n          // }\r\n          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\r\n          return getDateFormattedString();\r\n        });\r\n\r\n        function getDateFormattedString () {\r\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.dateFormat);\r\n        }\r\n      }\r\n    };\r\n  })\r\n\r\n  .provider('datepickerViews', function () {\r\n\r\n    // var defaults = this.defaults = {\r\n    //   dayFormat: 'dd',\r\n    //   daySplit: 7\r\n    // };\r\n\r\n    // Split array into smaller arrays\r\n    function split (arr, size) {\r\n      var arrays = [];\r\n      while (arr.length > 0) {\r\n        arrays.push(arr.splice(0, size));\r\n      }\r\n      return arrays;\r\n    }\r\n\r\n    // Modulus operator\r\n    function mod (n, m) {\r\n      return ((n % m) + m) % m;\r\n    }\r\n\r\n    this.$get = function ($dateFormatter, $dateParser, $sce) {\r\n\r\n      return function (picker) {\r\n\r\n        var scope = picker.$scope;\r\n        var options = picker.$options;\r\n\r\n        var lang = options.lang;\r\n        var formatDate = function (date, format) {\r\n          return $dateFormatter.formatDate(date, format, lang);\r\n        };\r\n        var dateParser = $dateParser({\r\n          format: options.dateFormat,\r\n          lang: lang,\r\n          strict: options.strictFormat\r\n        });\r\n\r\n        var weekDaysMin = $dateFormatter.weekdaysShort(lang);\r\n        var weekDaysLong = $dateFormatter.weekdays(lang);\r\n        var weekDaysShortLabels = weekDaysMin.slice(options.startWeek).concat(weekDaysMin.slice(0, options.startWeek));\r\n        var weekDaysLongLabels = weekDaysLong.slice(options.startWeek).concat(weekDaysMin.slice(0, options.startWeek));\r\n\r\n        var weekDaysLabelsHtml = '';\r\n        for (var i = 0; i < weekDaysShortLabels.length; i++) {\r\n          var weekDayShortLabel = weekDaysShortLabels[i];\r\n          var weekDayLabel = weekDaysLongLabels[i];\r\n          weekDaysLabelsHtml += '<th scope=\"col\" role=\"columnheader\" class=\"dow text-center\" aria-label=\"' + weekDayLabel + '\"><abbr title=\"' + weekDayLabel + '\">' + weekDayShortLabel + '</abbr></th>';\r\n        }\r\n        weekDaysLabelsHtml = $sce.trustAsHtml(weekDaysLabelsHtml);\r\n\r\n        var startDate = picker.$date || (options.startDate ? dateParser.getDateForAttribute('startDate', options.startDate) : new Date());\r\n        var viewDate = {\r\n          year: startDate.getFullYear(),\r\n          month: startDate.getMonth(),\r\n          date: startDate.getDate()\r\n        };\r\n\r\n        var views = [{\r\n          format: options.dayFormat,\r\n          split: 7,\r\n          steps: {\r\n            month: 1\r\n          },\r\n          update: function (date, force) {\r\n            if (!this.built || force || date.getFullYear() !== viewDate.year || date.getMonth() !== viewDate.month) {\r\n              angular.extend(viewDate, {\r\n                year: picker.$date.getFullYear(),\r\n                month: picker.$date.getMonth(),\r\n                date: picker.$date.getDate()\r\n              });\r\n              picker.$build();\r\n            } else if (date.getDate() !== viewDate.date || date.getDate() === 1) {\r\n                // chaging picker current month will cause viewDate.date to be set to first day of the month,\r\n                // in $datepicker.$selectPane, so picker would not update selected day display if\r\n                // user picks first day of the new month.\r\n                // As a workaround, we are always forcing update when picked date is first day of month.\r\n              viewDate.date = picker.$date.getDate();\r\n              picker.$updateSelected();\r\n            }\r\n          },\r\n          build: function () {\r\n            var firstDayOfMonth = new Date(viewDate.year, viewDate.month, 1);\r\n            var firstDayOfMonthOffset = firstDayOfMonth.getTimezoneOffset();\r\n            var firstDate = new Date(+firstDayOfMonth - mod(firstDayOfMonth.getDay() - options.startWeek, 7) * 864e5);\r\n            var firstDateOffset = firstDate.getTimezoneOffset();\r\n            var today = dateParser.timezoneOffsetAdjust(new Date(), options.timezone).toDateString();\r\n              // Handle daylight time switch\r\n            if (firstDateOffset !== firstDayOfMonthOffset) firstDate = new Date(+firstDate + (firstDateOffset - firstDayOfMonthOffset) * 60e3);\r\n            var days = [];\r\n            var day;\r\n            var selectedDay;\r\n            var todayDay;\r\n            for (var i = 0; i < 42; i++) { // < 7 * 6\r\n              day = dateParser.daylightSavingAdjust(new Date(firstDate.getFullYear(), firstDate.getMonth(), firstDate.getDate() + i));\r\n              // push the day information onto the collection\r\n              var dayItem = {\r\n                id: options.id !== null && options.id !== undefined ? (options.id + '_cell_' + i) : undefined,\r\n                date: day,\r\n                value: day.getDate(),\r\n                isToday: day.toDateString() === today,\r\n                label: formatDate(day, this.format),\r\n                screenReaderLabel: formatDate(day, $dateFormatter.getDatetimeFormat(options.screenReaderDateFormat)),\r\n                selected: picker.$date && this.isSelected(day),\r\n                muted: day.getMonth() !== viewDate.month,\r\n                disabled: this.isDisabled(day)\r\n              };\r\n\r\n              if (dayItem.selected) selectedDay = dayItem;\r\n              if (dayItem.isToday) todayDay = dayItem;\r\n\r\n              days.push(dayItem);\r\n            }\r\n\r\n            scope.selected = null;\r\n\r\n            var defaultFirstDayTabIndex = false;\r\n            // Setup the focusing\r\n            if (options.focusOnOpen) {\r\n              if (selectedDay) {\r\n                scope.selectedDayId = selectedDay.id;\r\n                if (todayDay) todayDay.focused = false;\r\n                // Needs to fire after the today focusing is unset in case the selected day is today.\r\n                selectedDay.focused = true;\r\n                scope.selected = selectedDay;\r\n              } else if (todayDay) {\r\n                todayDay.focused = true;\r\n              } else {\r\n                defaultFirstDayTabIndex = true;\r\n              }\r\n            }\r\n\r\n            scope.title = formatDate(firstDayOfMonth, options.monthTitleFormat);\r\n            scope.showLabels = true;\r\n            scope.labels = weekDaysLabelsHtml;\r\n            scope.rows = split(days, this.split);\r\n            if (defaultFirstDayTabIndex) {\r\n              scope.rows[0][0].isNext = true;\r\n            }\r\n            scope.isTodayDisabled = this.isDisabled(new Date());\r\n            scope.hasSelectedDate = picker.$date != null;\r\n            scope.$modeLabel = options.labelMonth;\r\n            this.built = true;\r\n          },\r\n          isSelected: function (date) {\r\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear() &&\r\n              date.getMonth() === picker.$date.getMonth() &&\r\n              date.getDate() === picker.$date.getDate();\r\n          },\r\n          isDisabled: function (date) {\r\n            var time = date.getTime();\r\n\r\n              // Disabled because of min/max date.\r\n            if (time < options.minDate || time > options.maxDate) return true;\r\n\r\n              // Disabled due to being a disabled day of the week\r\n            if (options.daysOfWeekDisabled.indexOf(date.getDay()) !== -1) return true;\r\n\r\n              // Disabled because of disabled date range.\r\n            if (options.disabledDateRanges) {\r\n              for (var i = 0; i < options.disabledDateRanges.length; i++) {\r\n                if (time >= options.disabledDateRanges[i].start && time <= options.disabledDateRanges[i].end) {\r\n                  return true;\r\n                }\r\n              }\r\n            }\r\n\r\n            return false;\r\n          },\r\n          onKeyDown: function (evt) {\r\n            var actualTime;\r\n\r\n            // If the picker doesn't have a date selected and the event comes from the today TD\r\n            // then set the picker's $date to today and set the actual time to its value.\r\n            if (options.keyboard &&\r\n              options.focusOnOpen &&\r\n              !picker.$date) {\r\n              if (angular.element(evt.target).find('span').hasClass('btn-today')) {\r\n                picker.$date = new Date();\r\n              } else {\r\n                picker.$date = dateParser.parse(angular.element(evt.target).attr('aria-label'), null, options.screenReaderDateFormat);\r\n              }\r\n            }\r\n\r\n            if (!picker.$date) {\r\n              return false;\r\n            }\r\n\r\n            actualTime = picker.$date.getTime();\r\n\r\n            var newDate;\r\n\r\n            switch (evt.keyCode) {\r\n              // enter\r\n              case 13:\r\n                if (options.focusOnOpen) {\r\n                  picker.select(new Date(actualTime), true);\r\n                  return false;\r\n                }\r\n                break;\r\n              // pageup\r\n              case 33:\r\n                if (evt.altKey) { // move back a year\r\n                  newDate = new Date(picker.$date.getFullYear() - 1, picker.$date.getMonth(), picker.$date.getDate());\r\n                } else { // move back a month\r\n                  newDate = new Date(picker.$date.getFullYear(), picker.$date.getMonth() - 1, picker.$date.getDate());\r\n                  if (newDate.getMonth() > (picker.$date.getMonth() - 1)) {\r\n                    newDate = new Date(picker.$date.getFullYear(), picker.$date.getMonth(), 0);\r\n                  }\r\n                }\r\n                break;\r\n\r\n              // pagedown\r\n              case 34:\r\n                if (evt.altKey) { // move forward a year\r\n                  newDate = new Date(picker.$date.getFullYear() + 1, picker.$date.getMonth(), picker.$date.getDate());\r\n                } else { // move forward a month\r\n                  newDate = new Date(picker.$date.getFullYear(), picker.$date.getMonth() + 1, picker.$date.getDate());\r\n                  if (newDate.getMonth() > (picker.$date.getMonth() + 1)) {\r\n                    newDate = new Date(picker.$date.getFullYear(), picker.$date.getMonth() + 1, 1);\r\n                  }\r\n                }\r\n\r\n                break;\r\n\r\n              // left arrow\r\n              case 37:\r\n                newDate = new Date(actualTime - 1 * 864e5);\r\n                break;\r\n\r\n              // up arrow\r\n              case 38:\r\n                newDate = new Date(actualTime - 7 * 864e5);\r\n                break;\r\n\r\n              // right arrow\r\n              case 39:\r\n                newDate = new Date(actualTime + 1 * 864e5);\r\n                break;\r\n\r\n              // down arrow\r\n              case 40:\r\n                newDate = new Date(actualTime + 7 * 864e5);\r\n                break;\r\n\r\n              default:\r\n                return false;\r\n            }\r\n\r\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\r\n\r\n            if (evt && evt.stopPropagation) evt.stopPropagation();\r\n\r\n            return false;\r\n          }\r\n        }, {\r\n          name: 'month',\r\n          format: options.monthFormat,\r\n          split: 4,\r\n          steps: {\r\n            year: 1\r\n          },\r\n          update: function (date, force) {\r\n            if (!this.built || date.getFullYear() !== viewDate.year) {\r\n              angular.extend(viewDate, {\r\n                year: picker.$date.getFullYear(),\r\n                month: picker.$date.getMonth(),\r\n                date: picker.$date.getDate()\r\n              });\r\n              picker.$build();\r\n            } else if (date.getMonth() !== viewDate.month) {\r\n              angular.extend(viewDate, {\r\n                month: picker.$date.getMonth(),\r\n                date: picker.$date.getDate()\r\n              });\r\n              picker.$updateSelected();\r\n            }\r\n          },\r\n          build: function () {\r\n            // var firstMonth = new Date(viewDate.year, 0, 1);\r\n            var months = [];\r\n            var month;\r\n            var thisMonthDate = new Date((new Date()).getFullYear(), (new Date()).getMonth(), 1);\r\n            var selectedMonth;\r\n            var thisMonth;\r\n            for (var i = 0; i < 12; i++) {\r\n              month = new Date(viewDate.year, i, 1);\r\n\r\n              var monthItem = {\r\n                date: month,\r\n                label: formatDate(month, this.format),\r\n                selected: picker.$isSelected(month),\r\n                isToday: month.getFullYear() === thisMonthDate.getFullYear() && month.getMonth() === thisMonthDate.getMonth(),\r\n                disabled: this.isDisabled(month)\r\n              };\r\n\r\n              if (monthItem.selected) selectedMonth = monthItem;\r\n              if (monthItem.isToday) thisMonth = monthItem;\r\n\r\n              months.push(monthItem);\r\n            }\r\n\r\n            scope.selected = null;\r\n\r\n            var defaultFirstDayTabIndex = false;\r\n            // Setup the focusing\r\n            if (options.focusOnOpen) {\r\n              if (selectedMonth) {\r\n                scope.selectedDayId = selectedMonth.id;\r\n                if (thisMonth) thisMonth.focused = false;\r\n                // Needs to fire after the today focusing is unset in case the selected day is today.\r\n                selectedMonth.focused = true;\r\n                scope.selected = selectedMonth;\r\n              } else if (thisMonth) {\r\n                thisMonth.focused = true;\r\n              } else {\r\n                defaultFirstDayTabIndex = true;\r\n              }\r\n            }\r\n\r\n            scope.title = formatDate(month, options.yearTitleFormat);\r\n            scope.showLabels = false;\r\n            scope.rows = split(months, this.split);\r\n            if (defaultFirstDayTabIndex) {\r\n              scope.rows[0][0].isNext = true;\r\n            }\r\n            scope.$modeLabel = options.labelYear;\r\n            this.built = true;\r\n          },\r\n          isSelected: function (date) {\r\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth();\r\n          },\r\n          isDisabled: function (date) {\r\n            var lastDate = +new Date(date.getFullYear(), date.getMonth() + 1, 0);\r\n            return lastDate < options.minDate || date.getTime() > options.maxDate;\r\n          },\r\n          onKeyDown: function (evt) {\r\n            // If the picker doesn't have a date selected and the event comes from the today TD\r\n            // then set the picker's $date to today and set the actual time to its value.\r\n            if (options.keyboard &&\r\n              options.focusOnOpen &&\r\n              !picker.$date &&\r\n              angular.element(evt.target).find('span').hasClass('btn-today')) {\r\n              picker.$date = new Date((new Date()).getFullYear(), (new Date()).getMonth(), 1);\r\n            }\r\n\r\n            if (!picker.$date) {\r\n              return;\r\n            }\r\n            var actualMonth = picker.$date.getMonth();\r\n            var newDate = new Date(picker.$date);\r\n\r\n            if (evt.keyCode === 37) newDate.setMonth(actualMonth - 1);\r\n            else if (evt.keyCode === 38) newDate.setMonth(actualMonth - 4);\r\n            else if (evt.keyCode === 39) newDate.setMonth(actualMonth + 1);\r\n            else if (evt.keyCode === 40) newDate.setMonth(actualMonth + 4);\r\n\r\n            if (options.focusOnOpen && evt.keyCode === 13) picker.select(new Date(picker.$date));\r\n            else if (!this.isDisabled(newDate)) picker.select(newDate, true);\r\n          }\r\n        }, {\r\n          name: 'year',\r\n          format: options.yearFormat,\r\n          split: 4,\r\n          steps: {\r\n            year: 12\r\n          },\r\n          update: function (date, force) {\r\n            if (!this.built || force || parseInt(date.getFullYear() / 20, 10) !== parseInt(viewDate.year / 20, 10)) {\r\n              angular.extend(viewDate, {\r\n                year: picker.$date.getFullYear(),\r\n                month: picker.$date.getMonth(),\r\n                date: picker.$date.getDate()\r\n              });\r\n              picker.$build();\r\n            } else if (date.getFullYear() !== viewDate.year) {\r\n              angular.extend(viewDate, {\r\n                year: picker.$date.getFullYear(),\r\n                month: picker.$date.getMonth(),\r\n                date: picker.$date.getDate()\r\n              });\r\n              picker.$updateSelected();\r\n            }\r\n          },\r\n          build: function () {\r\n            var firstYear = viewDate.year - viewDate.year % (this.split * 3);\r\n            var years = [];\r\n            var year;\r\n            var selectedYear;\r\n            var thisYear;\r\n            for (var i = 0; i < 12; i++) {\r\n              year = new Date(firstYear + i, 0, 1);\r\n\r\n              var yearItem = {\r\n                date: year,\r\n                label: formatDate(year, this.format),\r\n                selected: picker.$isSelected(year),\r\n                isToday: year.getFullYear() === (new Date()).getFullYear(),\r\n                disabled: this.isDisabled(year)\r\n              };\r\n\r\n              if (yearItem.selected) selectedYear = yearItem;\r\n              if (yearItem.isToday) thisYear = yearItem;\r\n\r\n              years.push(yearItem);\r\n            }\r\n\r\n            scope.selected = null;\r\n\r\n            var defaultFirstDayTabIndex = false;\r\n            // Setup the focusing\r\n            if (options.focusOnOpen) {\r\n              if (selectedYear) {\r\n                scope.selectedDayId = selectedYear.id;\r\n                if (thisYear) thisYear.focused = false;\r\n                // Needs to fire after the today focusing is unset in case the selected day is today.\r\n                selectedYear.focused = true;\r\n                scope.selected = selectedYear;\r\n              } else if (thisYear) {\r\n                thisYear.focused = true;\r\n              } else {\r\n                defaultFirstDayTabIndex = true;\r\n              }\r\n            }\r\n\r\n            scope.title = years[0].label + '-' + years[years.length - 1].label;\r\n            scope.showLabels = false;\r\n            scope.rows = split(years, this.split);\r\n            if (defaultFirstDayTabIndex) {\r\n              scope.rows[0][0].isNext = true;\r\n            }\r\n            scope.$modelLabel = options.labelDays;\r\n            this.built = true;\r\n          },\r\n          isSelected: function (date) {\r\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear();\r\n          },\r\n          isDisabled: function (date) {\r\n            var lastDate = +new Date(date.getFullYear() + 1, 0, 0);\r\n            return lastDate < options.minDate || date.getTime() > options.maxDate;\r\n          },\r\n          onKeyDown: function (evt) {\r\n            // If the picker doesn't have a date selected and the event comes from the today TD\r\n            // then set the picker's $date to today and set the actual time to its value.\r\n            if (options.keyboard &&\r\n              options.focusOnOpen &&\r\n              !picker.$date &&\r\n              angular.element(evt.target).find('span').hasClass('btn-today')) {\r\n              picker.$date = new Date((new Date()).getFullYear(), 0, 1);\r\n            }\r\n\r\n            if (!picker.$date) {\r\n              return;\r\n            }\r\n            var actualYear = picker.$date.getFullYear();\r\n            var newDate = new Date(picker.$date);\r\n\r\n            if (evt.keyCode === 37) newDate.setYear(actualYear - 1);\r\n            else if (evt.keyCode === 38) newDate.setYear(actualYear - 4);\r\n            else if (evt.keyCode === 39) newDate.setYear(actualYear + 1);\r\n            else if (evt.keyCode === 40) newDate.setYear(actualYear + 4);\r\n\r\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\r\n          }\r\n        }];\r\n\r\n        return {\r\n          views: options.minView ? Array.prototype.slice.call(views, options.minView) : views,\r\n          viewDate: viewDate\r\n        };\r\n\r\n      };\r\n\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.collapse', [])\r\n\r\n  .provider('$collapse', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-collapse',\r\n      disallowToggle: false,\r\n      activeClass: 'in',\r\n      startCollapsed: false,\r\n      allowMultiple: false\r\n    };\r\n\r\n    var controller = this.controller = function ($scope, $element, $attrs) {\r\n      var self = this;\r\n\r\n      // Attributes options\r\n      self.$options = angular.copy(defaults);\r\n      angular.forEach(['animation', 'disallowToggle', 'activeClass', 'startCollapsed', 'allowMultiple'], function (key) {\r\n        if (angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\r\n      });\r\n\r\n      // use string regex match boolean attr falsy values, leave truthy values be\r\n      var falseValueRegExp = /^(false|0|)$/i;\r\n      angular.forEach(['disallowToggle', 'startCollapsed', 'allowMultiple'], function (key) {\r\n        if (angular.isDefined($attrs[key]) && falseValueRegExp.test($attrs[key])) {\r\n          self.$options[key] = false;\r\n        }\r\n      });\r\n\r\n      self.$toggles = [];\r\n      self.$targets = [];\r\n\r\n      self.$viewChangeListeners = [];\r\n\r\n      self.$registerToggle = function (element) {\r\n        self.$toggles.push(element);\r\n        element.attr('aria-expanded', 'false');\r\n      };\r\n      self.$registerTarget = function (element) {\r\n        self.$targets.push(element);\r\n\r\n        var i = 0;\r\n        if (self.$targets) {\r\n          for (i = 0; i < self.$targets.length; i++) {\r\n            self.$targets[i].attr('aria-hidden', 'true');\r\n          }\r\n          for (i = 0; i < self.$targets.$active.length; i++) {\r\n            if (self.$targets[self.$targets.$active[i]]) {\r\n              self.$targets[self.$targets.$active[i]].attr('aria-hidden', 'false');\r\n            }\r\n            if (self.$toggles[self.$targets.$active[i]]) {\r\n              self.$toggles[self.$targets.$active[i]].attr('aria-expanded', 'true');\r\n            }\r\n          }\r\n        }\r\n      };\r\n\r\n      self.$unregisterToggle = function (element) {\r\n        var index = self.$toggles.indexOf(element);\r\n        // remove toggle from $toggles array\r\n        self.$toggles.splice(index, 1);\r\n      };\r\n      self.$unregisterTarget = function (element) {\r\n        var index = self.$targets.indexOf(element);\r\n\r\n        // remove element from $targets array\r\n        self.$targets.splice(index, 1);\r\n\r\n        if (self.$options.allowMultiple) {\r\n          // remove target index from $active array values\r\n          deactivateItem(element);\r\n        }\r\n\r\n        // fix active item indexes\r\n        fixActiveItemIndexes(index);\r\n\r\n        self.$viewChangeListeners.forEach(function (fn) {\r\n          fn();\r\n        });\r\n      };\r\n\r\n      // use array to store all the currently open panels\r\n      self.$targets.$active = !self.$options.startCollapsed ? [0] : [];\r\n      self.$setActive = $scope.$setActive = function (value) {\r\n        if (angular.isArray(value)) {\r\n          self.$targets.$active = value;\r\n        } else if (!self.$options.disallowToggle && isActive(value)) {\r\n          deactivateItem(value);\r\n        } else {\r\n          activateItem(value);\r\n        }\r\n\r\n        self.$viewChangeListeners.forEach(function (fn) {\r\n          fn();\r\n        });\r\n      };\r\n\r\n      self.$activeIndexes = function () {\r\n        if (self.$options.allowMultiple) {\r\n          return self.$targets.$active;\r\n        }\r\n        return self.$targets.$active.length === 1 ? self.$targets.$active[0] : -1;\r\n      };\r\n\r\n      function fixActiveItemIndexes (index) {\r\n        // item with index was removed, so we\r\n        // need to adjust other items index values\r\n        var activeIndexes = self.$targets.$active;\r\n        for (var i = 0; i < activeIndexes.length; i++) {\r\n          if (index < activeIndexes[i]) {\r\n            activeIndexes[i] = activeIndexes[i] - 1;\r\n          }\r\n\r\n          // the last item is active, so we need to\r\n          // adjust its index\r\n          if (activeIndexes[i] === self.$targets.length) {\r\n            activeIndexes[i] = self.$targets.length - 1;\r\n          }\r\n        }\r\n      }\r\n\r\n      function isActive (value) {\r\n        var activeItems = self.$targets.$active;\r\n        return activeItems.indexOf(value) !== -1;\r\n      }\r\n\r\n      function deactivateItem (value) {\r\n        var index = self.$targets.$active.indexOf(value);\r\n        if (index !== -1) {\r\n          self.$targets[self.$targets.$active[index]].attr('aria-hidden', 'true');\r\n          self.$toggles[self.$targets.$active[index]].attr('aria-expanded', 'false');\r\n          self.$targets.$active.splice(index, 1);\r\n        }\r\n      }\r\n\r\n      function activateItem (value) {\r\n        if (!self.$options.allowMultiple) {\r\n          // remove current selected item\r\n          if (self.$targets[self.$targets.$active[0]] !== undefined) {\r\n            self.$targets[self.$targets.$active[0]].attr('aria-hidden', 'true');\r\n          }\r\n          if (self.$toggles[self.$targets.$active[0]]) {\r\n            self.$toggles[self.$targets.$active[0]].attr('aria-expanded', 'false');\r\n          }\r\n          self.$targets.$active.splice(0, 1);\r\n        }\r\n\r\n        if (self.$targets.$active.indexOf(value) === -1) {\r\n          self.$targets.$active.push(value);\r\n\r\n          if (self.$targets[self.$targets.$active[self.$targets.$active.length - 1]] !== undefined) {\r\n            self.$targets[self.$targets.$active[self.$targets.$active.length - 1]].attr('aria-hidden', 'false');\r\n          }\r\n          if (self.$toggles[self.$targets.$active[self.$targets.$active.length - 1]] !== undefined) {\r\n            self.$toggles[self.$targets.$active[self.$targets.$active.length - 1]].attr('aria-expanded', 'true');\r\n          }\r\n        }\r\n      }\r\n\r\n    };\r\n\r\n    this.$get = function () {\r\n      var $collapse = {};\r\n      $collapse.defaults = defaults;\r\n      $collapse.controller = controller;\r\n      return $collapse;\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsCollapse', function ($window, $animate, $collapse) {\r\n\r\n    return {\r\n      require: ['?ngModel', 'bsCollapse'],\r\n      controller: ['$scope', '$element', '$attrs', $collapse.controller],\r\n      link: function postLink (scope, element, attrs, controllers) {\r\n\r\n        var ngModelCtrl = controllers[0];\r\n        var bsCollapseCtrl = controllers[1];\r\n\r\n        if (ngModelCtrl) {\r\n\r\n          // Update the modelValue following\r\n          bsCollapseCtrl.$viewChangeListeners.push(function () {\r\n            ngModelCtrl.$setViewValue(bsCollapseCtrl.$activeIndexes());\r\n          });\r\n\r\n          // modelValue -> $formatters -> viewValue\r\n          ngModelCtrl.$formatters.push(function (modelValue) {\r\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n            if (angular.isArray(modelValue)) {\r\n              // model value is an array, so just replace\r\n              // the active items directly\r\n              bsCollapseCtrl.$setActive(modelValue);\r\n            } else {\r\n              var activeIndexes = bsCollapseCtrl.$activeIndexes();\r\n\r\n              if (angular.isArray(activeIndexes)) {\r\n                // we have an array of selected indexes\r\n                if (activeIndexes.indexOf(modelValue * 1) === -1) {\r\n                  // item with modelValue index is not active\r\n                  bsCollapseCtrl.$setActive(modelValue * 1);\r\n                }\r\n              } else if (activeIndexes !== modelValue * 1) {\r\n                bsCollapseCtrl.$setActive(modelValue * 1);\r\n              }\r\n            }\r\n            return modelValue;\r\n          });\r\n\r\n        }\r\n\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsCollapseToggle', function () {\r\n\r\n    return {\r\n      require: ['^?ngModel', '^bsCollapse'],\r\n      link: function postLink (scope, element, attrs, controllers) {\r\n\r\n        // var ngModelCtrl = controllers[0];\r\n        var bsCollapseCtrl = controllers[1];\r\n\r\n        // Add base attr\r\n        element.attr('data-toggle', 'collapse');\r\n\r\n        // Push pane to parent bsCollapse controller\r\n        bsCollapseCtrl.$registerToggle(element);\r\n\r\n        // remove toggle from collapse controller when toggle is destroyed\r\n        scope.$on('$destroy', function () {\r\n          bsCollapseCtrl.$unregisterToggle(element);\r\n        });\r\n\r\n        var actionEventHandler = function () {\r\n          if (!attrs.disabled) {\r\n            var index = attrs.bsCollapseToggle && attrs.bsCollapseToggle !== 'bs-collapse-toggle' ? attrs.bsCollapseToggle : bsCollapseCtrl.$toggles.indexOf(element);\r\n            bsCollapseCtrl.$setActive(index * 1);\r\n            scope.$apply();\r\n          }\r\n        };\r\n\r\n        element.on('click', actionEventHandler);\r\n        element.bind('keydown keypress', function (e) {\r\n          if (e.which === 13 || e.which === 32) {\r\n            actionEventHandler();\r\n            e.preventDefault();\r\n          } else if (e.which !== 16 && e.which !== 9) {\r\n            e.preventDefault();\r\n          }\r\n        });\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsCollapseTarget', function ($animate) {\r\n\r\n    return {\r\n      require: ['^?ngModel', '^bsCollapse'],\r\n      // scope: true,\r\n      link: function postLink (scope, element, attrs, controllers) {\r\n\r\n        // var ngModelCtrl = controllers[0];\r\n        var bsCollapseCtrl = controllers[1];\r\n\r\n        // Add base class\r\n        element.addClass('collapse');\r\n\r\n        // Add animation class\r\n        if (bsCollapseCtrl.$options.animation) {\r\n          element.addClass(bsCollapseCtrl.$options.animation);\r\n        }\r\n\r\n        // Push pane to parent bsCollapse controller\r\n        bsCollapseCtrl.$registerTarget(element);\r\n\r\n        // remove pane target from collapse controller when target is destroyed\r\n        scope.$on('$destroy', function () {\r\n          bsCollapseCtrl.$unregisterTarget(element);\r\n        });\r\n\r\n        function render () {\r\n          var index = bsCollapseCtrl.$targets.indexOf(element);\r\n          var active = bsCollapseCtrl.$activeIndexes();\r\n          var action = 'removeClass';\r\n          if (angular.isArray(active)) {\r\n            if (active.indexOf(index) !== -1) {\r\n              action = 'addClass';\r\n            }\r\n          } else if (index === active) {\r\n            action = 'addClass';\r\n          }\r\n\r\n          $animate[action](element, bsCollapseCtrl.$options.activeClass);\r\n        }\r\n\r\n        bsCollapseCtrl.$viewChangeListeners.push(function () {\r\n          render();\r\n        });\r\n        render();\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.button', [])\r\n\r\n  .provider('$button', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      activeClass: 'active',\r\n      toggleEvent: 'click'\r\n    };\r\n\r\n    this.$get = function () {\r\n      return {defaults: defaults};\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsCheckboxGroup', function () {\r\n\r\n    return {\r\n      restrict: 'A',\r\n      require: 'ngModel',\r\n      compile: function postLink (element, attr) {\r\n        element.attr('data-toggle', 'buttons');\r\n        element.removeAttr('ng-model');\r\n        var children = element[0].querySelectorAll('input[type=\"checkbox\"]');\r\n        angular.forEach(children, function (child) {\r\n          var childEl = angular.element(child);\r\n          childEl.attr('bs-checkbox', '');\r\n          childEl.attr('ng-model', attr.ngModel + '.' + childEl.attr('value'));\r\n        });\r\n      }\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsCheckbox', function ($button, $$rAF) {\r\n\r\n    var defaults = $button.defaults;\r\n    var constantValueRegExp = /^(true|false|\\d+)$/;\r\n\r\n    return {\r\n      restrict: 'A',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        var options = defaults;\r\n\r\n        // Support label > input[type=\"checkbox\"]\r\n        var isInput = element[0].nodeName === 'INPUT';\r\n        var activeElement = isInput ? element.parent() : element;\r\n\r\n        var trueValue = angular.isDefined(attr.trueValue) ? attr.trueValue : true;\r\n        if (constantValueRegExp.test(attr.trueValue)) {\r\n          trueValue = scope.$eval(attr.trueValue);\r\n        }\r\n        var falseValue = angular.isDefined(attr.falseValue) ? attr.falseValue : false;\r\n        if (constantValueRegExp.test(attr.falseValue)) {\r\n          falseValue = scope.$eval(attr.falseValue);\r\n        }\r\n\r\n        // Parse exotic values\r\n        var hasExoticValues = typeof trueValue !== 'boolean' || typeof falseValue !== 'boolean';\r\n        if (hasExoticValues) {\r\n          controller.$parsers.push(function (viewValue) {\r\n            // console.warn('$parser', element.attr('ng-model'), 'viewValue', viewValue);\r\n            return viewValue ? trueValue : falseValue;\r\n          });\r\n          // modelValue -> $formatters -> viewValue\r\n          controller.$formatters.push(function (modelValue) {\r\n             // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n            return angular.equals(modelValue, trueValue);\r\n          });\r\n        }\r\n\r\n        // model -> view\r\n        controller.$render = function () {\r\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\r\n          var isActive = !!controller.$viewValue;\r\n          $$rAF(function () {\r\n            if (isInput) element[0].checked = isActive;\r\n            activeElement.toggleClass(options.activeClass, isActive);\r\n          });\r\n        };\r\n\r\n        // view -> model\r\n        element.bind(options.toggleEvent, function () {\r\n          scope.$apply(function () {\r\n            // console.warn('!click', element.attr('ng-model'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\r\n            if (!isInput) {\r\n              controller.$setViewValue(!activeElement.hasClass('active'));\r\n            }\r\n            controller.$render();\r\n          });\r\n        });\r\n\r\n      }\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsRadioGroup', function () {\r\n\r\n    return {\r\n      restrict: 'A',\r\n      require: 'ngModel',\r\n      compile: function postLink (element, attr) {\r\n        element.attr('data-toggle', 'buttons');\r\n        element.removeAttr('ng-model');\r\n        var children = element[0].querySelectorAll('input[type=\"radio\"]');\r\n        angular.forEach(children, function (child) {\r\n          angular.element(child).attr('bs-radio', '');\r\n          angular.element(child).attr('ng-model', attr.ngModel);\r\n        });\r\n      }\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsRadio', function ($button, $$rAF) {\r\n\r\n    var defaults = $button.defaults;\r\n    var constantValueRegExp = /^(true|false|\\d+)$/;\r\n\r\n    return {\r\n      restrict: 'A',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        var options = defaults;\r\n\r\n        // Support `label > input[type=\"radio\"]` markup\r\n        var isInput = element[0].nodeName === 'INPUT';\r\n        var activeElement = isInput ? element.parent() : element;\r\n\r\n        var value;\r\n        attr.$observe('value', function (v) {\r\n          if (typeof v !== 'boolean' && constantValueRegExp.test(v)) {\r\n            value = scope.$eval(v);\r\n          } else {\r\n            value = v;\r\n          }\r\n          controller.$render();\r\n        });\r\n\r\n        // model -> view\r\n        controller.$render = function () {\r\n          // console.warn('$render', element.attr('value'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\r\n          var isActive = angular.equals(controller.$viewValue, value);\r\n          $$rAF(function () {\r\n            if (isInput) element[0].checked = isActive;\r\n            activeElement.toggleClass(options.activeClass, isActive);\r\n          });\r\n        };\r\n\r\n        // view -> model\r\n        element.bind(options.toggleEvent, function () {\r\n          scope.$apply(function () {\r\n            // console.warn('!click', element.attr('value'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\r\n            controller.$setViewValue(value);\r\n            controller.$render();\r\n          });\r\n        });\r\n\r\n      }\r\n\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.aside', ['mgcrea.ngStrap.modal'])\r\n\r\n  .provider('$aside', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade-and-slide-right',\r\n      prefixClass: 'aside',\r\n      prefixEvent: 'aside',\r\n      placement: 'right',\r\n      templateUrl: 'aside/aside.tpl.html',\r\n      contentTemplate: false,\r\n      container: false,\r\n      element: null,\r\n      backdrop: true,\r\n      keyboard: true,\r\n      html: false,\r\n      show: true\r\n    };\r\n\r\n    this.$get = function ($modal) {\r\n\r\n      function AsideFactory (config) {\r\n\r\n        var $aside = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n\r\n        $aside = $modal(options);\r\n\r\n        return $aside;\r\n\r\n      }\r\n\r\n      return AsideFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsAside', function ($window, $sce, $aside) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink (scope, element, attr, transclusion) {\r\n        // Directive options\r\n        var options = {scope: scope, element: element, show: false};\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['backdrop', 'keyboard', 'html', 'container'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Support scope as data-attrs\r\n        angular.forEach(['title', 'content'], function (key) {\r\n          if (attr[key]) {\r\n            attr.$observe(key, function (newValue, oldValue) {\r\n              scope[key] = $sce.trustAsHtml(newValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Support scope as an object\r\n        if (attr.bsAside) {\r\n          scope.$watch(attr.bsAside, function (newValue, oldValue) {\r\n            if (angular.isObject(newValue)) {\r\n              angular.extend(scope, newValue);\r\n            } else {\r\n              scope.content = newValue;\r\n            }\r\n          }, true);\r\n        }\r\n\r\n        // Initialize aside\r\n        var aside = $aside(options);\r\n\r\n        // Trigger\r\n        element.on(attr.trigger || 'click', aside.toggle);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (aside) aside.destroy();\r\n          options = null;\r\n          aside = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\n// @BUG: following snippet won't compile correctly\r\n\r\nangular.module('mgcrea.ngStrap.alert', ['mgcrea.ngStrap.modal'])\r\n\r\n  .provider('$alert', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      prefixClass: 'alert',\r\n      prefixEvent: 'alert',\r\n      placement: null,\r\n      templateUrl: 'alert/alert.tpl.html',\r\n      container: false,\r\n      element: null,\r\n      backdrop: false,\r\n      keyboard: true,\r\n      show: true,\r\n      // Specific options\r\n      duration: false,\r\n      type: false,\r\n      dismissable: true\r\n    };\r\n\r\n    this.$get = function ($modal, $timeout) {\r\n\r\n      function AlertFactory (config) {\r\n\r\n        var $alert = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n\r\n        $alert = $modal(options);\r\n\r\n        // Support scope as string options [/*title, content, */ type, dismissable]\r\n        $alert.$scope.dismissable = !!options.dismissable;\r\n        if (options.type) {\r\n          $alert.$scope.type = options.type;\r\n        }\r\n\r\n        // Support auto-close duration\r\n        var show = $alert.show;\r\n        if (options.duration) {\r\n          $alert.show = function () {\r\n            show();\r\n            $timeout(function () {\r\n              $alert.hide();\r\n            }, options.duration * 1000);\r\n          };\r\n        }\r\n\r\n        return $alert;\r\n\r\n      }\r\n\r\n      return AlertFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsAlert', function ($window, $sce, $alert) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink (scope, element, attr, transclusion) {\r\n\r\n        // Directive options\r\n        var options = {scope: scope, element: element, show: false};\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'keyboard', 'html', 'container', 'animation', 'duration', 'dismissable'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['keyboard', 'html', 'container', 'dismissable'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // overwrite inherited title value when no value specified\r\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\r\n        if (!scope.hasOwnProperty('title')) {\r\n          scope.title = '';\r\n        }\r\n\r\n        // Support scope as data-attrs\r\n        angular.forEach(['title', 'content', 'type'], function (key) {\r\n          if (attr[key]) {\r\n            attr.$observe(key, function (newValue, oldValue) {\r\n              scope[key] = $sce.trustAsHtml(newValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Support scope as an object\r\n        if (attr.bsAlert) {\r\n          scope.$watch(attr.bsAlert, function (newValue, oldValue) {\r\n            if (angular.isObject(newValue)) {\r\n              angular.extend(scope, newValue);\r\n            } else {\r\n              scope.content = newValue;\r\n            }\r\n          }, true);\r\n        }\r\n\r\n        // Initialize alert\r\n        var alert = $alert(options);\r\n\r\n        // Trigger\r\n        element.on(attr.trigger || 'click', alert.toggle);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (alert) alert.destroy();\r\n          options = null;\r\n          alert = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.affix', ['mgcrea.ngStrap.helpers.dimensions', 'mgcrea.ngStrap.helpers.debounce'])\r\n\r\n  .provider('$affix', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      offsetTop: 'auto',\r\n      inlineStyles: true,\r\n      setWidth: true\r\n    };\r\n\r\n    this.$get = function ($window, debounce, dimensions) {\r\n\r\n      var bodyEl = angular.element($window.document.body);\r\n      var windowEl = angular.element($window);\r\n\r\n      function AffixFactory (element, config) {\r\n\r\n        var $affix = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n        var targetEl = options.target;\r\n\r\n        // Initial private vars\r\n        var reset = 'affix affix-top affix-bottom';\r\n        var setWidth = false;\r\n        var initialAffixTop = 0;\r\n        var initialOffsetTop = 0;\r\n        var offsetTop = 0;\r\n        var offsetBottom = 0;\r\n        var affixed = null;\r\n        var unpin = null;\r\n\r\n        var parent = element.parent();\r\n        // Options: custom parent\r\n        if (options.offsetParent) {\r\n          if (options.offsetParent.match(/^\\d+$/)) {\r\n            for (var i = 0; i < (options.offsetParent * 1) - 1; i++) {\r\n              parent = parent.parent();\r\n            }\r\n          } else {\r\n            parent = angular.element(options.offsetParent);\r\n          }\r\n        }\r\n\r\n        $affix.init = function () {\r\n\r\n          this.$parseOffsets();\r\n          initialOffsetTop = dimensions.offset(element[0]).top + initialAffixTop;\r\n          setWidth = options.setWidth && !element[0].style.width;\r\n\r\n          // Bind events\r\n          targetEl.on('scroll', this.checkPosition);\r\n          targetEl.on('click', this.checkPositionWithEventLoop);\r\n          windowEl.on('resize', this.$debouncedOnResize);\r\n\r\n          // Both of these checkPosition() calls are necessary for the case where\r\n          // the user hits refresh after scrolling to the bottom of the page.\r\n          this.checkPosition();\r\n          this.checkPositionWithEventLoop();\r\n\r\n        };\r\n\r\n        $affix.destroy = function () {\r\n\r\n          // Unbind events\r\n          targetEl.off('scroll', this.checkPosition);\r\n          targetEl.off('click', this.checkPositionWithEventLoop);\r\n          windowEl.off('resize', this.$debouncedOnResize);\r\n\r\n        };\r\n\r\n        $affix.checkPositionWithEventLoop = function () {\r\n\r\n          // IE 9 throws an error if we use 'this' instead of '$affix'\r\n          // in this setTimeout call\r\n          setTimeout($affix.checkPosition, 1);\r\n\r\n        };\r\n\r\n        $affix.checkPosition = function () {\r\n          // if (!this.$element.is(':visible')) return\r\n\r\n          var scrollTop = getScrollTop();\r\n          var position = dimensions.offset(element[0]);\r\n          var elementHeight = dimensions.height(element[0]);\r\n\r\n          // Get required affix class according to position\r\n          var affix = getRequiredAffixClass(unpin, position, elementHeight);\r\n\r\n          // Did affix status changed this last check?\r\n          if (affixed === affix) return;\r\n          affixed = affix;\r\n\r\n          if (affix === 'top') {\r\n            unpin = null;\r\n            if (setWidth) {\r\n              element.css('width', '');\r\n            }\r\n            if (options.inlineStyles) {\r\n              element.css('position', (options.offsetParent) ? '' : 'relative');\r\n              element.css('top', '');\r\n            }\r\n          } else if (affix === 'bottom') {\r\n            if (options.offsetUnpin) {\r\n              unpin = -(options.offsetUnpin * 1);\r\n            } else {\r\n              // Calculate unpin threshold when affixed to bottom.\r\n              // Hopefully the browser scrolls pixel by pixel.\r\n              unpin = position.top - scrollTop;\r\n            }\r\n            if (setWidth) {\r\n              element.css('width', '');\r\n            }\r\n            if (options.inlineStyles) {\r\n              element.css('position', (options.offsetParent) ? '' : 'relative');\r\n              element.css('top', (options.offsetParent) ? '' : ((bodyEl[0].offsetHeight - offsetBottom - elementHeight - initialOffsetTop) + 'px'));\r\n            }\r\n          } else { // affix === 'middle'\r\n            unpin = null;\r\n            if (setWidth) {\r\n              element.css('width', element[0].offsetWidth + 'px');\r\n            }\r\n            if (options.inlineStyles) {\r\n              element.css('position', 'fixed');\r\n              element.css('top', initialAffixTop + 'px');\r\n            }\r\n          }\r\n\r\n          // Add proper affix class\r\n          element.removeClass(reset).addClass('affix' + ((affix !== 'middle') ? '-' + affix : ''));\r\n\r\n        };\r\n\r\n        $affix.$onResize = function () {\r\n          $affix.$parseOffsets();\r\n          $affix.checkPosition();\r\n        };\r\n        $affix.$debouncedOnResize = debounce($affix.$onResize, 50);\r\n\r\n        $affix.$parseOffsets = function () {\r\n          var initialPosition = element[0].style.position;\r\n          var initialTop = element[0].style.top;\r\n          // Reset position to calculate correct offsetTop\r\n          if (options.inlineStyles) {\r\n            element.css('position', (options.offsetParent) ? '' : 'relative');\r\n            element.css('top', '');\r\n          }\r\n\r\n          if (options.offsetTop) {\r\n            if (options.offsetTop === 'auto') {\r\n              options.offsetTop = '+0';\r\n            }\r\n            if (options.offsetTop.match(/^[-+]\\d+$/)) {\r\n              initialAffixTop = - options.offsetTop * 1;\r\n              if (options.offsetParent) {\r\n                offsetTop = dimensions.offset(parent[0]).top + (options.offsetTop * 1);\r\n              } else {\r\n                offsetTop = dimensions.offset(element[0]).top - dimensions.css(element[0], 'marginTop', true) + (options.offsetTop * 1);\r\n              }\r\n            } else {\r\n              offsetTop = options.offsetTop * 1;\r\n            }\r\n          }\r\n\r\n          if (options.offsetBottom) {\r\n            if (options.offsetParent && options.offsetBottom.match(/^[-+]\\d+$/)) {\r\n              // add 1 pixel due to rounding problems...\r\n              offsetBottom = getScrollHeight() - (dimensions.offset(parent[0]).top + dimensions.height(parent[0])) + (options.offsetBottom * 1) + 1;\r\n            } else {\r\n              offsetBottom = options.offsetBottom * 1;\r\n            }\r\n          }\r\n\r\n          // Bring back the element's position after calculations\r\n          if (options.inlineStyles) {\r\n            element.css('position', initialPosition);\r\n            element.css('top', initialTop);\r\n          }\r\n        };\r\n\r\n        // Private methods\r\n\r\n        function getRequiredAffixClass (_unpin, position, elementHeight) {\r\n          var scrollTop = getScrollTop();\r\n          var scrollHeight = getScrollHeight();\r\n\r\n          if (scrollTop <= offsetTop) {\r\n            return 'top';\r\n          } else if (_unpin !== null) {\r\n            return scrollTop + _unpin <= position.top ? 'middle' : 'bottom';\r\n          } else if (offsetBottom !== null && (position.top + elementHeight + initialAffixTop >= scrollHeight - offsetBottom)) {\r\n            return 'bottom';\r\n          }\r\n          return 'middle';\r\n        }\r\n\r\n        function getScrollTop () {\r\n          return targetEl[0] === $window ? $window.pageYOffset : targetEl[0].scrollTop;\r\n        }\r\n\r\n        function getScrollHeight () {\r\n          return targetEl[0] === $window ? $window.document.body.scrollHeight : targetEl[0].scrollHeight;\r\n        }\r\n\r\n        $affix.init();\r\n        return $affix;\r\n\r\n      }\r\n\r\n      return AffixFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsAffix', function ($affix, $window, $timeout) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      require: '^?bsAffixTarget',\r\n      link: function postLink (scope, element, attr, affixTarget) {\r\n\r\n        var options = {scope: scope, target: affixTarget ? affixTarget.$element : angular.element($window)};\r\n        angular.forEach(['offsetTop', 'offsetBottom', 'offsetParent', 'offsetUnpin', 'inlineStyles', 'setWidth'], function (key) {\r\n          if (angular.isDefined(attr[key])) {\r\n            var option = attr[key];\r\n            if (/true/i.test(option)) option = true;\r\n            if (/false/i.test(option)) option = false;\r\n            options[key] = option;\r\n          }\r\n        });\r\n\r\n        var affix;\r\n        $timeout(function () { affix = $affix(element, options); });\r\n        scope.$on('$destroy', function () {\r\n          if (affix) affix.destroy();\r\n          options = null;\r\n          affix = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsAffixTarget', function () {\r\n    return {\r\n      controller: function ($element) {\r\n        this.$element = $element;\r\n      }\r\n    };\r\n  });\r\n","\r\nangular.module('mgcrea.ngStrap', [\r\n  'mgcrea.ngStrap.modal',\r\n  'mgcrea.ngStrap.aside',\r\n  'mgcrea.ngStrap.alert',\r\n  'mgcrea.ngStrap.button',\r\n  'mgcrea.ngStrap.select',\r\n  'mgcrea.ngStrap.datepicker',\r\n  'mgcrea.ngStrap.timepicker',\r\n  'mgcrea.ngStrap.navbar',\r\n  'mgcrea.ngStrap.tooltip',\r\n  'mgcrea.ngStrap.popover',\r\n  'mgcrea.ngStrap.dropdown',\r\n  'mgcrea.ngStrap.typeahead',\r\n  'mgcrea.ngStrap.scrollspy',\r\n  'mgcrea.ngStrap.affix',\r\n  'mgcrea.ngStrap.tab',\r\n  'mgcrea.ngStrap.collapse'\r\n]);\r\n"],"sourceRoot":"/source/"}